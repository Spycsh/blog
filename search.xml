<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>GFS &amp; FDS</title>
      <link href="/blog/2021/09/01/GFS-FDS/"/>
      <url>/blog/2021/09/01/GFS-FDS/</url>
      
        <content type="html"><![CDATA[<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Why GFS?痛点</p><ul><li><p>GFS有多个clinet多个存储机器，应用程序bug、操作系统的bug、人为失误，甚至还有硬盘、内存、连接器、网络以及电源失效，这些都会导致组件失效，因此文件系统必须有持续的监控，冗余，自动恢复的机制。</p></li><li><p>文件很大，GB级，传统操作系统里文件存取的最小单位block是4KB，处理TB数据集时，用数亿KB大小的小文件是不明智的。</p></li><li><p>处理大型数据集，对块的缓存没有意义，因为不够缓存，只能流式处理，顺序读，append写。<strong>不再存在overwrite写与随机写</strong>。</p></li><li><p>应用程序与API的协同设计。只保证原子性的追加，保证多客户端同时追加，而<strong>不需要额外的同步来保证数据的一致性</strong>。</p></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>GFS中，一个大文件会分为多个chunks，一个chunk是固定64MB的，是存储的基本单元，一个chunk对应了一个linux file。</p><p>这么大的chunk size，好处是减少了clinet和master的交互次数，也减少了metadata的overhead。</p><p>碎片化是个问题，因此采用惰性空间分配方式。这种分配方式只在需要时分配资源，就像singleton设计模式一样。但是仍然有坏处，那就是当很多client都访问这个file时，chunk因为很大，很容易成为hot spots。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>GFS有一个master，多个chunkserver，master和chunkserver都可能和client交互。</p><p>master存储metadata，包括namespaces，access control information（ACLs）, mapping from files to chunks，和chunks的地址。所有metadata存在master内存中，前两种是被持久化在本地磁盘和远程机器的operation log中。使用log可以让我们简单地更新主节点状态。</p><p>master并不持久化存储chunk副本地址，只是启动时向每个chunkserver确认它们上面chunk的地址。</p><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p>GFS 中，clinet只向master讯问数据块放在哪个chunkserver上（用文件名和字节偏移翻译成chunk index，发index和文件名给master），得到结果后后，然后去向最近的chunkserver请求数据。它不是直接向master请求数据。client同样对这些结果进行缓存，一段时间内都从同一个chunkserver请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">论文2.4节</span><br><span class="line">1. Application invokes read (filename, offset)</span><br><span class="line">2. Client library translates offset to chunk index and</span><br><span class="line">sends it to master (filename, chunk index)</span><br><span class="line">3. Master responds with handle (chunk handle, replica</span><br><span class="line">locations)</span><br><span class="line">4. Client library selects location and sends (handle,</span><br><span class="line">offset) to it</span><br><span class="line">5. Chunk server responds with requested data</span><br><span class="line">6. Data is forwarded to application</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Master上的Metadata</span><br><span class="line">## 存储了file对chunk的映射, **一个很大的文件可以被分成多个chunk，比如下面的043131文件被分到chunk4, chunk5上，都是连续存储的，利用chunk index可以找到对应的chunk**</span><br><span class="line">/logs/021512.log: B1, B2, B3</span><br><span class="line">/logs/043131.log: B4, B5</span><br><span class="line">## block(chunk)在哪些节点上（地址）</span><br><span class="line">B1: A, B, D</span><br><span class="line">B2: B, D, E</span><br><span class="line">B3: A, B, E</span><br><span class="line">B4: A, B, E</span><br><span class="line">B5: C, E, D</span><br><span class="line"></span><br><span class="line">client 首先在本地计算chunk index，利用chunk size固定是64MB这一个特性，如果我的文件是640MB，我想读后一半的数据，chunk index就可以计算出来是5 ~ 9(假设从0开始)，然后，这里比如043131.log大小是120M（用来两个chunk存储它），我想要读043131.log的一部分数据（offset=80MB~120MB部分)，由80MB/64MB=1, 120MB/64MB=1那么就计算出chunk index=1~1，那么master收到文件名和chunk index之后，就会在metadata内存中去通过文件名找到对应的chunks，也就是B4、B5，通过index=1发现应该读B5，就会去看存有B5的replicas（chunkserver）的地址，也就是C,E,D，返回给client这些server的hostname。由此一来，client就可以缓存这些hostnames，然后挑最近的去请求相应的数据了，下一次client就不用再询问master，直接通过缓存里去拿就行了。</span><br></pre></td></tr></table></figure><h2 id="master高可用"><a href="#master高可用" class="headerlink" title="master高可用"></a>master高可用</h2><p>master单点故障问题，需要一个operation log来确保，它是持久化的在master和其backup上的。master存储metadata，所有对metadata的修改都是有操作日志的。master有冗余的backup，确保master挂了，backup可以通过operation log反推出master的state。</p><p>gfs在什么时间写master的op log呢？每次client和master的交互，gfs会同步的将操作日志记录在本地，并发送到backup节点，操作日志写入到本地和远程的磁盘都成功，才会返回给客户端。</p><p>如何处理op log不断增大，从而减缓master startup恢复状态的问题呢？使用checkpoint，checkpoint前的数据都已落盘。op log只记录之后对metadata的操作。op log是一个compact B-tree，可以映射到内存中（论文2.6.3），每次checkpoint过程是在另一个线程中完成的，因此不会阻塞。只有成功的checkpoint会被用来恢复状态，失败的会被跳过。</p><h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>gfs对外提供的一致性保证中，提供了4种语义。分别是：</p><p>consistent：所有client都能读到相同的data<br>defined：consistent且都能完整的读到最新的写入<br>inconsistent and also undefined：不同的client在不同的时间看到不同的内容。（我的理解是：这个状态下的data已经损坏）<br>undefined but consistent：所有client都能读到相同的data，但data可能是错误的（就是发生了并发写的问题导致data错误）</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>GFS不是POSIX-compliant的，但是提供了create，delete，open，close，read和write操作。另外还支持了snapshot(create a compy of a file or a directory tree at a low cost)和append(allow multiple clients to append data to the same file concurrrently)操作。</p><p>另外还有update操作，是对metadata的改动。为了consistency，GFS保证了只在primary上定义了update的order，所有replica follow，用lease保证了正确性。每个周期T，master会给一个chunkserver一个lease指定它是primary。</p><p>读操作上面已经讲过了，下面介绍写操作。write 操作可以将任意⻓度 len 的数据写入到任意指定文件的位置 offset。</p><p>首先依然是client translate请求(file name ,chunk index)并发给master，master回应一个chunk handle和replica locations。</p><p>其次，client把要写的数据发到所有的副本上，数据将被存在chunkservers的internal buffers上，此时还没有落盘。</p><p>最后，client发写请求给primary（Sync请求），由primary决定serial order，并告知副本这个order，副本把buffer里的数据依照相同顺序写入磁盘。然后，primary等待所有从副本的sync响应，然后回复client成功响应。</p><p>我们将拥有一致的副本，然而，文件区域将会包含不同clients的mingled fragments，比如说对不同chunks的写入，由于每个chunk有一个primary，但不代表不同chunks的primary相同，因此可能顺序不一样，因此write是consistent的，但是是undefined的。</p><p>record append 操作可以原子的将 len&lt;=16MB 的数据写入到指定文件的末尾。不是简单的 offset 等于文件末尾的 write 操作。 record append 是具有原子特性的操作。</p><p>下面用两个例子简述差别，摘自<a href="https://www.infoq.cn/article/6r4tafyggnyynu7tesiy" target="_blank" rel="noopener">链接</a>，<a href="https://www.modb.pro/db/81505" target="_blank" rel="noopener">链接</a></p><p>例子 1，文件目前有 2 个 chunk，分别是 chunk1, chunk2。</p><p>Client 1 要在 54MB 的位置写入 20MB 数据。这写入跨越了边界，要分解成 2 个操作，第一个操 作写入 chunk1 最后 10 MB，第二个操作写入 chunk2 的开头 10MB。Client 2 也要在 54MB 的位置写入 20MB 的数据。这个写入也跨越边界，也要分解为 2 个操作， 作为第三个操作写入 chunk1 最后 10 MB，作为第四个操作写入 chunk2 的开头 10MB。</p><p>2 个客户端并发写入数据，那么第一个操作和第三个操作在 chunk1 上就是并发执行的，第二个操作和第四个操作在 chunk2 上并发执行，如果 chunk1 的先执行第一操作再执行第三个操作， chunk2 先执行第四个操作再执行第二个操作，那么最后，在 chunk1 上会保留 client 1 的写入的 数据，在 chunk2 上保留了 client 2 的写入的数据。虽然 client 1 和 client 2 的写入都成功了，但最后既不是 client 1 想要的结果，也不是 client 2 想要的结果。最后的结果是 client 1 和 client 2 写入 的混合。对于 client 1 和 client 2 来说，他们操作都不是原子的。</p><p>例子 2，文件目前有 2 个 chunk，分别是 chunk1, chunk2。</p><p>Client 要在 54MB 的位置写入 20MB 数据。这写入跨越了边界，要分解成 2 个操作，第一个操作 写入 chunk1 最后 10 MB，第二个操作写入 chunk2 的开头 10MB。chunk1 执行第一个操作成功 了，chunk2 执行第二个操作失败了，也就是写入的这部分数据，一部分是成功的，一部分是 失败的，这也不是原子操作。</p><p>接下来看 record append。由于 record append 最多能写入 16MB 的数据，并且当写入的数据量 超过块的剩余空间时，剩余的空间会被填充，这次写入操作会在下个块重试，这 2 点保证了 record append 操作只会在一个块上生效。这样就避免了跨越边界分解成多个操作，从而也就避免了，写入的数据一部分成功一部分失败，也避免了并发写入数据混合在一起，这 2 种非原子性的行为。</p><h2 id="Master操作"><a href="#Master操作" class="headerlink" title="Master操作"></a>Master操作</h2><p>控制流与数据流分离是GFS的最大特点，而Master主要做的事情就是控制流。</p><ul><li><p>Namespace management and locking<br>namespace会表示成一个lookup table，存储了全路径名对metadata的映射，<br>internal nodes（文件夹）上读锁（读时别人不能写，删，重命名），leaf nodes（文件）上读写锁（写时别人不能读写删改）。</p></li><li><p>Replica placement  </p></li><li>Creating, re-replicating and re-balancing replicas<br>新的副本加到disk使用率最低的chunkserver上，限制每个chunkserver上recent的replica creation数量</li><li>garbage collection<br>文件删除会由master log，转为hidden file（回收站），3日后删除，metadata中消除</li><li>stale replica detection<br>如果一个replica fail了它就跟不上primary了，也就是过时了，需要区分过时的replica和不过时的，就要记录一个chunk version number，这个number每当授予一次lease，就会增加1。</li></ul><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>Master的容错是由shadow master提供的，实际是冗余容错，它会在master crash时提供read-only的服务。</p><p>Chunkserver的容错是由version number确保的，正如前面提到的。stale的chunkserver会被删除。</p><h2 id="GFS-与-HDFS"><a href="#GFS-与-HDFS" class="headerlink" title="GFS 与 HDFS"></a>GFS 与 HDFS</h2><table><thead><tr><th style="text-align:center">GFS</th><th style="text-align:center">HDFS</th></tr></thead><tbody><tr><td style="text-align:center">Master</td><td style="text-align:center">Namenode</td></tr><tr><td style="text-align:center">Chunkserver</td><td style="text-align:center">DataNode</td></tr><tr><td style="text-align:center">Operation Log Journal</td><td style="text-align:center">Edit Log</td></tr><tr><td style="text-align:center">Chunk</td><td style="text-align:center">Block</td></tr><tr><td style="text-align:center">Random ﬁle writes possible</td><td style="text-align:center">Only append is possible</td></tr><tr><td style="text-align:center">Multiple write/reader model</td><td style="text-align:center">Single write/multiple reader model</td></tr><tr><td style="text-align:center">Default chunk size: 64MB</td><td style="text-align:center">Default chunk size: 128MB</td></tr></tbody></table><h1 id="FDS"><a href="#FDS" class="headerlink" title="FDS"></a>FDS</h1><p>Flat Datacenter Storage (FDS): to “move the computation to data”, because remote access is slow due to oversubscription.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Data Storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>云原生，Docker和K8s</title>
      <link href="/blog/2021/08/27/%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%8CDocker%E5%92%8CK8s/"/>
      <url>/blog/2021/08/27/%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%8CDocker%E5%92%8CK8s/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>说起云原生，大家都不陌生，与之相关的两个工具也是耳熟能详，Docker和K8s。本文将简单介绍云原生这个概念和两个工具。</p><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p>云或云计算的根本是通过网络提供服务，也就是应用提供商比如youtube，netflix这种公司使用云提供商提供的云进行应用的设计，然后向大众提供一系列网络应用。云的特性有on-demand self service, ubiquitous network access, location transparent research pooling, rapid elasticity, measured service pay per use。使用云服务的用户无需与服务提供商直接交互，也能手机电脑等不同工具上访问云服务，计算资源也会以location transparent的形式供用户使用，快速的弹性使系统的capacity根据demand的变动而灵活变动（elastically provisioned），按需计费则表示系统服务商可以监控用户对云服务的使用情况进行收费。</p><h2 id="云服务模型"><a href="#云服务模型" class="headerlink" title="云服务模型"></a>云服务模型</h2><p>SaaS, PaaS, IaaS，就好比住房子，买房子，建房子。从公司层面看，从前往后需要考虑的事情依次增多。当然，灵活性也越大。</p><p>IaaS中，提供商提供一些资源比如网络，存储。一个例子比如AWS的EC2 instance和S3 storage，而给使用者提供了可以定制的虚拟机。</p><p>Paas中，提供商提供硬件和开发环境。一个例子比如Google App Engine。它本身不提供存储或网络，但是提供了runtime，IDE，编程接口，开发工具。</p><p>SaaS中，就是提供了可以用网络访问到的具体应用了。具体例子比如Gmail，GitHub。</p><p>从层次上看，IaaS提供了Virtualization, Server, Network, Storage，PaaS在IaaS之上又提供了O/S, Runtime, Middleware，SaaS在PaaS上又提供了Application和Data。</p><h2 id="云服务三种形式"><a href="#云服务三种形式" class="headerlink" title="云服务三种形式"></a>云服务三种形式</h2><ul><li>Vitual Machine</li><li>Containers</li><li>Serveless</li></ul><p>目前是Container最红火的时代。比如PaaS级别的Docker，由于它本身轻量，使得广大SaaS公司在构建云原生应用时，无需考虑不同组件版本的搭配和环境，可以在已有的只有MB级的镜像上构建自己的新镜像，从而为自己的应用服务。使用容器构建的一套服务集群网络，由大量容器构成，每个容器提供一种服务，比如MySQL数据库，ES查询，Redis缓存，Kafka消息队列。这些东西本身自己就由各自创造的公司打包成一个镜像可以从Docker Hub上拉取下来，组合在一起就可以也可以一个镜像，公司写一个docker compose文件来组合在一起，再docker run就给自己的SaaS应用部署好环境了。你也可以打包自己的容器进去，或者说进入这个容器，改变它的config文件。这样灵活的操作以及快速部署的形式在当下是最流行的。</p><p>Virtual Machine 常被拿来与Containers作比较，但是Virtual Machine实际上要兼顾更底层比如操作系统和设备驱动。由此相比docker更加笨重。</p><p>Serveless相比Container，VM，托管程度更高，开发者只需要关心应用的业务逻辑，连服务器的运维都托管给后台。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>在windows上从源构建emqx</title>
      <link href="/blog/2021/08/25/%E5%9C%A8windows%E4%B8%8A%E4%BB%8E%E6%BA%90%E6%9E%84%E5%BB%BAemqx/"/>
      <url>/blog/2021/08/25/%E5%9C%A8windows%E4%B8%8A%E4%BB%8E%E6%BA%90%E6%9E%84%E5%BB%BAemqx/</url>
      
        <content type="html"><![CDATA[<p>踩坑指南</p><p><a href="https://github.com/emqx/emqx" target="_blank" rel="noopener">https://github.com/emqx/emqx</a></p><p><a href="https://docs.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-160" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-160</a></p><p>step4</p><p>Choose workloads: “Desktop development with C++”</p><p>powershell</p><p>$Env:PATH</p><p>paht改成path<br>lnik.exe拼错</p><p>make 29行错，which bash有问题，选错了bash，把bash目录提到环境变量最上面</p><p>C:\Users\Spycsh\Desktop\emqx&gt;make<br>make: *** [Makefile:29: ensure-rebar3] Error 1</p><p>用git bash make</p><p>可能git不能https因为vpn，因此要配置vpn的代理地址<br>C:\Users\Spycsh&gt;git config –global https.proxy <a href="https://127.0.0.1:7890" target="_blank" rel="noopener">https://127.0.0.1:7890</a></p><p>C:\Users\Spycsh&gt;git config –global https.proxy <a href="https://127.0.0.1:7890" target="_blank" rel="noopener">https://127.0.0.1:7890</a></p><p>curl: (56) OpenSSL SSL_read: Connection was reset错误</p><p>git config –global http.sslVerify “false”</p><!-- installer中下载Windows Universal C Runtime --><p>decoder.c<br>c:/Users/Spycsh/Desktop/emqx/c_src/decoder.c(4): fatal error C1083: Cannot open include file: ‘assert.h’: No such file or directory</p><p>←[0mmake: *** [Makefile:78: emqx] Error 1</p><p>下载individual component：windows universal CRT SDK，不必配置环境变量C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt？：<br>这将会包括10.0.10240.0版本的ucrt，而下面的assert.h才是</p><p>？以上方法仍存疑</p><p>用在vs studio打开项目的方法解决</p><p>然后vcvarsall.bat x86_amd64</p><p>Compiling emqx_resource<br>Compiling emqx_authn<br>Compiling emqx_data_bridge<br>Compiling emqx_rule_actions<br>Compiling emqx_connector<br>[relup_helper] running gen_appups<br>operable program or batch file.not recognized as an internal or external command,<br>…<br>←[1mUncaught error in rebar_core. Run with DIAGNOSTIC=1 to see stacktrace or consult rebar3.crashdump<br>←[0mWhen submitting a bug report, please include the output of <code>rebar3 report &quot;your command&quot;</code><br>make: *** [Makefile:78: emqx] Error 1</p><p>改了rebar3要把原来_build文件夹删掉</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>操作系统面试</title>
      <link href="/blog/2021/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95/"/>
      <url>/blog/2021/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统面试题"><a href="#操作系统面试题" class="headerlink" title="操作系统面试题"></a>操作系统面试题</h1><a id="more"></a><h1 id="文件系统篇"><a href="#文件系统篇" class="headerlink" title="文件系统篇"></a>文件系统篇</h1><h2 id="提高文件性能的方式"><a href="#提高文件性能的方式" class="headerlink" title="提高文件性能的方式"></a>提高文件性能的方式</h2><ul><li>寄存器 1ns &lt;1KB</li><li>高速缓存 2ns 4MB</li><li>主存 10ns 1-8GB</li><li>磁盘 10ms 1-4TB</li></ul><h3 id="高速缓存来优化磁盘"><a href="#高速缓存来优化磁盘" class="headerlink" title="高速缓存来优化磁盘"></a>高速缓存来优化磁盘</h3><p>检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过高速缓存来完成。</p><p>如何查看高速缓存中需要的块？常用方法是将设备和磁盘地址进行hash操作。HashMap+LRU/MRU</p><p>高速缓存已满，就调入新的块，把原来某一块调出高速缓存，<strong>如果调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似</strong>。（因为可能还没有执行flush操作）</p><h3 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h3><p>对于顺序读取，对块k操作时就把k+1放进高速缓存。</p><h3 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h3><p>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。</p><p>在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：一次是访问 inode，一次是访问块。其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。</p><p>一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表。</p><h3 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h3><p>删除文件后，回收磁盘块，可能会造成空穴。windows的defrag会移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。SSD固态硬盘不能做碎片整理，反而磨损了自己。</p><h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><p>SSF最短路径优先算法，电梯算法。</p><h2 id="RAID的不同级别"><a href="#RAID的不同级别" class="headerlink" title="RAID的不同级别"></a>RAID的不同级别</h2><p>RAID 称为 磁盘冗余阵列，简称 磁盘阵列。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/lR_A3jbfRiRjchz_lyyKxw</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>kafka &amp; page cache &amp; zero copy</title>
      <link href="/blog/2021/08/18/kafka-page-cache/"/>
      <url>/blog/2021/08/18/kafka-page-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="kafka为什么那么快"><a href="#kafka为什么那么快" class="headerlink" title="kafka为什么那么快"></a>kafka为什么那么快</h1><a id="more"></a><h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>Linux中引入 Cache 层的目的是为了提高 Linux 操作系统对磁盘访问的性能。Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 Cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。Cache 层也正是磁盘 IOPS 为什么能突破 200 的主要原因之一。</p><p>在 Linux 的实现中，文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。Page Cache 主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read/write 操作的时候。Buffer Cache 则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</p><p>page cache与buffer cache的共同目的都是加速数据I/O：写数据时首先写到缓存，将写入的页标记为dirty，然后向外部存储flush，也就是缓存写机制中的write-back（另一种是write-through，Linux未采用）；读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作page cache和buffer cache，当内存不够用时也会用LRU等算法淘汰缓存页。</p><p>在Linux 2.4版本的内核之前，page cache与buffer cache是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。所以在2.4版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了page cache，那么同时buffer cache只需要维护块指向页的指针就可以了。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到buffer cache里。因此，我们现在提起page cache，基本上都同时指page cache和buffer cache两者，本文之后也不再区分，直接统称为page cache。</p><p>Kafka为什么不自己管理缓存，而非要用page cache？原因有如下三点：</p><ul><li>JVM中一切皆对象，数据的对象存储会带来所谓object overhead，浪费空间；</li><li>如果由JVM来管理缓存，会受到GC的影响，并且过大的堆也会拖累GC的效率，降低吞吐量；</li><li>进程重启，JVM自己管理的缓存数据会全部丢失，Page cache还在。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Producer ---pwrite--&gt;</span><br><span class="line">                    |</span><br><span class="line">   [(JVM Heap)      Page Cache] ---&gt;send file --&gt; Consumer</span><br><span class="line">                    |  |</span><br><span class="line">                    sync</span><br><span class="line">                    |  |</span><br><span class="line">                    Disk</span><br></pre></td></tr></table></figure><p>producer生产消息时，会使用pwrite()系统调用【对应到Java NIO中是FileChannel.write() API】按偏移量写入数据，并且都会先写入page cache里。consumer消费消息时，会使用sendfile()系统调用【对应FileChannel.transferTo() API】，零拷贝地将数据从page cache传输到broker的Socket buffer，再通过网络传输。</p><p>图中没有画出来的还有leader与follower之间的同步，这与consumer是同理的：只要follower处在ISR中，就也能够通过零拷贝机制将数据从leader所在的broker page cache传输到follower所在的broker。</p><p>如果Kafka producer的生产速率与consumer的消费速率相差不大，那么就能几乎只靠对broker page cache的读写完成整个生产-消费过程</p><p>两个问题：<br>JVM堆大小（5~8GB，剩下的系统内存都作为page cache空间以最大化I/O效率）？lagging consumer冷热数据问题（消费速率慢、明显落后的consumer大概率不在broker page cache中，它们不必要的读盘仍会使冷数据进入page cache）。</p><h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h2><p>producer -&gt; broker -&gt; consumer 数据传送的过程的性能影响到kafka的整天吞吐量。</p><p>传统的 Linux 系统中，标准的 I/O 接口（例如 read，write）都是基于数据拷贝操作的，即 I/O 操作会导致数据在内核地址空间的缓冲区和用户地址空间的缓冲区之间进行拷贝，所以标准 I/O 也被称作缓存 I/O。这样做的好处是，如果所请求的数据已经存放在内核的高速缓冲存储器中，那么就可以减少实际的 I/O 操作，但坏处就是数据拷贝的过程，会导致 CPU 开销。</p><h3 id="Producer-gt-broker"><a href="#Producer-gt-broker" class="headerlink" title="Producer -&gt; broker"></a>Producer -&gt; broker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = socket.read()// 读取网络数据 </span><br><span class="line">File file = new File() </span><br><span class="line">file.write(data)// 持久化到磁盘 </span><br><span class="line">file.flush()</span><br></pre></td></tr></table></figure><p>这一过程实际上发生了四次数据拷贝：</p><ul><li><p>首先通过 DMA copy 将网络数据拷贝到内核态 Socket Buffer</p></li><li><p>然后应用程序将内核态 Buffer 数据读入用户态（CPU copy）</p></li><li><p>接着用户程序将用户态 Buffer 再拷贝到内核态（CPU copy）</p></li><li><p>最后通过 DMA copy 将数据拷贝到磁盘文件</p></li></ul><p>网卡–DMA copy–&gt;Socket缓存区–CPU copy–&gt;用户缓存–CPU copy–&gt;内核缓存区–DMA copy–&gt;磁盘</p><p>kafka直接在内核空间完成落盘，而不用读到应用进程缓冲区（broker收到数据后持久化）。采用mmap文件（Memory Mapped Files，使用page来实现文件到物理内存的直接映射）映射实现内核缓冲区与应用程序内存的共享，也就是Page cache。</p><p>mmap 也有一个很明显的缺陷——不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。Kafka 提供了一个参数——producer.type 来控制是不是主动 flush；如果 Kafka 写入到 mmap 之后就立即 flush 然后再返回 Producer 叫同步(sync)；写入 mmap 之后立即返回 Producer 不调用 flush 就叫异步(async)，默认是 sync。</p><blockquote><p>DMA（Direct Memory Access）：直接存储器访问。DMA 是一种无需 CPU 的参与，让外设和系统内存之间进行双向数据传输的硬件机制。使用 DMA 可以使系统 CPU 从实际的 I/O 数据传输过程中摆脱出来，从而大大提高系统的吞吐率。</p></blockquote><p>然后就是DMA copy到磁盘文件。</p><h3 id="broker-到-Consumer"><a href="#broker-到-Consumer" class="headerlink" title="broker 到 Consumer"></a>broker 到 Consumer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer = File.read</span><br><span class="line">Socket.send(buffer)</span><br></pre></td></tr></table></figure><ul><li><p>首先通过系统调用将文件数据读入到内核态 Buffer（DMA 拷贝）</p></li><li><p>然后应用程序将内存态 Buffer 数据读入到用户态 Buffer（CPU 拷贝）</p></li><li><p>接着用户程序通过 Socket 发送数据时将用户态 Buffer 数据拷贝到内核态 Buffer（CPU 拷贝）</p></li><li><p>最后通过 DMA 拷贝将数据拷贝到 NIC Buffer</p></li></ul><p>Linux 2.4+ 内核通过 sendfile 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件 - 网络发送由一个 sendfile 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p><p>Kafka 在这里采用的方案是通过 NIO 的 transferTo/transferFrom 调用操作系统的 sendfile 实现零拷贝。总共发生 2 次内核数据拷贝、2 次上下文切换和一次系统调用，消除了 CPU 数据拷贝</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>在很多情况下，系统的瓶颈不是 CPU 或磁盘，而是网络 IO。</p><p>因此，除了操作系统提供的低级批处理之外，Kafka 的客户端和 broker 还会在通过网络发送数据之前，在一个批处理中累积多条记录 (包括读和写)。记录的批处理分摊了网络往返的开销，使用了更大的数据包从而提高了带宽利用率。</p><h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>Producer 可将数据压缩后发送给 broker，从而减少网络传输代价，目前支持的压缩算法有：Snappy、Gzip、LZ4。数据压缩一般都是和批处理配套使用来作为优化手段的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1488144" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1488144</a></p><p><a href="https://xie.infoq.cn/article/c06fea629926e2b6a8073e2f0" target="_blank" rel="noopener">https://xie.infoq.cn/article/c06fea629926e2b6a8073e2f0</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Emacs常用命令</title>
      <link href="/blog/2021/08/03/Emacs%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2021/08/03/Emacs%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Emacs常用的有用的命令汇总"><a href="#Emacs常用的有用的命令汇总" class="headerlink" title="Emacs常用的有用的命令汇总"></a>Emacs常用的有用的命令汇总</h1><a id="more"></a><p>启动/打开/新建文件: emacs example.erl</p><p>C-x表示按住CTRL键，然后按x</p><p>M-x表示先按住Alt键，然后按x</p><p>取消执行 C-g，按错键或中断emacs命令可以按C-g</p><p>翻页 C-v 上一页 M-v (view next screen)</p><p>移到行头 C-a，行尾 C-e，移到句首 M-a，到句尾 M-e，移到文档投 M-&lt;, 档尾 M-&gt;</p><p>删到行尾(剪贴) C-k ，删掉选中highlight的区域 C-w，黏贴 C-Y</p><p>C-x 1 （One Window) C-x 2 （two Window)</p><p>保存 C-x C-c</p><p>查看buffer C-x C-b</p><p>切换Mode（Fundamental原始编辑模式，C-mode,lisp-mode,tex-mode,text-mode等等）M-x fundamental-mode可以变回来，可以用tab补全</p><p>查找 C-s （forward）C-r (backward)，想要看下一个就可以再按C-s或C-r。按C-g可以取消搜索跳回原位置，按enter可以让游标停在找到的地方</p><p>grep替代品（使用regex），M-x occur</p><p>M-x replace 然后按tab，可以替换从光标开始所有的字符</p><p>Emacs的一些package：<br>M-x shell 开个shell</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB笔记</title>
      <link href="/blog/2021/08/02/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2021/08/02/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB的一些总结与实验"><a href="#MongoDB的一些总结与实验" class="headerlink" title="MongoDB的一些总结与实验"></a>MongoDB的一些总结与实验</h1><a id="more"></a><h1 id="MongoDB介绍"><a href="#MongoDB介绍" class="headerlink" title="MongoDB介绍"></a>MongoDB介绍</h1><p>MongoDB是一个面向文档的数据库。它没有“行”的概念，没有预定义的schema，key和value不再是固定的类型和大小。</p><p>MongoDB适合横向扩展，能自动处理跨集群的数据和负载，自动重新分配文档，以及将用户请求路由到正确的机器上。如果一个集群需要更大的容量，只需要向集群添加新服务器，MongoDB就会自动将现有数据向新服务器传送。</p><p>MongoDB支持二级索引、唯一索引、复合索引、地理空间索引、全文索引；支持聚合管道；支持时间有限的集合（session）和一定大小的集合（log）。支持存储大文件和metadata。</p><p>MongoDB主要目标是高性能，能对document进行dynamic padding，也能预分配数据文件来换取稳定的性能。它把尽可能多的内存当作缓存。但不追求关系型数据库的全部功能，而是把处理逻辑交给客户端代码实现。</p><h1 id="MongoDB基础"><a href="#MongoDB基础" class="headerlink" title="MongoDB基础"></a>MongoDB基础</h1><p>MongoDB中，document是基本单元，collection可以看作是一个拥有dynamic schema的表，一个实例可以有多个db，每个db有自己的collection。自带js shell。</p><p>一个基本的文档<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"greeting"</span>:<span class="string">"Hello, world!"</span>, <span class="string">"foo"</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><p>不能含有<code>\0</code>，这表示末尾。<code>.</code>和<code>$</code>具有特殊意义。</p><p>不能有重复的键，区分大小写，且区分类型。</p><p><strong>文档的键值对是有序的</strong>，会对字段重新排序。</p><p>shell打开mongo后默认有3个数据库，config（分片设置）、admin（身份验证）、local（不可复制，一台服务器所有本地集合都可存储在这个数据库）。如果要使用cms数据库中的blog.posts集合，就可以用cms.blog.posts。</p><h2 id="shell-操作"><a href="#shell-操作" class="headerlink" title="shell 操作"></a>shell 操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use blog</span><br><span class="line">post = &#123;<span class="string">"title"</span>:<span class="string">"example"</span>&#125;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">db.blog.insert(post)</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">db.blog.findOne()</span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">post.comments = []</span><br><span class="line">db.blog.update(&#123;<span class="attr">title</span>:<span class="string">"example"</span>&#125;,post)</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">db.blog.remove(&#123;<span class="attr">title</span>:<span class="string">"example"</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>近似类似于JSON，有null、布尔、数字、字符串、数组和对象这几种数据类型。不同的是，还添加了日期类型和一些其它数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"x"</span>:<span class="literal">null</span>&#125;</span><br><span class="line">&#123;<span class="string">"x"</span>:<span class="literal">true</span>&#125;</span><br><span class="line"><span class="comment">// 默认64位浮点型数值</span></span><br><span class="line">&#123;<span class="string">"x"</span>:<span class="number">3.14</span>&#125;</span><br><span class="line"><span class="comment">// 整型</span></span><br><span class="line">&#123;<span class="string">"x"</span> : NumberInt(<span class="string">"3"</span>)&#125;</span><br><span class="line"><span class="comment">// Long</span></span><br><span class="line">&#123;<span class="string">"x"</span> : NumberLong(<span class="string">"3"</span>)&#125;</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">&#123;<span class="string">"x"</span>:<span class="string">"foobar"</span>&#125;</span><br><span class="line"><span class="comment">// date类型：</span></span><br><span class="line"><span class="comment">//ISODate("2021-08-02T19:51:17.878Z")</span></span><br><span class="line">&#123;<span class="string">"x"</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span><br><span class="line"><span class="comment">// 正则, 不区分大小写</span></span><br><span class="line">&#123;<span class="string">"x"</span>:<span class="regexp">/foobar/i</span>&#125;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">&#123;<span class="string">"x"</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]&#125;</span><br><span class="line"><span class="comment">// 内嵌文档</span></span><br><span class="line">&#123;<span class="string">"x"</span>:&#123;<span class="string">"foo"</span>:<span class="string">"bar"</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 对象id</span></span><br><span class="line">&#123;<span class="string">"x"</span>:ObjectId()&#125;</span><br><span class="line"><span class="comment">// js代码</span></span><br><span class="line">&#123;<span class="string">"x"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*...*/</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>每个文档都有一个ObjectId的12个字节（24个16进制数，举例：{“_id” : ObjectId(“5fe3c9b3f12bbe57b8f62978”)}）按照以下方式生成</p><p>0~3字节：4个字节的时间戳<br>4~6字节：3字节机器号（机器主机名的hash值）<br>7~8字节：2字节PID进程号<br>9~11字节：3字节自动增加的计数器，保证同一秒生成的ObjectId也是不一样的，允许每秒每个进程有2^24(16777216)个不同的ObjectId</p><h2 id="shell-tips"><a href="#shell-tips" class="headerlink" title="shell tips"></a>shell tips</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 连通别的计算机的Mongo实例</span><br><span class="line">mongo some-host:30000/myDB</span><br><span class="line">// 或者</span><br><span class="line">mongo --nodb</span><br><span class="line">conn = new Mongo(<span class="string">"some-host:30000"</span>)</span><br><span class="line">db = conn.getDB(<span class="string">"myDB"</span>)</span><br></pre></td></tr></table></figure><h1 id="增删查改文档"><a href="#增删查改文档" class="headerlink" title="增删查改文档"></a>增删查改文档</h1><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>插入一个文档到目标集合 <code>db.foo.insert({&quot;bar&quot;:&quot;baz&quot;})</code></p><p>批量插入多个文档到<strong>一个</strong>集合 <code>db.foo.batchInsert([{&quot;_id&quot;:0}, {&quot;_id&quot;:1}, {&quot;_id&quot;:2}])</code></p><p><strong>mongo shell中比较实验</strong><br>10000次插入，每次插入一条数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeInsert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start1 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">        db.test.insert(&#123;<span class="string">"foo"</span>:i, <span class="string">"oof"</span>:i&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> timeDiff1 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start1;</span><br><span class="line">    print(<span class="string">"insert 1000000 documents into MongoDB cost: "</span>+timeDiff1+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeInsert();</span><br></pre></td></tr></table></figure></p><p>1次插入1万条数据</p><blockquote><p>注意：mongo中的batchInsert方法已经废弃，直接用insert就行了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeBatchInsert = <span class="function"><span class="keyword">function</span>(<span class="params">records</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start2 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    db.test.insert(records);</span><br><span class="line">    <span class="keyword">var</span> timeDiff2 = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start2;</span><br><span class="line">    <span class="keyword">return</span> timeDiff2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">records = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">    records.push(&#123;<span class="string">"foo"</span>:i, <span class="string">"oof"</span>:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeBatchInsert(records)</span><br></pre></td></tr></table></figure><p>实验结果得出，前者花费7216ms，后者花费134毫秒。可见，一次性insert多个记录要快得多。</p><p>一次发送多个文档会提高插入的速度。不能重复插入，如果一个插入失败，之前的都会成功，之后的都会插入失败（可以用<code>continueOnError</code>选项强制执行后续插入。</p><p>insert check：所有文档都需小于16MB，要查看某个文档doc的BSON大小（字节）可以在shell中执行Object.bsonsize(doc)。不包含非UTF-8的字符串，以及类型检查。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>删除<code>db.foo.remove()</code></p><p>删除mailing.list集合中所有”opt-out”为true的人<br><code>db.mailing.list.remove({&quot;opt-out&quot;:true})</code></p><p>直接drop删除集合更快<code>db.mailing.list.drop()</code></p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>先find到<strong>唯一</strong>记录再update<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">joe = db.people.findOne(&#123;<span class="string">"name"</span>:<span class="string">"joe"</span>,<span class="string">"age"</span>:<span class="number">20</span>&#125;);</span><br><span class="line"><span class="comment">// 添加一个新的子文档relationship</span></span><br><span class="line">joe.relationships = &#123;<span class="string">"friends"</span>:joe.friends, <span class="string">"enemies"</span>:joe.enemies&#125;;</span><br><span class="line"><span class="keyword">delete</span> joe.friends;</span><br><span class="line"><span class="keyword">delete</span> joe.enemies;</span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">db.people.update(&#123;<span class="string">"name"</span>:<span class="string">"joe"</span>&#125;, joe);</span><br></pre></td></tr></table></figure></p><p>问题是如果若有多个name叫joe的，那么update条件就必须唯一，可以使用_id来指明。</p><p><strong>而使用_id作为查询条件比随机字段速度更快，因为是通过_id建立了索引</strong>。</p><h2 id="使用修改器"><a href="#使用修改器" class="headerlink" title="使用修改器"></a>使用修改器</h2><p>总结的update模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.表名.update(&#123;过滤条件&#125;,</span><br><span class="line">    &#123;修改器:&#123;键，值&#125;&#125;)</span><br></pre></td></tr></table></figure><p>键的值加一<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.analytics.update(&#123;<span class="string">"url"</span>:<span class="string">"www.example.com"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"$inc"</span>:&#123;<span class="string">"pageviews"</span>:<span class="number">1</span>&#125;&#125;)   <span class="comment">// 用$inc修改器增加pageviews的值，增加1</span></span><br></pre></td></tr></table></figure></p><p>加/修改一对键值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;<span class="string">"_id"</span>:ObjectId(<span class="string">"..."</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"$set"</span>:&#123;<span class="string">"favorite book"</span>:<span class="string">"War and Peace"</span>&#125;&#125;) <span class="comment">// 用$set修改器加一对键值</span></span><br></pre></td></tr></table></figure></p><p>删除一对键值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;<span class="string">"_id"</span>:ObjectId(<span class="string">"..."</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"$unset"</span>:&#123;<span class="string">"favorite book"</span>:<span class="number">1</span>&#125;&#125;) <span class="comment">// 用$unset修改器删除1个键</span></span><br></pre></td></tr></table></figure></p><p>数组添加元素（如果没有就创建一个新的数组）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.blog.posts.update(&#123;<span class="string">"title"</span>:<span class="string">"A blog post"</span>&#125;,</span><br><span class="line">                     &#123;<span class="string">"$push"</span>:&#123;<span class="string">"comments"</span>:  <span class="comment">// $push</span></span><br><span class="line">                        &#123;<span class="string">"name"</span>:<span class="string">"joe"</span>,<span class="string">"email"</span>:<span class="string">"joe@example.com"</span>,</span><br><span class="line">                        <span class="string">"content"</span>:<span class="string">"nice post."</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>一次添加多个值<code>$push:{&quot;comments&quot;:{&quot;$each&quot;:[aa,bb]}}</code></p><p>数组删除元素<code>{&quot;$pop&quot;:{&quot;key&quot;:1}}</code></p><p>更多操作请查看原书</p><ul><li>修改器速度</li></ul><p>$inc较快因为能就地修改，由于在磁盘上，文档都是顺序写的，所以若一个文档变大了，原先的位置放不下这个文档，就要移到到集合另一个位置。这时就会修改集合的填充因子（padding factor），可以通过db.coll.stats()查看，初始值是1。<strong>之后插入的新文档都会拥有填充因子指定大小的增长空间，如果之后的插入中不再发生文档移到，填充因子会逐渐变小</strong>。</p><h2 id="upsert"><a href="#upsert" class="headerlink" title="upsert"></a>upsert</h2><p>upsert是一种特殊的更新，要是没有找到符合更新条件的文档，就会以这个条件和更新文档为基础创建一个新的文档。如果找到了匹配的文档，则正常更新。</p><p>最基础的方法（可能有多个进程同时运行代码，导致同时对给定URL插入到多个文档这样的race condition）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查这个页面是否有一个文档, url会自动转化成string</span></span><br><span class="line">blog = db.analytics.findOne(&#123;<span class="attr">url</span> : <span class="string">"/blog"</span>&#125;)</span><br><span class="line"><span class="comment">// 如果有，就将视图数加/并保存</span></span><br><span class="line"><span class="keyword">if</span> (blog) &#123;</span><br><span class="line">    blog.pageviews++;</span><br><span class="line">    db.analytics.save(blog);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  <span class="comment">// 否则为这个页面创建一个新文档</span></span><br><span class="line">    db.analytics.save(&#123;<span class="attr">url</span>:<span class="string">"/blog"</span>,<span class="attr">pageviews</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以防止race condition</strong>的原子性的upsert方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.analytics.update(&#123;<span class="string">"url"</span>:<span class="string">"/blog"</span>&#125;,&#123;<span class="string">"$inc"</span>:&#123;<span class="string">"pageviews"</span>:<span class="number">1</span>&#125;&#125;, <span class="literal">true</span>&#125;);            <span class="comment">// true表示upsert</span></span><br></pre></td></tr></table></figure></p><p><code>$setOnInsert</code>没有就创建字段并为它赋值，但是之后所有更新，字段值不再改变。</p><h2 id="更新多个文档"><a href="#更新多个文档" class="headerlink" title="更新多个文档"></a>更新多个文档</h2><p>为所有该生日用户都添加了gift键<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;<span class="string">"birthday"</span>:<span class="string">"10/13/1978"</span>&#125;, &#123;<span class="string">"$set"</span>:&#123;<span class="string">"gift"</span>:<span class="string">"Happy Birthday!"</span>&#125;&#125;, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 第四个参数设成true</span></span><br></pre></td></tr></table></figure></p><ul><li>应答式/非应答式写入</li></ul><p>非应答式写入不会抛出异常（比如插入重复键值）</p><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p><code>db.users.find({}, {&quot;username&quot; : 1, &quot;email&quot; : 1})</code> 只返回username，email信息</p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>“$lt”,”$lte”,”$gt”,”gte”, “$ne”比较操作符<br><code>db.users.find({&quot;age&quot; : {&quot;$gte&quot; : 18, &quot;$lte&quot; : 30}})</code></p><p><code>db.users.find({&quot;registered&quot;:{&quot;$lt&quot;:new Date(&quot;01/01/2007&quot;)}})</code></p><p>另外，可以用”$in”,”$nin”,”$or”,”$not”,”$mod”,”$not”等，参见原书。</p><h2 id="特定类型的查询"><a href="#特定类型的查询" class="headerlink" title="特定类型的查询"></a>特定类型的查询</h2><p>MongoDB使用Perl兼容的正则表达式（PCRE）来匹配。</p><p><code>db.users.find({&quot;name&quot;: /joe/i})</code></p><p>查询前10个（后10个就slice改成-10，也可以用[23, 10]代表返回从24~33个元素<br><code>db.blog.posts.findOne(criteria, {&quot;comments&quot;:{&quot;$slice&quot;:10}})</code></p><p>查询内嵌文档（例如查询名字为joe的文档），<br>原来查询指定精确匹配的条件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span> : &#123;</span><br><span class="line">        <span class="string">"first"</span> : <span class="string">"Joe"</span>,</span><br><span class="line">        <span class="string">"last"</span> : <span class="string">"Schmoe"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">"age"</span> : <span class="number">45</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">db.people.find(&#123;<span class="string">"name"</span> : &#123;<span class="string">"first"</span> : <span class="string">"Joe"</span>, </span><br><span class="line"><span class="string">"last"</span> : <span class="string">"Schmoe"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果加一个middle名，就不能这样精确匹配，而是要用点表示法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.find(&#123;<span class="string">"name.first"</span>:<span class="string">"Joe"</span>,<span class="string">"name.last"</span>:<span class="string">"Schmoe"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>查询由Joe发表的5分以上的评论<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.blog.find()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"content"</span> : <span class="string">"..."</span>,</span><br><span class="line">    <span class="string">"comments"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"author"</span> : <span class="string">"joe"</span>,</span><br><span class="line">            <span class="string">"score"</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="string">"comment"</span> : <span class="string">"nice post"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"author"</span> : <span class="string">"mary"</span>,</span><br><span class="line">            <span class="string">"score"</span> : <span class="number">6</span>,</span><br><span class="line">            <span class="string">"comment"</span> : <span class="string">"terrible post"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用$elemMatch,不用的话会返回错误的记录</span></span><br><span class="line">&gt; db.blog.find(&#123;<span class="string">"comments"</span> : &#123;<span class="string">"$elemMatch"</span> : </span><br><span class="line">&#123;<span class="string">"author"</span> : <span class="string">"joe"</span>, <span class="string">"score"</span> : &#123;<span class="string">"$gte"</span> : <span class="number">5</span>&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>服务器脚本<br>在服务器上执行js脚本很容易受到注入攻击。</li></ul><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>数据库使用游标返回find的执行结果。客户端对游标的实现能对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者执行一些其他强大的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">...     db.collection.insert(&#123;<span class="attr">x</span> : i&#125;);</span><br><span class="line">... &#125;</span><br><span class="line">&gt; <span class="keyword">var</span> cursor = db.collection.find();</span><br><span class="line">&gt; <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">...     obj = cursor.next();</span><br><span class="line">...     <span class="comment">// do stuff</span></span><br><span class="line">... &#125;</span><br><span class="line">&gt; cursor.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">...     print(x.name);</span><br><span class="line">... &#125;);</span><br></pre></td></tr></table></figure><p>这样得到cursor的查询都没有真正执行，直到hasNext或next方法被调用时，查询被发往服务器，shell立刻获取前100个结果或者前4MB数据（两者较小者），这样下一次hasNext或next就不用再次连接服务器取结果了，直到用光第一组结果会再次联系数据库。</p><h3 id="limit，skip和sort"><a href="#limit，skip和sort" class="headerlink" title="limit，skip和sort"></a>limit，skip和sort</h3><p>下面几种是等价的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> cursor = db.foo.find().sort(&#123;<span class="string">"x"</span> : <span class="number">1</span>&#125;).limit(<span class="number">1</span>).skip(<span class="number">10</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> cursor = db.foo.find().limit(<span class="number">1</span>).sort(&#123;<span class="string">"x"</span> : <span class="number">1</span>&#125;).skip(<span class="number">10</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> cursor = db.foo.find().skip(<span class="number">10</span>).limit(<span class="number">1</span>).sort(&#123;<span class="string">"x"</span> : <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>sort按照username升序以及age降序<code>db.c.find().sort({username : 1, age : -1})</code></p><h3 id="获取一致性结果"><a href="#获取一致性结果" class="headerlink" title="获取一致性结果"></a>获取一致性结果</h3><p>当cursor hasNext时，一个文档改了之后，如果体积变大了，再存进去，就会放到集合末尾，也会再最后被重新遍历到。为此必须使用snapshot，查询就会在”_id”索引上遍历执行，这样就可以保证每个文档只被返回一次。</p><p><code>db.foo.find().snapshot()</code></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><p><strong>一个比较创建索引前后的实验</strong></p><p>书上的例子已过时，具体参考<a href="https://docs.mongodb.com/manual/reference/method/db.collection.explain/" target="_blank" rel="noopener">文档</a>，原来的执行时间<code>millis</code>属性已被改成<code>executionStats.executionTimeMillis</code>，以下是一个正确的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt; <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">... db.users.insert(</span><br><span class="line">...   &#123;</span><br><span class="line">...     <span class="string">"i"</span>:i,</span><br><span class="line">...     <span class="string">"username"</span>:<span class="string">"user"</span>+i,<span class="string">"age"</span>:<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">120</span>),<span class="string">"created"</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span><br><span class="line">... );</span><br><span class="line">... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.users.find(&#123;<span class="attr">username</span>:<span class="string">"user101"</span>&#125;).explain(<span class="string">"executionStats"</span>).executionStats</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"executionSuccess"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"nReturned"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"executionTimeMillis"</span> : <span class="number">62</span>,</span><br><span class="line">        <span class="string">"totalKeysExamined"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"totalDocsExamined"</span> : <span class="number">100000</span>,</span><br><span class="line">        <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,</span><br><span class="line">                <span class="string">"filter"</span> : &#123;</span><br><span class="line">                        <span class="string">"username"</span> : &#123;</span><br><span class="line">                                <span class="string">"$eq"</span> : <span class="string">"user101"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"nReturned"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"works"</span> : <span class="number">100002</span>,</span><br><span class="line">                <span class="string">"advanced"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"needTime"</span> : <span class="number">100000</span>,</span><br><span class="line">                <span class="string">"needYield"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"saveState"</span> : <span class="number">100</span>,</span><br><span class="line">                <span class="string">"restoreState"</span> : <span class="number">100</span>,</span><br><span class="line">                <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                <span class="string">"docsExamined"</span> : <span class="number">100000</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在username上建立索引：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.users.ensureIndex(&#123;<span class="string">"username"</span> : <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.users.find(&#123;<span class="attr">username</span>:<span class="string">"user101"</span>&#125;).explain(<span class="string">"executionStats"</span>).executionStats</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"executionSuccess"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"nReturned"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"totalKeysExamined"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"totalDocsExamined"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                <span class="string">"nReturned"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"works"</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">"advanced"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"needYield"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"saveState"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"restoreState"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"docsExamined"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"alreadyHasObj"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                        <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                        <span class="string">"nReturned"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"works"</span> : <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"advanced"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"needYield"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"saveState"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"restoreState"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">                                <span class="string">"username"</span> : <span class="number">1</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">"indexName"</span> : <span class="string">"username_1"</span>,</span><br><span class="line">                        <span class="string">"isMultiKey"</span> : <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"multiKeyPaths"</span> : &#123;</span><br><span class="line">                                <span class="string">"username"</span> : [ ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">"isUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"isSparse"</span> : <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"isPartial"</span> : <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"indexVersion"</span> : <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                        <span class="string">"indexBounds"</span> : &#123;</span><br><span class="line">                                <span class="string">"username"</span> : [</span><br><span class="line">                                        <span class="string">"[\"user101\", \"user101\"]"</span></span><br><span class="line">                                ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="string">"keysExamined"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"seeks"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"dupsTested"</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">"dupsDropped"</span> : <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，executionTimeMillis执行时间显著减少。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>在如下的sort代码中，对单个username建索引作用不大，因为sort是先对age进行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.users.find().sort(&#123;<span class="string">"age"</span> : <span class="number">1</span>, <span class="string">"username"</span> : <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>此时可以建立复合索引compound index <code>db.users.ensureIndex({&quot;age&quot; : 1, &quot;username&quot; : 1})</code></p><p>例子：假设我们有一个users集合，如果在这个集合上执行一个自然顺序的查询。如何建立索引？如何查询比较快？</p><p>复合索引结构大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, &quot;user100309&quot;] -&gt; 0x0c965148</span><br><span class="line">[0, &quot;user100334&quot;] -&gt; 0xf51f818e</span><br><span class="line">[0, &quot;user100479&quot;] -&gt; 0x00fd7934</span><br></pre></td></tr></table></figure></p><blockquote><p>对索引的使用方式取决于查询的类型</p></blockquote><ul><li>db.users.find({“age”:21}).sort({“username”:-1})</li></ul><p>Mongo从age等于21匹配的最后一个索引开始，逆序依次遍历索引。</p><ul><li>db.users.find({“age”:{“$gte”:21,”$lte”:30}})</li></ul><p>查询结果按照索引顺序排列，也即先age再username</p><p>应当特别注意，用来排列的键可能是字符串类型，也就是1、10、100这样</p><ul><li>db.users.find({“age”:{“$gte”:21,”$lte”:30}}).sort({“username”:1})</li></ul><p>这样第一个find得到的结果username是无序的，尤其是当find的<strong>结果集</strong>大于32MB进行排序就会报错，因此如果文档很大，使用<code>{&quot;username&quot; : 1，&quot;age&quot; : 1}</code>作索引。先对username有序sort，再对sort的结果集进行find，这样也有缺点就是find的时间会很长，需要对全表扫描。</p><blockquote><p>《高性能MySQL》一书中提到的一个经验法则：将选择性最高的列放到索引最前列。”选择性最高”指的是差异性最大，也即这一列的重复值最少.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前者时间显著大于后者</span></span><br><span class="line"></span><br><span class="line">&gt; db.users.find(&#123;<span class="string">"age"</span> : &#123;<span class="string">"$gte"</span> : <span class="number">21</span>, <span class="string">"$lte"</span> : <span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"username"</span> : <span class="number">1</span>&#125;).explain()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过hint来强制MongoDB使用某个特定的索引</span></span><br><span class="line">&gt; db.users.find(&#123;<span class="string">"age"</span> : &#123;<span class="string">"$gte"</span> : <span class="number">21</span>, <span class="string">"$lte"</span> : <span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"username"</span> : <span class="number">1</span>&#125;).hint(&#123;<span class="string">"username"</span> : <span class="number">1</span>, <span class="string">"age"</span>:<span class="number">1</span>&#125;).explain()</span><br></pre></td></tr></table></figure><p>但是，在上面用limit(1000)会发现后者比前者快很多。</p><p>ensureIndexes()添加索引<code>db.users.ensureIndex({&#39;username&#39;: 1})</code>, 1代表从小到大顺序<br>getIndexes()查看索引<code>db.users.getIndexes()</code><br>dropIndex删除索引<code>db.users.dropIndex(&quot;username_1&quot;)</code></p><h2 id="何时不应该用索引"><a href="#何时不应该用索引" class="headerlink" title="何时不应该用索引"></a>何时不应该用索引</h2><p>文档较小，集合较小或非选择性查询时，不应该使用索引。想象每次要返回集合95%的文档，还不如不建索引。区间查询时，使用索引就可以顺序的取文档出来，索引就很有用。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>唯一索引</li></ul><p>可以确保集合的每个文档的指定键都有唯一值。</p><p>db.users.ensureIndex({‘username’: 1, unique: true}) ，指定unique: true，如果插入2个相同都叫张三的数据，第二次插入的则会失败。_id即为唯一索引，并且不能删除。</p><ul><li>稀疏索引</li></ul><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>对数据进行分析并加以利用，就可以只有MondoDB提供的聚合工具。</p><h2 id="聚合框架"><a href="#聚合框架" class="headerlink" title="聚合框架"></a>聚合框架</h2><p>用多个component创建一个pipeline，对一连串的文档处理，这样的component包括filtering、projecting、grouping、sorting、limiting和skipping。</p><p><strong>一个例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将每个文章文档中的作者投射出来。</span></span><br><span class="line"><span class="comment">// 2. 将作者按照名字排序，统计每个名字出现的</span></span><br><span class="line"><span class="comment">// 次数。</span></span><br><span class="line"><span class="comment">// 3. 将作者按照名字出现次数降序排列。</span></span><br><span class="line"><span class="comment">// 4. 将返回结果限制为前5个。</span></span><br><span class="line">db.articles.aggregate(</span><br><span class="line">    &#123;<span class="string">"$project"</span>:&#123;<span class="string">"author"</span>:<span class="number">1</span>&#125;&#125;,  <span class="comment">// 每个文档会以&#123;"_id":id,"author":"authorName"&#125;形式表示，并且只存在内存中</span></span><br><span class="line">    &#123;<span class="string">"$group"</span>:&#123;<span class="string">"_id"</span>:<span class="string">"$author"</span>,<span class="string">"count"</span>:&#123;<span class="string">"$sum"</span>:<span class="number">1</span>&#125;&#125;&#125;,    <span class="comment">// </span></span><br><span class="line">    &#123;<span class="string">"$sort"</span>:&#123;<span class="string">"count"</span>:<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">"$limit"</span>:<span class="number">5</span>&#125;)</span><br></pre></td></tr></table></figure><p>聚合的结果必须要限制在16 MB以内（MongoDB支持的最大响应消息大小）</p><h2 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h2><p><code>$match</code>: { $match : { score : { $gt : 70, $lte : 90 } } }</p><p><code>$project</code>: {“$project” : {“author” : 1, “_id” : 0}} 包括author，不包括_id</p><p><code>$group</code>: $group: { _id: null, count: { $sum: 1 } }</p><p>相当于<code>select *, count(*) from mycol group by by_user</code></p><p>$sum, $avg, $min, $max, $push, $addToSet, $first, $last</p><p><code>$unwind</code>: 拆分一篇有多条评论的博客文章到多个独立的文档。</p><p><code>$sort</code>：与$group一样，$sort也是一个无法使用流式工作方式的操作符。”$sort”也必须要接收所有文档后才能进行排序。在分片环境下，先在各个分片上排序，再将各个分片排序结果发到mongos做进一步处理。</p><p><code>$limit</code>：返回集合前n个文档</p><p><code>$skip</code>：丢弃结果集的前n个文档</p><p><strong>顺序</strong>：”$project”,”$group”,”$unwind”操作应当最先运行，将尽可能多的文档和字段过滤掉。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>有些问题过于复杂，无法用聚合框架的查询语言表达，可以使用MapReduce。</p><p>map-shuffle-reduce</p><p>map to all documents -&gt; group the key values by key -&gt; reduce the values corresponding to one key to one single value</p><h3 id="例子1：wordCount"><a href="#例子1：wordCount" class="headerlink" title="例子1：wordCount"></a>例子1：wordCount</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>)&#123;   <span class="comment">// this is the reference to the current document that is mapped to</span></span><br><span class="line">        emit(key, &#123;<span class="attr">count</span>:<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reduce = <span class="function"><span class="keyword">function</span>(<span class="params">key, emits</span>)</span>&#123;</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> emits)&#123;</span><br><span class="line">        total += emits[i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"count"</span>:total&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mongodb可能将这样调用reduce</span></span><br><span class="line">&gt; r1 = reduce(<span class="string">"x"</span>,[&#123;<span class="attr">count</span>:<span class="number">1</span>,<span class="attr">id</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">count</span>:<span class="number">1</span>,<span class="attr">id</span>:<span class="number">2</span>&#125;])</span><br><span class="line">&#123;<span class="attr">count</span>:<span class="number">2</span>&#125;</span><br><span class="line">&gt; r2 = reduce(<span class="string">"x"</span>,[&#123;<span class="attr">count</span>:<span class="number">1</span>,<span class="attr">id</span>:<span class="number">3</span>&#125;])</span><br><span class="line">&#123;<span class="attr">count</span>:<span class="number">1</span>&#125;</span><br><span class="line">&gt; reduce(<span class="string">"x"</span>, [r1,r2])</span><br><span class="line">&#123;<span class="attr">count</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>reduce一定要能够在之前的map阶段或者前一个reduce阶段的结果上反复执行。所以reduce返回的文档必须能作为reduce的第二个参数的一个元素</p></blockquote><h1 id="应用程序设计"><a href="#应用程序设计" class="headerlink" title="应用程序设计"></a>应用程序设计</h1><h2 id="范式化与反范式化"><a href="#范式化与反范式化" class="headerlink" title="范式化与反范式化"></a>范式化与反范式化</h2><p>student, class 表，需要范式化(normalization)吗？MongoDB没有join，如果范式化，查询需要多次查询；如果不范式化(denormalization)，把classes信息内嵌到student表中，更新某个字段（比如credits）就需要更新许多记录，不划算。</p><blockquote><p>第一范式（1NF，Normal Forms），列不能分成其他几列；第二范式，必须有一个主键，其他列不能只依赖于主键的一部分；第三范式，任何非主属性不依赖于其它非主属性。</p></blockquote><p>内嵌数据与引用数据的比较：</p><hr><table><thead><tr><th style="text-align:center">更适合内嵌</th><th style="text-align:center">major</th></tr></thead><tbody><tr><td style="text-align:center">子文档较小</td><td style="text-align:center">子文档较大</td></tr><tr><td style="text-align:center">数据不会定期改变</td><td style="text-align:center">数据经常改变</td></tr><tr><td style="text-align:center">最终数据一致即可</td><td style="text-align:center">中间阶段的数据必须一致</td></tr><tr><td style="text-align:center">文档数据小幅增加</td><td style="text-align:center">文档数据大幅增加</td></tr><tr><td style="text-align:center">数据通常需要执行二次查询才能获得</td><td style="text-align:center">数据通常不包含在结果中</td></tr><tr><td style="text-align:center">快速读取</td><td style="text-align:center">快速写入</td></tr></tbody></table><hr><h1 id="副本集实践"><a href="#副本集实践" class="headerlink" title="副本集实践"></a>副本集实践</h1><p>mongodb采用副本集方式实现冗余，以下是windows上模拟副本集（真实情况下应当在不同机器上模拟，条件有限）的实践过程</p><p>首先建立mongoReplTest文件夹，在下面建立三个data文件夹，对应三个节点，也就是一个主节点和两个从节点组成一个副本集。</p><p>然后，打开三个shell开启3个mongod服务，指定数据库存取文件夹位置，再指定同一个replication set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod --port 27018 --dbpath &quot;C:\Users\Spycsh\Desktop\mongoReplTest\data1&quot; --replSet rs0</span><br><span class="line">mongod --port 27019 --dbpath &quot;C:\Users\Spycsh\Desktop\mongoReplTest\data2&quot; --replSet rs0</span><br><span class="line">mongod --port 27020 --dbpath &quot;C:\Users\Spycsh\Desktop\mongoReplTest\data3&quot; --replSet rs0</span><br></pre></td></tr></table></figure></p><p>其次，打开三个shell开启3个mondo client<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongo localhost:27018</span><br><span class="line">mongo localhost:27019</span><br><span class="line">mongo localhost:27020</span><br></pre></td></tr></table></figure></p><p>在端口为27018（主节点）的clinet shell中，指定它是primary节点，在它里面建立一个叫test的数据库，建立一个叫test的表，再添加一条记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate()</span><br><span class="line">rs.conf()</span><br><span class="line">// 按一下回车就可以出现rs0:PRIMARY的标识</span><br><span class="line">rs0:PRIMARY&gt; use test</span><br><span class="line">rs0:PRIMARY&gt; db.createCollection(&quot;test&quot;)</span><br><span class="line">rs0:PRIMARY&gt; db.test.insert(&#123;&quot;test&quot;:1&#125;)</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; db.test.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;6112daf152385613cbb6bcfc&quot;), &quot;test&quot; : 1 &#125;</span><br></pre></td></tr></table></figure></p><p>再在主节点的client shell添加从节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs0:PRIMARY&gt; rs.add(&quot;localhost:27019&quot;)</span><br><span class="line">rs0:PRIMARY&gt; rs.add(&quot;localhost:27020&quot;)</span><br></pre></td></tr></table></figure></p><p>再到端口为27019，27020的从节点client shell中，按一下回车就可以发现它们都变成了SECONDARY节点，执行以下命令查看主节点复制过来的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs0:SECONDARY&gt; rs.secondaryOk()</span><br><span class="line">rs0:SECONDARY&gt; db.test.find()</span><br></pre></td></tr></table></figure></p><ul><li>把主节点变成从节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.stepDown()</span><br></pre></td></tr></table></figure></li></ul><p>然后在另两个shell里面按按回车，就可以看到有一个原来的从节点变成了主节点。如果没有节点变成主节点，该节点60s后会重新选举当主节点。</p><ul><li>阻止选举<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs.freeze(10000)    // 从节点冻结10000秒，不能参加选举。常用在主节点维护且不希望其它节点成为主节点情况下</span><br><span class="line">rs.freeze(0)        // 从节点解除冻结</span><br></pre></td></tr></table></figure></li></ul><h2 id="监控复制"><a href="#监控复制" class="headerlink" title="监控复制"></a>监控复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.status()</span><br></pre></td></tr></table></figure><ul><li>self 这个字段只会出现在执行rs.status()函数的成员信息中</li><li>stateStr 用于描述服务器状态的字符串。</li><li>uptime 从成员可达一直到现在所经历的时间，单位是秒。</li><li>optimeDate 每个成员的oplog中最后一个操作发生的时间（也就是操作被同步过来的时间）。注意，这里状态是每个成员通过心跳报告上来的状态，所以optime跟实际时间可能会有几秒钟的偏差。</li><li>lastHeartbeat 当前服务器最后一次收到其他成员心跳的时间。如果网络故障或者当前服务器比较繁忙，这个时间可能会是2秒钟之前。</li><li>pingMs 心跳从当前服务器到达某个成员所花费的平均时间，可以根据这个字段选择从哪个成员进行同步。</li><li>errmsg 成员在心跳请求中返回的状态信息。这个字段的内容通常只是一些状态信息，而不是错误信息。</li></ul><h3 id="复制图谱"><a href="#复制图谱" class="headerlink" title="复制图谱"></a>复制图谱</h3><p><strong>新的备份节点通常会从与自己处于同一个数据中心的其他成员进行复制</strong></p><p>如果在备份节点上运行rs.status()，输出信息中会有一个名为”syncSourceId”的字段，用于表示当前成员正在从哪个成员处进行复制。</p><h3 id="复制循环"><a href="#复制循环" class="headerlink" title="复制循环"></a>复制循环</h3><p>A从B复制数据，B从C，C从A，没有人能成为主节点，都不能复制写操作。</p><h3 id="禁用复制链"><a href="#禁用复制链" class="headerlink" title="禁用复制链"></a>禁用复制链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; var config = rs.config()</span><br><span class="line">&gt; // 如果设置子对象不存在，就自动创建一个空的</span><br><span class="line">&gt; config.settings = config.settings || &#123;&#125;</span><br><span class="line">&gt; config.settings.allowChaining = false</span><br><span class="line">&gt; rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>类似星型拓补</p><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>可以看作是没有自动故障恢复功能的副本集模式，已经弃用。</p><h1 id="分片（sharding）"><a href="#分片（sharding）" class="headerlink" title="分片（sharding）"></a>分片（sharding）</h1><p>也称为partitioning。指将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// replication set实现了冗余复制与故障恢复</span><br><span class="line">// sharding解决了大量数据的存储与负载的水平拓展</span><br><span class="line">// 如下是一个replication set和sharding都考虑的示意图</span><br><span class="line">// A1, A2...这些都表示不同的机器</span><br><span class="line">// (A1, A2, A3) 代表一个replication set，每个元素都有相同的数据集</span><br><span class="line">// (A1, B1, C1) 涵盖了所有的数据，比如A1负责数据key hash值</span><br><span class="line">// 0~999的，B负责1000~1999的...以此类推</span><br><span class="line">(A1, A2, A3)  --- (B1, B2, B3)</span><br><span class="line">    \             /</span><br><span class="line">     \           /</span><br><span class="line">     (C1, C2, C3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Data Storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用sftp在不同云主机间传递文件</title>
      <link href="/blog/2021/07/15/%E4%BD%BF%E7%94%A8sftp%E5%9C%A8%E4%B8%8D%E5%90%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6/"/>
      <url>/blog/2021/07/15/%E4%BD%BF%E7%94%A8sftp%E5%9C%A8%E4%B8%8D%E5%90%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="使用sftp在不同云主机间传递文件"><a href="#使用sftp在不同云主机间传递文件" class="headerlink" title="使用sftp在不同云主机间传递文件"></a>使用sftp在不同云主机间传递文件</h1><a id="more"></a><p>公司里的unix工作环境都部署在citrix云上，并且都没有接入互联网。想要给同事共享一个文件就很麻烦，需要复制黏贴代码到本地windows上再邮件发过去。</p><p>无意间想到一个sftp（secure file transport protocol），大家都知道ftp是不加密的传输，而sftp可以通过ssh建立一个可靠的链路进行文件传输，就尝试用了用，发现确实可以在远程unix工作环境启动sftp然后直接共享文件给同事的unix工作环境。</p><p>unix shell命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sftp username@192.168.xx.xx <span class="comment"># 打开sftp服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入远程用户的windows密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些操作，如果本地用命令就加一个l前缀就行了</span></span><br><span class="line">sftp&gt; lcd Desktop   <span class="comment"># cd到本地Desktop目录（local cd）</span></span><br><span class="line">sftp&gt; <span class="built_in">cd</span> Desktop    <span class="comment"># 远程cd到Desktop目录</span></span><br><span class="line">sftp&gt; ls Desktop    <span class="comment"># 查看远程桌面目录下的文件</span></span><br><span class="line">sftp&gt; lls Desktop   <span class="comment"># 查看本地桌面目录下的文件</span></span><br><span class="line">sftp&gt; <span class="built_in">pwd</span>           <span class="comment"># 查看远程工作目录</span></span><br><span class="line">sftp&gt; lpwd          <span class="comment"># 查看本地工作目录</span></span><br><span class="line">sftp&gt; get example.txt <span class="comment"># 下载文件</span></span><br><span class="line">sftp&gt; put example.txt <span class="comment"># 上传文件</span></span><br><span class="line">sftp&gt; mkdir new_dir</span><br><span class="line">sftp&gt; rmdir new_dir</span><br><span class="line"></span><br><span class="line">sftp&gt; <span class="built_in">exit</span> <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><p>详细用法可以<a href="https://geekflare.com/sftp-command-examples/" target="_blank" rel="noopener">参见</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDIA 数据密集型应用笔记 （III）</title>
      <link href="/blog/2021/07/13/DDIA-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0-III/"/>
      <url>/blog/2021/07/13/DDIA-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0-III/</url>
      
        <content type="html"><![CDATA[<h1 id="Design-Data-intensive-applications-II-–-派生数据"><a href="#Design-Data-intensive-applications-II-–-派生数据" class="headerlink" title="Design Data-intensive applications (II) – 派生数据"></a>Design Data-intensive applications (II) – 派生数据</h1><a id="more"></a><p>本章主要会介绍面向批处理（batch processing）和面向流的处理的数据系统。</p><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/nginx/access/<span class="built_in">log</span> |</span><br><span class="line">    awk <span class="string">'&#123;print $7&#125;'</span>    |</span><br><span class="line">    sort                |</span><br><span class="line">    uniq -c             |</span><br><span class="line">    sort -r -n          |</span><br><span class="line">    head -n 5           |</span><br></pre></td></tr></table></figure><p>awk命令按空格分割成不同的字段，每行打印第7个字段（也可以指定awk -F ‘//‘  ‘{print  $2}’用-F表示以’//‘分隔。sort命令从大到小排，因为uniq只比较相邻行去重，所以需要sort。head表示取前五个。</p><p>使用这样的UNIX命令可以像流水线一样处理数据，每个命令处理好一件事情，组合成强大的作业。</p><p>当某个程序输出称为另一个程序的输入时，就必须统一<strong>接口</strong>。在UNIX中就是文件（文件描述符）。如上的命令将输入文件视为由\n字符分隔的记录列表。</p><p>UNIX工具另外也使用stdin和stdout。管道允许将一个进程的stdout附加到另一个进程的stdin（小的内存缓冲区）。也可以将文件作为输入/输出重定向到文件。而这里局限性是，有多个输入或输出就很棘手。用户不能pipe输出给一个网络连接。</p><p>最大的局限是，UNIX工具只能在一台机器上运行。</p><h3 id="MapReduce与分布式文件系统"><a href="#MapReduce与分布式文件系统" class="headerlink" title="MapReduce与分布式文件系统"></a>MapReduce与分布式文件系统</h3><p>UNIX工具使用stdin和stdout作为输入和输出，而MapReduce作业在分布式文件系统上读写文件。在Hadoop的MapReduce实现中，该文件系统称为HDFS。HDFS基于<a href="https://spycsh.github.io/blog/2021/06/29/DDIA-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0-II/">无共享原则</a>。</p><p>HDFS包含一个在每台机器上运行的守护进程，并会开放一个网络服务以允许其他节点访问存储在该机器上的文件（假设数据中心的每台节点都附带一些本地磁盘）。名为NameNode的中央服务器会跟踪哪个文件块存储在哪台机器上。因此，从概念上讲，HDFS创建了一个庞大的文件系统，来充分利用每个守护进程机器上的磁盘资源。</p><p><a href="https://www.hadoopdoc.com/hadoop/hadoop-intro" target="_blank" rel="noopener">HDFS架构和Hadoo守护进程</a>。master节点上会运行一个叫做 namenode 的守护进程，每个 slave 节点上都会有 datanode 守护进程，两个进程都是属于HDFS 的。因此，slave 节点也叫做 datanode 节点。Namenode 主要用于<strong>存储元数据</strong>和管理 datanode 节点。而 datanode 则是<strong>真正存储数据和执行任务的地方</strong>。此外，还有一个SecondaryNameNode（管理层）辅助NameNode管理。</p><p>Apache Hadoop 工作原理：</p><ol><li>输入数据被划分成若干个128MB（默认值）的块，然后把它们移动到不同的节点。</li><li>在多个 datanode 存储完所有数据块之后，用户才能处理这些数据。</li><li>接着，master 把用户提交的程序调度到独立的节点上。</li><li>等所有节点处理完数据之后，输出计算结果并写回 HDFS。</li></ol><h4 id="MapReduce作业执行"><a href="#MapReduce作业执行" class="headerlink" title="MapReduce作业执行"></a>MapReduce作业执行</h4><p>JobTracker：属于管理层，管理集群资源与对任务调度，监控任务的执行<br>TaskTracker：属于应用层，执行JobTracker分配分发的任务，并向JobTracker汇报任务的执行情况</p><p>MapReduce工作步骤：</p><ol><li>读取一组输入文件，分解成记录，web日志例子里每个记录就是一行。</li><li>调用mapper函数从每个输入记录中提取一个键值对。</li><li>按关键字将所有键值对<strong>排序</strong>。对应日志例子里的sort。</li><li>调用reducer遍历排序后的键值对，键重复，则可以组合，对应uniq -c，reducer可以对相邻记录进行计数。</li></ol><blockquote><p>mapper 和 reducer 如何链接<br>通过目录名隐式完成，每个命令的输出被写入临时文件，下一个命令从临时文件中读取，而不是像UNIX命令一样直接从一个进程通过很小的内存缓冲区传递到另一个进程</p></blockquote><blockquote><p>Hadoop的工作流调度，一个作业只有在先前的作业成功完成时才能开始，为了处理其中的依赖关系，有各种Hadoop的工作流调度器，包括Oozie，Azkaban，Luigi，Airflow和Pinball。</p></blockquote><p>一个MongoDB的js的<a href="https://spycsh.github.io/blog/2021/06/02/DDIA%20%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/">例子</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.observations.mapReduce(</span><br><span class="line">    function map() &#123;</span><br><span class="line">        var year = this.observationTimestamp.getFullYear();</span><br><span class="line">        var month = this.observationTimestamp.getMonth() + 1;</span><br><span class="line">        emit(year + &quot;-&quot; + month, this.numAnimals);</span><br><span class="line">    &#125;,</span><br><span class="line">    function reduce(key, values)&#123;</span><br><span class="line">        return Array.sum(values);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        query: &#123;family: &quot;Sharks&quot;&#125;,</span><br><span class="line">        out: &quot;monthlySharkReport&quot;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>MapReduce的分布式执行（详见原书图10-1）</li></ul><p>MapReduce的并行化基于分区，HDFS输入目录的每个文件或文件块都被视为一个单独的分区。</p><p>MapReduce调度器会尝试在有输入文件的那台机器上运行mapper任务，这被称为计算靠近数据，避免输入文件网络复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 带有3个mapper和reducer的MapReduce作业</span><br><span class="line"># 为了确保具有相同关键字的所有键值对都在相同的reducer任务中处理，框架使用关键字的哈希值来确定哪个reduce任务接收特定的键值对</span><br><span class="line">---- mapper -----          ---- reducer ----</span><br><span class="line">        m1, r1              m1, r1</span><br><span class="line">m1 =&gt;   m1, r2       =》    m2, r1  =&gt; r1</span><br><span class="line">        m1, r3              m3, r1</span><br><span class="line"></span><br><span class="line">        m2, r1              m1, r2</span><br><span class="line">m2 =&gt;   m2, r2      =》     m2, r2  =&gt; r2</span><br><span class="line">        m2, r3              m3, r2</span><br><span class="line"></span><br><span class="line">        m3, r1              m1, r3</span><br><span class="line">m3 =&gt;   m3, r2      =》     m2, r3  =&gt; r3</span><br><span class="line">        m3, r3              m3, r3</span><br></pre></td></tr></table></figure><p>每当mapper完成读取输入文件并写入经过排序的输出文件，MapReduce调度器就会通知reducer开始从mapper中获取输出文件。根据key哈希值，有相同的key的kv pair会复制到同一个reducer。</p><h4 id="Reduce端的join与分组"><a href="#Reduce端的join与分组" class="headerlink" title="Reduce端的join与分组"></a>Reduce端的join与分组</h4><p>查询涉及少量记录，对全表扫描费时，建索引比较好。</p><p>分析查询，则需要并行扫描数据集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># log</span><br><span class="line">user 105 clicked button ... to load URL ... </span><br><span class="line">user 296 viewed the profile of user 134 </span><br><span class="line">user 251 logged out from browser session ...</span><br><span class="line"></span><br><span class="line"># db</span><br><span class="line">user_id email data_of_birth</span><br><span class="line">105 ...</span><br></pre></td></tr></table></figure><p>活动事件需要与用户描述的数据库进行join。但是尽量应该在一个机器上运行，因此应当获取db副本，将其放在HDFS的一组文件中，并将用户活动记录放在另一组文件中，然后用MapReduce将所有记录集中到一起，从而有效处理它们。</p><ul><li>排序-合并join</li></ul><p>使用相同的ID遍历活动事件，输出相应的已观看网址和观看者年龄。<br>详见书图10-3</p><ul><li>分组<br>GROUP BY + COUNT(*) / SUM(fieldname) / topK</li></ul><ol><li>收集用户会话（使用会话cookie、用户id作key）的所有活动事件，确定选择网站新版本的用户是否比选择旧版本(A / B测试）的用户更有可能产生购买行为。将不同用户的事件分配到不同分区。</li></ol><h4 id="处理数据倾斜"><a href="#处理数据倾斜" class="headerlink" title="处理数据倾斜"></a>处理数据倾斜</h4><p>有些用户有上百万关注者，这些人被称为热键。</p><p>某个reducer必须处理比其他reducer更多的记录。然而，MapReduce必须等到所有mapper和reducer都完成时才能完成。</p><p>解决方法是先抽样作业(Pig)或明确指定(Crunch)哪些是热键，然后复制到多个reducer并行处理。</p><p>Hive则是明确指定哪些是热键，然后独立出来，使用map端join。</p><h4 id="map端join"><a href="#map端join" class="headerlink" title="map端join"></a>map端join</h4><p>reducer join：mapper从每个输入记录中提取关键字和值，将键值对分配给reducer分区，并按关键字排序。这样的问题是复制到reducer以及合并reducer输入可能会是非常昂贵的操作。</p><p>而map端join则是缩减版的MapReduce作业。没有reducer，没有排序，每个mapper只需从分布式文件系统中读取输入文件块，然后将输出文件写入文件系统即可。</p><p>以下是三种<strong>优化</strong>：</p><ul><li>广播哈希join</li></ul><p>实现map端join的<strong>最简单方法</strong>广播哈希适合大数据与小数据join，尤其当小数据集能够全部加载到每个mapper的内存（以哈希表形式）中。每个大数据集的分区都会读取<strong>整个</strong>小数据集。</p><p>另外不一定要把小数据集保存在哈希表中，也可以保存到本地磁盘上的只读索引中（驻留在操作系统的页面缓存中）。</p><p>Hive中称为（MapJoin），Pig中称为（replicated join）。</p><ul><li>分区哈希join</li></ul><p><strong>如果以“相同”方式对map端的join的输入进行分区（某个key都在一个分区里）</strong>，则哈希join方法可以独立作用于每个分区。例如，可以根据用户ID的最后一个数字来分配活动事件和用户数据库的记录。</p><p>这样的优点是每个mapper都可以将较少的数据加载到其哈希表中。</p><p>Hive这称为bucketed map join。</p><ul><li>map端合并join</li></ul><p><strong>输入数据集不仅以“相同”的方式进行了分区（某个key都在一个分区里），也同时基于相同关键字进行了排序</strong>，可以使用另一种变体。</p><p>直接按关键字升序增量读取两个输入文件，并且匹配具有相同关键字的记录。</p><h4 id="MapReduce的弊端"><a href="#MapReduce的弊端" class="headerlink" title="MapReduce的弊端"></a>MapReduce的弊端</h4><p>中间状态实体化</p><ul><li><p>某些任务需要比其他任务花费更长的时间，必须等待前面作业所有任务完成会减慢整个工作流的执行。</p></li><li><p>mapper有时是冗余的。可能只需要mapper-&gt;reducer-&gt;reducer-&gt;reducer…，直接链接在一起</p></li><li><p>将中间状态存储在分布式文件系统中意味着这些文件被复制到多个节点，这对临时数据来说是大材小用了。</p></li></ul><h4 id="数据流引擎"><a href="#数据流引擎" class="headerlink" title="数据流引擎"></a>数据流引擎</h4><p>为了解决以上问题，开发了分布式批处理的新的执行引擎：Spark，Tez和Flink。<strong>也是有分区并行工作，复制输出到网络，成为另一个功能的输入</strong>。不同的是</p><ul><li>不需要map和reduce，而是用更灵活的函数运算符</li><li>排序等代价昂贵的实际需要才进行</li><li>没有不必要的mapper</li><li>所有join和数据依赖明确声明，因此调度器知道哪些数据在哪里是必须的，可以本地优化。 例如，可以尝试将占用某些数据的任务放在与生成它的任务相同的机器上，以便可以通过共享内存缓冲区来交换数据，而不必通过网络复制数据。</li><li>中间状态保存在内存或本地磁盘而不是HDFS(复制到多个节点并写入每个副本所在的磁盘)</li><li>运算符可以在输入准备就绪后立即开始执行，无须等待前一个全部完成。</li><li>MapReduce为每个任务启动一个新的JVM，现有Java虚拟机JVM可以被重用来运行新的运算符，减少开销。</li></ul><blockquote><p>容错<br>Spark, Flink和Tez避免将中间状态写入HDFS, 所以它们采用不同的方法来容忍错误： 如果机器发生故障， 并且该机器上的中间状态丢失， 则利用其他可用的数据重新计算（例如之前的中间阶段， 如果可能的话；或原始输入数据， 通常在HDFS上）。<br>为了实现重新计算，框架必须追踪给定数据是如何计算的， 使用了哪个输入分区，以及应用了哪个运算符。Spark使用弹性分布式数据集(Resilient Distributed Dataset, RDD)抽象来追踪数据的祖先, 而Flink对运算符状态建立检查点，从而允许将执行过程中遇到故障的运算符恢复运行。</p></blockquote><h2 id="流处理系统"><a href="#流处理系统" class="headerlink" title="流处理系统"></a>流处理系统</h2><blockquote><p>为什么需要流处理？<br>输入是有限大小的，批处理知道何时读完它们。而流处理则是只要有事件就开始处理。这个概念简单的例子有UNIX的stdin和stdout、Java的FileInputStream、TCP连接、通过互联网传送音频和视频等。</p></blockquote><p>批处理的基本对象是记录，在流处理里则称之为事件，通常带有时间戳。在文件系统中，文件名标识一组相关记录，在流处理系统中，相关事件通常被组合成主体或流。</p><p>生产者将其生成的每个事件写入<strong>数据存储</strong>，并且每个消费者定期轮询数据存储以检查自上次运行以来出现的事件。</p><p>但是，如果数据存储没有特别为这种轮询设计，那么轮询次数越多，返回新事件请求的百分比越低。所以当新事件出现时，最好通知消费者。</p><p>传统数据库只有触发器（行插入表时），功能有限，因此开发了专门的工具用来提高事件通知。</p><h3 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h3><p>UNIX管道和TCP连接一个发送者和一个接收者。而消息系统允许多个生产<br>者节点将消息发送到同一主题，并允许多个消费者节点接收主题中的消息。</p><blockquote><p>如果生产者发送消息的速度比消费者所能处理的快，会发生什么？<br>一般来说，有三种选择：系统丢弃消息；将消息缓存在队列中；或者激活背压，也称为流量控制（即阻止生产者发送更多消息）。例如，UNIX管道和TCP使用背压： 他们有一个固定大小的小缓冲区， 如果它被填满， 发送者将被阻塞，直到接收方将数据从缓冲区中取出（参阅书第8章 “网络拥塞与排队”) 。如果缓存在队列中，可能无法容纳，也许要将消息写入磁盘，这样或许会影响消息传递系统的性能。</p></blockquote><blockquote><p>如果节点崩溃或暂时离线，是否会有消息丢失？<br>持久性可能需要写入磁盘或结合复制（WAL?)方案（参阅书第7章“复制与持久性”）。而这些都是需要成本的。如果有时能接受丢失消息，那么在同样的硬件上可能获得更高的吞吐量和更低的延迟。</p></blockquote><p>批处理系统对失败的任务会自动重试，失败任务部分输出会自动丢弃；下面会讲到如何在流上下文提供类似的保证。</p><h4 id="数据库-vs-消息队列"><a href="#数据库-vs-消息队列" class="headerlink" title="数据库 vs. 消息队列"></a>数据库 vs. 消息队列</h4><ul><li>数据库通常会保留数据直到被明确要求删除，而大多数消息代理在消息成功传递给消费者时就自动删除消息。这样的消息代理不适合长期的数据存储。</li><li>由于消息代理很快删除了消息，多数消息系统会假定当前工作集相当小，即队列很短。缓存不够用则会存到磁盘，吞吐量就会降低</li><li>消息代理不支持任意的查询，但是当数据发生变化时（即新消息可用时），它们会通知客户端。</li></ul><h4 id="多个消费者"><a href="#多个消费者" class="headerlink" title="多个消费者"></a>多个消费者</h4><ul><li>AMQP/JMS风格的消息代理, 相关标准：STOMP, MQTT。举例：RabbitMQ。无日志，生产者和消费者直连，消费后就删除</li></ul><p><strong>负载均衡式</strong> 和 <strong>扇出fan-out式</strong>，前者每个消息有一个消费者消费即可，后者每个消息都传递给所有消费者。</p><p>前者可能会出问题：消费者（客户端）关闭超时，代理没有收到ack，就需要重新传递给另一个消费者，这样可能就不会按照生产者发送的顺序处理消息了。如果消息有因果关系就比较棘手。<br>还要注意：消息可能完全处理，但是ack丢失，这时候可能要原子提交协议，譬如2PC。</p><h4 id="分区日志"><a href="#分区日志" class="headerlink" title="分区日志"></a>分区日志</h4><p>append-only</p><ul><li>基于日志的消息存储（Kafka，Amazon Kinesis， Twitter Distributed Log）</li></ul><p>生产者通过将消息追加到日志的末尾来发送消息，消费者通过依次读取日志来接收消息。如果消费者读到日志的末尾，它就开始等待新消息被追加的通知。</p><p>生产者通过将消息追加到基于<strong>主题-分区</strong>的文件，消费者依次读取这些文件。尽管这些消息代理将所有消息写入磁盘，但通过多台机器的<strong>分区</strong>，支持百万条消息的吞吐量，并且通过<strong>复制消息</strong>实现了容错性。</p><p>Kafka 如何保证消息的消费顺序？详见<a href="https://zhuanlan.zhihu.com/p/262156222" target="_blank" rel="noopener">链接</a></p><ul><li><p>消费者顺序读取一个分区，需要一个偏移量</p></li><li><p>磁盘空间使用中需要回收，日志会被分为段，不断的归档或删除。mq很短时，很快。当写入磁盘时吞吐量会降低。</p></li><li><p>消费者跟不上生产者时，会写到mq里，积压很多会写到磁盘里，再不济就会丢弃过旧的信息（环形缓冲区)，但这些不会影响其它的消费者。</p></li></ul><h3 id="数据库与流"><a href="#数据库与流" class="headerlink" title="数据库与流"></a>数据库与流</h3><p>大多数重要的应用程序都需要结合多种不同的技术来满足需求：例如，使<br>用OLTP数据库来为用户请求提供服务， 使用缓存来加速常见请求， 使用全文索引处理搜索查询， 以及使用数据仓库用于分析。</p><p>如果数据库某个项更新，也需要在缓存、搜索索引和数据仓库中更新。这时就可以在数据更改时显式地写入每个系统，称之为<strong>双重写入</strong>。这时就会出现race condition（书中图11-4，客户端1 set X=A，客户端2 set X=B，都是先更新数据库再更新搜索索引，但是可能出现数据库与索引不一致的情况）。</p><p>这个问题书上是以版本向量作为解决方案，但是我个人对此表示怀疑，因为即使知道数据库上的happens-before关系，搜索索引也不知道，版本向量又有什么用呢？我觉得缓存本身就是查不到（目标没命中）就去回查数据库，那么就是以数据库为主的。所以可以数据库更新时就直接删了缓存，而不是写入缓存。到时候要新值的时候,缓存既然是空，就从数据库加载新值就行了。</p><h4 id="变更数据捕获-CDC"><a href="#变更数据捕获-CDC" class="headerlink" title="变更数据捕获(CDC)"></a>变更数据捕获(CDC)</h4><p>当然，另一种可能性就是change data capture，也就是用数据库触发器来检测数据库变更，变更的数据日志（只追加）会被发到搜索索引和数仓里，类似的比如用PostgreSQL的预写日志，MySQL的binlog等。这样的操作因为是异步的，所以用户依然可能会在写到搜索和数仓前查到旧数据，也就是遇到复制滞后问题。</p><ul><li>初始快照</li></ul><p>日志通常需要被阶段，因为太耗空间了。因此有了快照。全文索引需要整个数据库的完整副本，所以仅仅应用最近更改的日志不够，需要从一致的快照开始应用。</p><ul><li>日志压缩</li></ul><p>正如书第3章“哈希索引”的日志结果存储引擎，存储引擎定期查找具有相同key的日志记录，丢弃所有的重复项，并且只保留每个key的最新的更新。这个压缩和合并的过程是在后台运行的。Apache Kafka支持此日志压缩功能。</p><h4 id="流处理的目标场景"><a href="#流处理的目标场景" class="headerlink" title="流处理的目标场景"></a>流处理的目标场景</h4><ul><li>基于事件模型的查询（复杂事件处理）</li><li>计算窗口聚合（流分析）</li><li>保持派生数据系统处于最新状态（物化视图）</li></ul><h4 id="流join"><a href="#流join" class="headerlink" title="流join"></a>流join</h4><ul><li>流和流join</li></ul><p>两个输入流都由活动事件组成，采用join操作来搜索在特定时间窗口内发生的相关事件。例如，匹配相同用户在30min内采取的两个动作。两个join可以是相同的流。</p><ul><li>流和表join</li></ul><p>一个事件输入流，另一个是数据库变更日志。join来输出一个包含更多信息的事件。</p><ul><li>表和表join</li></ul><p>两个都是数据库更新日志。对两个表之间的join的物化视图进行持续的更新。</p><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><ul><li><p>批处理中，恰好一次exactly once可以由重新启动任务并丢弃失败的副本输出实现。但由于流是无限的，几乎无法做到。</p></li><li><p>Apache Flink定期生成状态滚动检查点并写入持久化存储。</p></li><li><p>幂等（idempotent）</p></li></ul><p>多次执行输出一样。kafka的offset避免了这个问题防止重复执行相同的更新。</p><h4 id="流式处理与服务"><a href="#流式处理与服务" class="headerlink" title="流式处理与服务"></a>流式处理与服务</h4><p>当前流行的应用程序开发风格是将功能分解为一组通过同步网络请求（REST,RPC)进行通信的服务。优点是松耦合，让不同的团队可以在不同服务上工作。将stream operator组合成数据流系统与微服务理念有许多相似的特征。但是通信机制是单向、异步的消息流而非同步的请求/响应交互。</p><p>数据流能具有更好的容错，也可以有更好的性能，比如买东西需要知道汇率，用微服务RPC的方法就要从远程数据库查汇率服务，用数据流方法就可以订阅汇率更新流，在当地数据库发生更改时记录当前的汇率，有购汇请求就只需查询本地数据库即可。也就是购汇请求和汇率更新事件有一个流与表的join。</p><blockquote><p>结语</p></blockquote><p>暑假花了一个月，终于把这本书大概看了一遍了，每一章看的时候都能和以前的课程或项目联系起来，也扩充了自己的知识面。正如作者最后所说，数据是把双刃剑，它能给生活带来便捷，也能危及人们的隐私。从学校课堂监视孩子表情来检测积极性，到外卖软件对骑手送餐的监管与时间的严格限制，再到Deepfake，再到各大视频流网站的推荐技术。大数据似乎像一个囚笼，把人的自由和隐私作为一种积累资本的工具。我不否认大数据带来的便捷，但是它绝不应当无视道德边界与人文关怀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDIA 数据密集型应用笔记 (II)</title>
      <link href="/blog/2021/06/29/DDIA-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0-II/"/>
      <url>/blog/2021/06/29/DDIA-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0-II/</url>
      
        <content type="html"><![CDATA[<h1 id="Design-Data-intensive-applications-II-–-分布式数据系统"><a href="#Design-Data-intensive-applications-II-–-分布式数据系统" class="headerlink" title="Design Data-intensive applications (II) – 分布式数据系统"></a>Design Data-intensive applications (II) – 分布式数据系统</h1><a id="more"></a><p>上一部分针对单机存储系统技术，这一部分我们将讨论多台机器的存储与检索服务。</p><ul><li>扩展性：读写压力大，负载分散到多台机器上</li><li>容错与高可用性：单机故障，多机提供冗余接管失效组件</li><li>延迟：应优先让用户就近的数据中心提供服务</li></ul><blockquote><p>如何处理更强的负载？</p></blockquote><p>垂直扩展（更强大机器）：</p><ul><li><p>共享内存架构：热插拔组件（服务器不关闭机器情况下更换磁盘，内存模块，甚至CPU）；无法异地容错；</p></li><li><p>共享磁盘：数据存储在可共享访问的磁盘阵列上，服务器与磁盘之间往往提供高速网络连接。race condition或锁会限制。</p></li></ul><p>水平扩展：</p><ul><li>无共享shared-nothing架构（本章重点）：每个节点独立使用本地CPU，运行数据库软件的机器或虚拟机称为节点，节点之间的协调通信全部在传统网络且核心逻辑主要依靠软件实现。</li></ul><p><strong>复制和分区</strong><br>复制replication：在多个节点上保存相同数据的副本。</p><p>分区partitioning：将一个大的数据库拆分成多个较小的分区，不同分区分配给不同的节点（sharding）。</p><h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><h3 id="主节点与从节点"><a href="#主节点与从节点" class="headerlink" title="主节点与从节点"></a>主节点与从节点</h3><blockquote><p>如何确保所有副本之间的数据是一致的？</p></blockquote><p>对于每一笔数据写入，所有副本都有随之更新。否者某些副本将出现不一致，最常见的解决方案是基于主节点的复制（<strong>主从复制</strong>）。在这种情况下，只有主副本处理写请求，写入本地存储，然后将数据更改为复制的日志或更改流发送给所有从副本，每个从副本获得更改日之后应用到本地，严格保持顺序。而对于读请求，主从副本都可以处理。</p><blockquote><p>同步复制还是异步复制</p></blockquote><p>同步是指执行一个请求前，讯问从节点的确认，得到确认后再执行，异步指不用等到确认就立即执行。前者好处在于主节点发生故障数据丢失，从节点就可以继续访问最新数据；缺点在于从节点会阻塞，没有throughput。所以有时设为半同步会比较好。</p><blockquote><p>如何处理主从节点呈现不同时间点的数据？</p></blockquote><p>对<strong>主节点</strong>的数据副本产生一个consistent snapshot，将快照拷贝到新的从节点。从节点连接到主节点并请求快照点之后发生的数据更改日志。快照与复制日志的某个确定位置相关联，这个位置信息在PostgreSQL中称为”log sequence number”，MySQL称为”binlog coordinates”。获得日志后从节点处理主节点上的新的数据变化（追赶caught up)。</p><h4 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h4><ul><li>从节点失效 - 追赶式恢复</li><li>主节点失效 - 节点切换（leader election，心跳确认失效，选主共识，重新配置reconfigure把主节点降级为从节点并认可新的主节点）</li></ul><blockquote><p>使用异步复制，且失效之前，新的主节点并未收到原主节点的所有数据，选举后，原主节点又重新上线并加入到集群，接下来的写操作会发生什么？</p></blockquote><p>新的主节点会收到冲突的写请求，那么就需要让这个把请求丢弃，如果数据库之外有其它系统依赖于数据库的内容，丢弃数据会特别危险。</p><blockquote><p>脑裂（split brain）是什么？</p></blockquote><p>两个节点各认为是主节点，都会接收写请求。</p><blockquote><p>如何设置合适的超时来检测主节点失效?</p></blockquote><p>超时太短，突发的负载峰值会导致节点的响应时间变长甚至超时，严重拥塞。</p><h3 id="复制滞后问题"><a href="#复制滞后问题" class="headerlink" title="复制滞后问题"></a>复制滞后问题</h3><p>上面讲到了利用<strong>冗余</strong>容忍节点故障，复制还可以加强<strong>可扩展性</strong>（多节点处理更多请求），以及保证<strong>低延迟</strong>（将副本部署在地理上距离用户更近的地方）？</p><p>如果用户从副本读数据，但副本还没有和主节点同步。这时就会引起复制滞后replication lag，而在现实生活中又可能对应下列三种问题。</p><h4 id="读自己的写-read-your-own-write"><a href="#读自己的写-read-your-own-write" class="headerlink" title="读自己的写 read your own write"></a>读自己的写 read your own write</h4><p>写请求到主节点，主节点insert一条数据，复制SQL语句到从节点，但这条SQL尚未到达从节点，此时若从从节点查询结果，结果可能空。</p><p>因此我们需要<strong>写后读一致性</strong>，也称为读写一致性。</p><p>解决方法有：</p><ul><li><p>社交网站上用户首页信息通常只能由所有者编辑，其他人无法编辑，所以总是从主节点读取字节的首页配置文件。如果用户访问可能会被修改的内容，从主节点读取；否则，在从节点读取。</p></li><li><p>监控从节点的复制滞后程度。避免从滞后时间过长的从节点读取。</p></li></ul><h4 id="单调读-monotonic-reads"><a href="#单调读-monotonic-reads" class="headerlink" title="单调读 monotonic reads"></a>单调读 monotonic reads</h4><p>写请求到主节点，主节点insert一条数据，复制SQL语句到A,B两个从节点，传到了A节点但没有传到B节点，用户先从A从节点查询结果有数据，而从B节点查询结果无数据。</p><p>因此我们需要单调读，这介于强一致性和最终一致性之间。它保证了用户绝对不会看到这种“回滚”现象。</p><p>解决方法：<br>用户总是从同一副本执行读取，为此，需要基于用户ID的哈希选择副本，副本失效则要重新路由到另外一个副本。</p><h4 id="前缀一致读-consistent-prefix-reads"><a href="#前缀一致读-consistent-prefix-reads" class="headerlink" title="前缀一致读 consistent prefix reads"></a>前缀一致读 consistent prefix reads</h4><p>情景：对于观察者，A提出问题之前，B就就回答了A的问题。</p><p>这是分区partitioned（分片sharded）数据库的一个特殊问题。不同分区独立运行，因此不存在全局写入顺序，这就导致当用户从数据库中读时，可能会看到数据库的某部分旧值和另一部分新值。</p><p>A在一个分区，B在另一个分区，分区各有一个从节点，主节点A，B接发消息维持顺序，从节点逆序，观察者从从节点查看消息记录发现颠倒。</p><p>解决方法：<br>只在主节点进行特定类型的读取？应用层代码复杂；<br>支持事务？可用性代价过高。</p><h3 id="多主节点复制"><a href="#多主节点复制" class="headerlink" title="多主节点复制"></a>多主节点复制</h3><p>主节点网络中断，主从复制就无效了。因此可以以一定的topology配置多个主节点。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>多数据中心</li></ul><p>多数据中心（接近用户）。在每个数据中心都配置主节点。性能上，主从复制每个写请求都必须经由广域网传送到主节点所在的数据中心，而多主节点复制中，可以在本地数据中心快速响应，然后采取<strong>异步复制</strong>将变化同步到其他数据中心。对上层应用有效屏蔽了数据中心之间的网络延迟，使得终端用户所体验到的性能更好。此外，还可以容忍数据中心失效和网络问题。如MySQL的Tungsten Replicator，PostgreSQL的BDR和Oracle的GoldenGate。</p><p>问题：冲突解决？</p><ul><li>离线客户端操作</li></ul><p>应用在网络断开后还要继续工作。比如手机，笔记本上的日历，需要随时查看或添加，在离线状态下进行任何更改会在下次设备上线时与服务器同步。例子：CouchDB</p><ul><li>协作编辑</li></ul><p>Google Docs。冲突可以将文档锁定，或单个按键或全程无锁。</p><h4 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h4><ul><li><p>检测到冲突后，根据ID或时间戳大小先后选择一个写请求作为胜利者，将另外的丢弃（数据丢失）。</p></li><li><p>所有冲突保存下来，下一次读取时，提示用户或自动解决冲突（CouchDB）。</p></li></ul><h4 id="拓补结构"><a href="#拓补结构" class="headerlink" title="拓补结构"></a>拓补结构</h4><p>多个主节点的拓补（环形MySQL，星形，all-to-all）。环形拓补中，中间节点需要转发数据变更，如果某个节点收到包含自身标识符的数据更改，表明请求已经被处理过。问题是单点故障。需要重新配置拓补结构排除故障。</p><p>all-to-all拓补中消息可以沿不同方向传播，没有单点故障。但是，可能会出现某些网络链路比其他更快的情况，产生意外的顺序。（因果序乱了，类似前缀一致读中）。</p><p>为此可以使用version vector向量来描述因果序。</p><h3 id="无主节点复制"><a href="#无主节点复制" class="headerlink" title="无主节点复制"></a>无主节点复制</h3><p>Dynamo, Riak, Cassandra。取消主节点，任何副本都可以接收写请求。</p><p>向多个副本<strong>并行发送</strong>读请求，根据版本号确定哪个值更新。向多个副本并行发送写请求，三个副本有两个成功确认写操作，则成功。</p><p>read-repair:</p><p>当检测查询到三个中两个副本返回一个值，另一个返回一个旧值时，把新值写入旧的副本。</p><p>anti-entropy：<br>后台进程不断查找副本之间的差异。同步到最新。</p><h4 id="读写quorum"><a href="#读写quorum" class="headerlink" title="读写quorum"></a>读写quorum</h4><p>多少个副本完成才可以认为写成功？</p><p>n个副本，w个节点确认，必须查询r个节点，则只需要w+r&gt;n，读取的节点一定包含最新值。一般来说n是奇数，w=r=(n+1)/2向上舍入。读多写少的情况下，w=n，r=1，写需要所有节点确认，查询只需查询1给节点也是ok的。</p><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>分区数据库早在20世纪80年代就有了，最近又被一些NoSQL和基于Hadoop的数据库重视起来。接下来会讨论如何根据数据索引分区，以及分区的再平衡，和如何路由请求到正确的分区并查询。</p><h3 id="数据分区与复制"><a href="#数据分区与复制" class="headerlink" title="数据分区与复制"></a>数据分区与复制</h3><p>分区（可扩展性）：面临海量数据，需要把数据切分成多段，那么每一段就是一个分区，</p><p>复制（冗余容错）：一个分区有一个主副本（写请求经过）和多个从副本，每个副本存在不同的节点上。</p><p>如果分区不均匀，那么某些分区节点会承担更多的数据量或查询负载，称之为倾斜skewed。因此我们有几种分区方法</p><ul><li>基于关键字区间分区</li></ul><p>类似字典，ABC顺序。分区边界由管理员手动确定。Bigtable、HBase、RethinkDB、2.4版本之前的MongoDB。</p><p>对于时间戳，可以很好的区间查询。但是可能某天写入过多（当天分区），负载过高，而其它分区空闲。为此，可以引入传感器名称，然后按时间分区。</p><ul><li>基于关键字哈希值分区（<a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener">一致性哈希算法</a>)</li></ul><p>哈希函数可以将字符串转换为定长随机分布的数值，减轻热点（相近的两个key也会存储在不同分区上），但是就丧失了区间查询。</p><ul><li>组合索引</li></ul><p>Cassandra的表可以声明为由多个列组成的复合主键。复合主键只有第一部分可用于哈希分区，其它列用作组合索引对Cassandra SSTable中的数据进行排序。因此它不支持在第一列上进行区间查询，但如果第一列指定好了固定值，可以对其他列进行高效的区间查询。</p><p>e.g. (user_id, update_timestamp)。不同user在不同分区，但消息时间戳顺序存在一个分区上。</p><h4 id="负载倾斜与热点"><a href="#负载倾斜与热点" class="headerlink" title="负载倾斜与热点"></a>负载倾斜与热点</h4><p>出现大量对相同关键字的写操作（点赞，关键字名人ID），哈希无效，因为两个相同的哈希值仍然相同。一个操作是key头尾各加一个随机数。</p><h3 id="分区与二级索引"><a href="#分区与二级索引" class="headerlink" title="分区与二级索引"></a>分区与二级索引</h3><p>上面讨论的是kv模型，根据关键字查，但是二级索引会更复杂，是关系数据库的必备特性。HBase不支持，但是Riak支持，也是ES等全文索引的根本。</p><ul><li>基于文档分区的二级索引</li></ul><p>假设二手车ID: 0~1000, 根据id两个分区，按颜色和厂商过滤，就需要并行对两个分区，生成color:black, color:silver等<strong>文档ID的list</strong>，软件合并（对所有分区执行查询，然后合并结果，scatter/gather）。</p><ul><li>基于词条的二级索引</li></ul><p>对所有数据进行全局索引，而不是每个分区维护自己的本地索引。读取更为高效，不需要并行scatter/gather，只需对包含词条的那个分区发出读请求。写入慢，负载，二级索引分区可能不同、在不同节点上，产生写放大。</p><blockquote><p>读放大（Read Amplification）。LSM-Tree 的读操作需要从新到旧（从上到下）一层一层查找，直到找到想要的数据。这个过程可能需要不止一次 I/O。特别是区间查询的情况，影响很明显。<br>RocksDB 和 LevelDB后台compaction减少读放大的同时，也会增加写放大的问题，也即观察到的写入数据多于上层程序写入的数据。</p></blockquote><h3 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h3><p>随着时间的推移，数据库需要增加节点（冗余容错，更多CPU处理负载，更多磁盘和内存存储），这样一来，请求需要从一个节点转移到另一个节点。这被称之为再平衡。目标是至少要满足：负载、读写请求数据存储更均匀分布，再平衡过程中，数据库可以继续正常提供读写服务，避免不必要的负载迁移，尽量减少网络和磁盘I/O。</p><h4 id="动态再平衡的策略"><a href="#动态再平衡的策略" class="headerlink" title="动态再平衡的策略"></a>动态再平衡的策略</h4><p>为什么不hash(key) 然后取模（mod节点数，以均匀分布所有节点到不同分区）呢？</p><p>迁移数据操作过于频繁。假设hash(key) = 123456，如果节点数N增加，hash(key) mod N 不断变化，数据必须随节点数变化而不断迁移。</p><ul><li>固定数量的分区</li></ul><p>先事先设立20个分区（远大于节点个数），假设有4个节点，每个节点有5个分区，一旦集群中添加一个新节点，该节点在每个现有的节点上匀走几（这里是1）个分区，直到分区再次达到全局平衡。删除则相反操作。</p><p>这里不会改变key到分区的映射，只会调整分区与节点的对应关系。而且可以逐步完成，旧的分区仍然可以接收读写请求。</p><p>Riak、ES、Couchbase都支持这种动态平衡的方法。</p><p>数据集总规模不确定的情况下，分区数量怎样算适宜？很难达到一个取舍点。</p><ul><li>动态分区</li></ul><p>动态分区。分区数量可以自动适配数据总量。分区数据太大就分裂、太小就合并。MongoDB、HBase。每个分区总是分配给一个节点，每个节点可以承担多个分区。对于HBase，分区文件传输需要HDFS。</p><ul><li>按节点比例分区</li></ul><p>Cassandra。分区数与集群节点数成正比。</p><h3 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h3><p>发生了分区再平衡，怎么找到关键字？需要连接哪个IP地址和哪个端口号？</p><p>这属于服务发现问题（zookeeper），任何网络访问的系统都有这样的问题，尤其是当服务目标支持高可用时。</p><p>处理策略（3种）。</p><ul><li><strong>允许客户端链接任意的节点</strong>（例如，采用循环式的负载均衡器）。如果某节点恰好拥有所请求的分区，则直接处理该请求；否则，将请求转发到下一个合适的节点，接收答复，并将答复返回给客户端。</li><li>将所有客户端的请求都发送到一个<strong>路由层</strong>，由后者负责将请求转发到对应的分区节点上。 路由层本身不处理任何请求，它仅充一个分区感知的负载均衡器。</li><li>客户端感知分区和节点分配关系。此时，客户端可以直接连接到目标节点， 而不需要任何中介。</li></ul><p>所有参与者都要达成共识（分区与节点的对应关系及其变化）。如ZooKeeper，每个节点向ZooKeeper注册自己，它维护了分区到节点的最终映射关系。其他参与者（路由层或分区感知的客户端）订阅此信息。一旦分区改变或者添加、删除节点，ZooKeeper就会通知路由层。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务将应用程序多个读写操作捆绑在一起成为一个逻辑操作单元。而使用事务，也许会丧失一些可用性。为此我们必须考虑事务的作用以及如何使用它。</p><h3 id="深入理解事务"><a href="#深入理解事务" class="headerlink" title="深入理解事务"></a>深入理解事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>原子性Atomicity，一致性Consistency，隔离性Isolation，持久性Durability描述了数据库的容错机制。</p><p>A：在出错时中止事务，并将部分完成的写入全部丢弃。不用担心数据库的部分失败，它总是保证要么全部成功，要么全部失败</p><p>C：数据库处于应用程序所期待的“预期状态” （账户贷款余额和借款保持平衡）</p><p>I：并发执行的多个事务相互隔离，不能相互交叉。（不能有race condition）</p><p>D：一旦，事务提交成功，即使硬件故障或数据库崩溃，事务写入的任何数据也不会消失。（硬盘或SSD，预写日志WAL）</p><h4 id="脏读脏写、幻读、不可重复读"><a href="#脏读脏写、幻读、不可重复读" class="headerlink" title="脏读脏写、幻读、不可重复读"></a>脏读脏写、幻读、不可重复读</h4><p>解决方法：四种隔离级别read_uncommit，read_commit，read_repeatable，Serializable</p><p><a href="https://spycsh.github.io/blog/2021/02/22/dirty-read-phantom-read-and-unrepeatable-read/">参考</a></p><p>补充总结：</p><ul><li>read_commit</li></ul><p>防止了脏读（读数据库时，只能看到成功提交的数据）；防止脏写（写数据库时，只会覆盖已经成功提交的数据）。</p><p>脏写用行级锁来防止，当事务想修改某个对象（例如行或文档）时，它<br>必须首先获得该对象的锁；然后一直持有锁直到事务提交（或中止）。</p><p><strong>不能用读锁因为一个写事务就会阻塞很多读的锁申请。因此，大多数据库会维护一个旧值和当前写事务要设置的新值两个版本。事务提交前，所有其他读操作都读旧值，事务提交后才会切换到读取新值</strong>。</p><ul><li>read_repeatable</li></ul><p>防止了重复读问题（A读，B写，B提交，A再读，不一致）</p><p>MVCC多版本并发控制的<strong>一致性快照</strong>的可见性规则： </p><ol><li><p>每笔事务开始，列出当时尚在进行中的事务，忽略这些事务完成的部分写入（尽管之后可能会被提交），即不可见</p></li><li><p>所有终止事务所做的修改全部不可见</p></li><li><p>较晚事务ID所做的任何修改不可见，不管这些事务是否完成了提交</p></li><li><p>此外，其他所有的写入都对应用查询可见</p></li></ol><blockquote><p>Mysql的可重复读级别并没有完全解决幻读，考虑A读，B写，B提交，A再更新，A再提交，可能会出现A对B写的内容进行修改；所以得用MVCC+next-key locks(gap lock间隙锁或record locks索引加锁），或者下面的serializable来完全解决，这个case需要用<code>select * from table where ? for update;</code>select for update来手动锁定查询结果。但如果A只是读请求，Mysql的read_repeatable级别是可以保证幻读不出现的。<br><a href="https://juejin.cn/post/6844903799534911496" target="_blank" rel="noopener">https://juejin.cn/post/6844903799534911496</a></p></blockquote><ul><li>serializable</li></ul><p>防止了写倾斜（医生轮班例子，同一个会议室预订，声明同一个用户名）与幻读（在一个事务中的写入改变了另一个事务查询结果的现象（行增加或删除）， 称为幻读）</p><p>可串行化的三种技术：严格串行顺序执行Redis、两阶段加锁2PL（广泛运用）、乐观并发。</p><p>2PL（two-phase locking):<br>如果事务A已经<strong>读取</strong>了某个对象， 此时事务B想要写入该对象， 那么B必须等到A<strong>提交或中止</strong>之才能继续。 以确保B不会在事务A执行的过程中间去修改对象。如果事务A已经<strong>修改</strong>了对象， 此时事务B想要读取该对象， 则B必须等到A<strong>提交或中止</strong>之后才能继续。 对于2PL, 不会出现读到旧值的情况。</p><p>谓词锁（查询条件加锁），效果不佳，使用索引区间（next-key locking)锁。<strong>数据库可以简单地将共享锁附加到索引条目，表明事务已搜索了数据</strong>。</p><p>2PL是一种悲观并发控制机制（如果有锁冲突，那么直接放弃，相当于多线程的互斥锁），SSI可串行化的快照隔离是一种乐观并发机制（发生锁冲突，事务继续执行，当提交时，检查是否发生了冲突）。</p><h2 id="分布式系统的挑战"><a href="#分布式系统的挑战" class="headerlink" title="分布式系统的挑战"></a>分布式系统的挑战</h2><h3 id="故障与部分失效partial-failure"><a href="#故障与部分失效partial-failure" class="headerlink" title="故障与部分失效partial failure"></a>故障与部分失效partial failure</h3><p>当通过网络发送数据包时， 数据包可能会丢失或者延迟；同样， 回复也可能会丢失或延迟。 所以如果没有收到回复， 并不能确定消息是否发送成功。</p><p>对于HPC这种计算密集型的任务来说（天气预报或分子动力学），会定期对任务状态进行快照，保存在持久存储上，总是整体开停集群的任务。并且，节点间主要通过share memory或RDMA（远程内存直接访问）进行通信。</p><p>而对于基于互联网的服务系统（云计算），则必须考虑可用性，在线，低延迟。特征有<strong>多租户数据中心，通用计算机，IP以太网链接，弹性资源分配，按需计费</strong>。停下集群修复故障是不可取的。设备是通用机器，单节点成本低廉，也有较高故障率。</p><h4 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h4><p>如果故障有响应，比如发现服务进程没有侦听目标端口，操作系统会返回RST或FIN数据包辅助关闭或拒绝TCP连接，再比如路由器判断目标节点不可访问就会返回ICMP“目标不可达”数据包。但是想要知道具体请求是否执行成功，还是需要应用级别的回复。如果故障没有响应，一般使用超时判断故障。超时的选择一般是2d+r时间（d是传输时间，r是请求处理时间）。</p><p>但是一个问题是网络拥塞与排队。TCP实行流量控制，节点会主动限制自己的发送速率以避免网络链路或接受节点负载。<strong>这意味数据在进入网络之前，已经在发送方开始了排队</strong>。TCP还实现了超时重传，超时时间由响应时间分布自动调整。这些都会导致网络延迟变化。</p><p>拨打电话时，系统会动态建立一条电路，为整个线路上分配一个固定的带宽有保障的通信链路，电路一直维持到通话结束。这本质是同步的。然而，TCP连接会尝试使用所有可用的网络带宽。TCP可以传输任意大小可变的数据块，这样的代价是只能使用分组交换，对突发流量进行很多优化。如果通过电路链接来传输文件，将预估一个带宽，就不能传输任意大小可变的数据块了。有些网络比如ATM（Asynchronous Transfer Mode，与自动提款机无关）, InfiniBand尝试混合电路交换和分组交换，使用QoS（数据包优先级和调度）和准入控制（限制发送速率），在link layer实现端到端的流量控制以减少网络中的排队。但此类QoS在多租户数据中心，公有云和广域网中并未启用。</p><h3 id="时钟不同步"><a href="#时钟不同步" class="headerlink" title="时钟不同步"></a>时钟不同步</h3><p>使用NTP（Network Time Protocol）同步不同机器的时钟。</p><ul><li>石英钟漂移</li><li>本地时钟被强制重置后，突然倒退或跳跃</li><li>NTP失效，同步失败</li><li>NTP受延迟影响</li><li>闰秒</li></ul><p>冲突解决策略：LWW。Cassandra，Riak使用，最后写入获胜。</p><p>另一个问题：Lease（租约）based leader election</p><p>主节点获得租约，成为leader，这时候进程暂停（垃圾回收）被宣告为失效，recovery后对它暂停毫无所知，导致不知道新leader的存在。</p><p>为解决它，可以使用Fencing令牌，这主要是针对使用锁和租约机制来保护资源的并发访问。必须确保过期的唯一节点不能影响其他正常部分。在授予lease时，同时授予fencing令牌，每授予一次就会递增，当客户端每次向存储系统发送写请求时，都必须包含fencing令牌。比如节点A得到了lease成为leader并得到了fencing号 33，然后进程暂停很长时间，此时节点B已经得到lease成为新leader并得到fencing号 34，当节点A恢复再准备写时，就会被拒绝。</p><p>这在zookeeper中，可用事务表示zxid或节点版本cversion充当令牌，因为它们都是单调递增的。</p><p>fencing可检测无意的误操作，但是万一有节点试图破坏系统，可以伪造令牌，这样就是<a href="https://spycsh.github.io/blog/2021/01/24/Byzantine-Leader-Election/">拜占庭故障</a>。</p><p><strong>一些理论术语</strong>：</p><ul><li>系统模型synchronous, partially synchronous, asynchronous</li><li>节点失效模型crash-stop, crash recovery, byzantine crash</li><li>算法的正确性uniqueness, monotonic sequence, availability</li><li>安全与活性safety(false if有限时间内可以被违背，e.g. uniqueness, monotonic sequence), liveness（true if无限时间内可以eventually达成, availability）</li></ul><h2 id="一致性与共识"><a href="#一致性与共识" class="headerlink" title="一致性与共识"></a>一致性与共识</h2><p>第5章“复制滞后问题”中，多节点复制的先后导致了<strong>同时查询</strong>可能出现不一致的数据，这一点是无法避免的。因此退而求其次，引入了最终一致性。但这是很弱的保证，没有告诉我们什么时候能收敛于一致，当<strong>更新完立即读取</strong>，由于读取可能路由到不同副本，不保证一定能读到刚刚写入的值。</p><h3 id="可线性化Linearizability"><a href="#可线性化Linearizability" class="headerlink" title="可线性化Linearizability"></a>可线性化Linearizability</h3><p>又称强一致性，原子一致性，所有客户都有相同的数据视图。直觉的例子参见书上的例子。用一句话概括，不同客户端的所有操作（读，写，cas）的确切执行时刻（在invocation和response之间的某个时刻）都能在一个global的时间轴上表示出来。一旦某个读操作返回了新值，之后所有的读（包括柜同或不同的客户端）都必须返回新值。</p><blockquote><p>可线性化Linearizable vs. 可串行化Serializable<br>可线性化是读写寄存器（单个对象）的最新值保证。 它并不要求将操作<br>组合到事务中，因此无法避免写倾斜等问题，除非采取其他额外措施；<br>可串行化是事务的隔离属性，其中每个事务可以读写多个对象（行，文<br>档，记录等，它用来确保事务执行的结果与串行执行（即每次执行一个事务）的结果完全相同，<strong>即使串行执行的顺序可能与事务实际执行顺序不同</strong>。数据库可以同时支持这两者，但是可串行化的快照隔离必然不是线性化的，因为快照意味着不包含快照创建之后的写入数据。</p></blockquote><p>什么情况下需要线性化？</p><p>账户余额，库存，座位，都需要所有节点对某个最新值达成一致。</p><h4 id="实现线性化系统"><a href="#实现线性化系统" class="headerlink" title="实现线性化系统"></a>实现线性化系统</h4><ul><li><p>主从复制（部分可线性化）<br>主节点写入，从节点备份。如果某节点错误自认主节点，就会违法线性化。这通常用共识算法保证防止脑裂和过期的副本（zookeeper, etcd)，就可以线性化了。</p></li><li><p>多主复制（不可线性化）<br>在多节点上执行并发写入，发生写冲突后进行处理（根据ID时间戳选择一个写请求作为胜利者，丢弃另外的）</p></li><li><p>无主复制（部分可线性化）<br>Dynamo风格，写入满足w+r&gt;n，可能满足。Cassandra的LWW和不规范的quorum不能。Dynamo可以牺牲性能，使用read-impose（读修复，读后写，并行检测到某副本有过期的副本，就将新值写入此副本）和write-consult（读取quorum节点获取最新值）来满足线性化。</p></li></ul><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>网络分区情况下，选择一致性（线性化）还是可用性。</p><p>权衡选择系统，钱财安全CP, 用户可用AP。</p><blockquote><p>现代CPU上的内存甚至都是非线性化，除非使用内存屏障或fence指令。为了性能，每个CPU核都有自己独立的cache和寄存器，先访问cache，再异步刷新到主存。</p></blockquote><p>不支持线性化，是为了性能。想要满足线性化，读写请求的响应时间至少要与网络中延迟成正比。master挂掉时，zookeeper选举时间30~120s，且选主时间中集群不可用。如果只是向注册中心查询服务列表，这样的时间是无法接受的。Eureka这种AP系统就更好。</p><h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><blockquote><p>什么情况下需要顺序与因果关系？</p><ol><li>第5章，consistent prefix read一致前缀读，观察者先看到问题答案然后才是本身。</li><li>全链接拓补（多主节点），图5-9，应当先在一个主节点插入，再在另一个主节点上更新，但是更新操作在后一个主节点比前一个更早执行。</li><li>第5章检测并发写，A, B之间存在依赖关系</li><li>在事务的快照隔离上下文中，需要“一致性”，如果快照中包含了答案，那么他也必须包含所提的问题。（一致性的快照如何正确切分）</li><li>写倾斜与幻读。两方调班，需要有一个因果关系。A申请调班成功需要依赖于B仍在值班。利用可序列化的快照隔离（乐观并发）来跟踪事务之间的因果依赖关系来达到检测写倾斜的目的。</li><li>两个通道调整图片大小的例子，一个上传，一个修改，修改了缩略图导致原图被覆盖。</li></ol></blockquote><p>total order全序，可线性化：总是能指出哪个先哪个后，而causal order因果序，如果存在happen before（依赖或同进程中的先后），就是并发关系。全序一定是因果序，反之未必。</p><p><strong>Lamport 时间戳可以保证全序与因果关系一致</strong>，计数器较大的那个时间戳大，如果计数器正好相同，节点ID越大，时间戳越大。Lamport clock和Vector clock不同，后者可以区分两个操作属于并发还是因果依赖关系，但前者不能，它的优点是紧凑高效。</p><p>虽然面临并发请求（比如注册同一个用户名），可以使用lamport clock决定获胜者（先来者申请成功），然而时间戳排序依然不够，因为不知道别的节点是否也在同时创建相同用户名。这个时候就需要全序关系广播。</p><h4 id="全序关系广播"><a href="#全序关系广播" class="headerlink" title="全序关系广播"></a>全序关系广播</h4><p>total order broadcasting/atomic broadcasting必须满足</p><ul><li>可靠发送：没有消息丢失， 如果消息发送到了某一个节点， 则它一定要发送到所有节点。</li><li>严格有序：消息总是以相同的顺序发送给每个节点。</li></ul><h3 id="分布式事务与共识"><a href="#分布式事务与共识" class="headerlink" title="分布式事务与共识"></a>分布式事务与共识</h3><ol><li>主节点选举（网络故障，脑裂）</li><li>原子事务提交（回滚）</li></ol><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>twp phase commit 是一种在多节点之间实现原子事务提交的算法，用来保证所有节点要么全部提交，要么全部中止。2PC在数据库中使用，或以XA事务（Java Transaction API）或SOAP Web服务WS-AtomicTransaction的形式提供给应用程序。</p><p>当应用程序启动一个分布式事务时，它首先向协调者请求事务ID。该ID全局唯一。</p><p>prepare阶段，coordinator向所有participant讯问是否写入数据，如果有一票否决就作罢。</p><p>commit阶段，coordinator收到所有准备请求的答复，<strong>把决定写入到磁盘的事务日志中</strong>，防止之后系统崩溃，这个时刻称为提交点。向所有participant发送提交请求。如果请求失败，coordinator就必须一直重复，直到成功。participant收到也不能反悔。</p><p>问题是，万一coordinator出现故障怎么办？在commit阶段，participant收不到消息，但他也不知道是别的participant否决了还是coordinator故障导致自己收不到消息。</p><p>因此2PC能够顺利完成的唯一方法需要等待协调者恢复。</p><ul><li>问题可以由<a href="https://www.cnblogs.com/stateis0/p/9062128.html" target="_blank" rel="noopener">3PC</a>解决，因为在do commit 第三阶段，participant即使收不到消息，由于它在第二阶段收到了消息，所以他知道别的coordinator在第一阶段都同意提交了，所以只可能是coordinator挂了，所以过一段timeout它会自行提交。然而大部分系统还是使用2PC为主。</li></ul><h4 id="Zab，Paxos，Raft"><a href="#Zab，Paxos，Raft" class="headerlink" title="Zab，Paxos，Raft"></a>Zab，Paxos，Raft</h4><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">Raft</a></p><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><p>很多项目间接依赖于Zookeeper，例如HBase，Hadoop YARN, kafka，是因为它提供了全序广播，达到了多副本之间的一致性。具有以下特性：</p><ul><li>线性化的原子操作（共识）：多个节点同时尝试相同操作，确保只有一个会成功。分布式锁（租约，可以释放）</li><li>全序操作：fencing令牌，解决进程暂停情况引起的冲突</li><li>故障检测（心跳）</li><li>更改通知（订阅通知机制，客户端可以读取其他客户端所创建的锁和键值）</li></ul><p>Zookeeper还用于服务发现，例如需要某项服务应该连接到哪个IP地址。在典型的云环境中，虚拟机可能会起起停停，这种动态变化的节点无<br>法提前知道服务节点的IP地址，因此，可以这样配置服务，每当节点启动时将其网络端口信息向ZooKeeper等服务注册，然后其他人只需向ZooKeeper的注册表中询问即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDIA 数据密集型应用笔记 (I)</title>
      <link href="/blog/2021/06/02/DDIA%20%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2021/06/02/DDIA%20%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Design-Data-intensive-applications-I-–-数据系统基础"><a href="#Design-Data-intensive-applications-I-–-数据系统基础" class="headerlink" title="Design Data-intensive applications (I) – 数据系统基础"></a>Design Data-intensive applications (I) – 数据系统基础</h1><a id="more"></a><h2 id="可靠，可扩展，可维护的应用系统"><a href="#可靠，可扩展，可维护的应用系统" class="headerlink" title="可靠，可扩展，可维护的应用系统"></a>可靠，可扩展，可维护的应用系统</h2><p>一个常见的应用系统应包括以下模块：数据库、高速索引（memcache，redis）、索引（ES)、流式处理（异步）、批处理（定期处理大量累计数据）。</p><p>API客户端请求进来，应首先检测数据缓存(redis)是否命中，命中就从内存读请求，否则更新数据库-&gt;数据库应数据变化更新缓存。同时更新数据库-&gt;更新索引，应用代码就可以进行全文索引(ES)查询。另外，对于异步任务可以交予消息队列(kafka)慢慢处理。</p><p>对于大多应用系统应考虑三个问题：可靠性(Reliability),可扩展性(Scalability),可维护性(Maintainability)。</p><h3 id="可靠性："><a href="#可靠性：" class="headerlink" title="可靠性："></a>可靠性：</h3><ul><li><p>硬件故障<br>硬件冗余：磁盘RAID, 服务器双电源，热插拔CPU</p></li><li><p>软件错误<br>特定值（闰秒）导致应用程序挂起，级联故障</p></li><li><p>人为失误<br>抽象层，API以及管理界面。测试边界条件（property based testing)，自动化测试。滚动发布新代码，快速恢复机制。监控性能指标和错误率。</p></li></ul><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><blockquote><p>twitter案例：<br>问题：当一个人tweet后，当follower查看自己的timeline时，需要联表查询，效率很低：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tweets.*, users.* <span class="keyword">FROM</span> tweets</span><br><span class="line">    <span class="keyword">JOIN</span> <span class="keyword">users</span> <span class="keyword">ON</span> tweets.sender_id = users.id</span><br><span class="line">    <span class="keyword">JOIN</span> <span class="keyword">follows</span> <span class="keyword">ON</span> follows.followee_id =users.id</span><br><span class="line">    <span class="keyword">WHERE</span> follows.follower_id = <span class="keyword">current_user</span></span><br></pre></td></tr></table></figure></p></blockquote><p>可以改进的一点是当一个人tweet时就fan-out到所有follower的timeline。虽然牺牲了这个人发布tweet的时间，但是所有follower查看timeline的速度都提升了。</p><p>当然如果这个人有很多的follower，就会导致发布时间太长，也不行，所以要混着用。</p><p>另外在批处理系统Hadoop中，throughput吞吐量（<strong>每秒可处理的记录条数，或者在某指定数据集上运行作业所需的总时间</strong>）很重要，而在线系统更关注响应时间。响应时间使用平均值并不好，因为可能出现极端值（上下文切换、进程调度、网络丢包、TCP重传、垃圾回收暂停、缺页中断、磁盘I/O），所以可以使用百分数（percentiles)，中位数。amazon使用99.9百分位数作为响应时间的标准，即1000个请求中有一个无需到达最小响应时间。</p><p>如何应对负载增加？垂直扩展vertical scaling（机器升级），水平扩展（负载分布到多个小机器）。有些系统具有弹性，可以自动检测负载增加然后分配更多计算资源。水平扩展会大大提升复杂性。</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>监控、自动化、标准工具集成（jenkins,Teamcity,K8s,JIRA,GitHub Action)</p><p>敏捷开发，TDD， 重构</p><h2 id="数据模型与查询语言"><a href="#数据模型与查询语言" class="headerlink" title="数据模型与查询语言"></a>数据模型与查询语言</h2><p>三种数据模型：关系模型、文档模型、图模型。</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>最知名的数据模型SQL，基于1970年提出的关系模型。数据被组织成关系，在SQL中称为表(table)，其中每个关系都是元组（tuples）的无序集合（SQL中的行）。</p><blockquote><p>第一范式（1NF）强调的是列的原子性，表示列不能够分成其它几列。举例：联系人建表，电话要分成家庭电话和个人电话。第二范式（2NF），表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分，不符合 2NF 的设计容易产生冗余数据。举例【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）= 【OrderDetail】（OrderID，ProductID，Discount，Quantity）+ 【Product】（ProductID，UnitPrice，ProductName）。第三范式（3NF），任何非主属性不依赖于其它非主属性。【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），符合第二范式，但Custom也依赖于CustomID。应拆分出来<br>参考：<br><a href="https://blog.csdn.net/Dream_angel_Z/article/details/45175621" target="_blank" rel="noopener">https://blog.csdn.net/Dream_angel_Z/article/details/45175621</a></p></blockquote><p>关系数据库的核心在于商业数据处理，用例分为事务处理（银行交易，订票，仓库库存）和批处理（客户发票，工资单，报告）。</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>超大数据集或超高写入吞吐量，关系模型不能很好地支持一些特定的查询操作。开源。</p><p>ORM对象关系映射框架有ActiveRecord和Hibernate，降低了应用层对象与传统关系模型之间转换的难度。面向文档数据库MongoDB, RethinkDB, CouchDB, Espresso。MongoDB数据库通过JSON模型将树形结构显示化。</p><h3 id="MapReduce-查询"><a href="#MapReduce-查询" class="headerlink" title="MapReduce 查询"></a>MapReduce 查询</h3><p>MapReduce是一种编程模型,用于在许多机器上批最处理海量数据。一些 NoSQL 存储系统（例如MongoDB和CouchDB) 支持有限的<br>MapReduce方式在大量文档上执行只读查询。举例：</p><p>在PostgreSQL中，统计每个月看到了多少鲨鱼，可以这样查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> date_trunc(<span class="string">'month'</span>, observation_timestamp) <span class="keyword">AS</span> observation_month,</span><br><span class="line">    <span class="keyword">sum</span>(num_animals) <span class="keyword">AS</span> total_animals </span><br><span class="line"><span class="keyword">FROM</span> observations </span><br><span class="line"><span class="keyword">WHERE</span> family=<span class="string">'Sharks'</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> observation_month;</span><br></pre></td></tr></table></figure></p><p>而在MongoDB中MapReduce功能可以这样实现目的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.observations.mapReduce(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> year = <span class="keyword">this</span>.observationTimestamp.getFullYear();</span><br><span class="line">        <span class="keyword">var</span> month = <span class="keyword">this</span>.observationTimestamp.getMonth() + <span class="number">1</span>;</span><br><span class="line">        emit(year + <span class="string">"-"</span> + month, <span class="keyword">this</span>.numAnimals);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">key, values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.sum(values);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        query: &#123;<span class="attr">family</span>: <span class="string">"Sharks"</span>&#125;,</span><br><span class="line">        out: <span class="string">"monthlySharkReport"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>一个文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    observationTimestamp: Data.parse(&quot;Mon, 25 Dec 2020 12:11:11 GMT&quot;),</span><br><span class="line">    family:     &quot;Sharks&quot;,</span><br><span class="line">    species:    &quot;xxx&quot;,</span><br><span class="line">    numAnimals: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对于每个匹配查询的文档，都会调用一次js的map函数，设为文档对象。</li><li>map函数emit一个kv对，key如”2021-06”，value代表观察的动物数量</li><li>对于相同的key，利用reduce按key分组，reduce将特定月份所有观察到的动物数量相加</li><li>写入monthlySharkReport集合中</li></ul><blockquote><p>map和reduce 函数对于可执行的操作有所限制。 它们必须是纯函数， 这意味着只能使用传递进去的数据作为输入， 而不能执行额外的数据库查询， 也不能有任何副作用。这样使得数据库能在任何位置，以任何顺序来运行函数，并在失败时重新运行这些函数。</p></blockquote><p>MongoDB 2.2 增加了聚合管道查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.observations.aggregate([</span><br><span class="line">    &#123; $match: &#123;family: &quot;Sharks&quot;&#125;&#125;,</span><br><span class="line">    &#123; $group: &#123;</span><br><span class="line">        _id: &#123;</span><br><span class="line">            year: &#123; $year: &quot;$observationTimestamp&quot; &#125;,</span><br><span class="line">            month: &#123; $month: &quot;$observationTimestamp&quot; &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        totalAnimals: &#123; $sum: &quot;$numAnimals&quot; &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="图状数据模型"><a href="#图状数据模型" class="headerlink" title="图状数据模型"></a>图状数据模型</h3><p>属性图</p><p>每个顶点包括</p><ul><li>唯一的标识符</li><li>出边的集合</li><li>入边的集合</li><li>属性的集合（键值对）</li></ul><p>每个边包括</p><ul><li>唯一的标识符</li><li>边开始的顶点</li><li>边结束的顶点</li><li>描述两个顶点间关系的label</li><li>属性的集合（键值对）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vertices (</span><br><span class="line">    vertex_id   <span class="built_in">integer</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    properties  <span class="keyword">json</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> edges (</span><br><span class="line">    edge_id     <span class="built_in">integer</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    tail_vertex <span class="built_in">integer</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">    head_vertex <span class="built_in">integer</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">    label       <span class="built_in">text</span>,</span><br><span class="line">    properties  <span class="keyword">json</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> edges_tails <span class="keyword">ON</span> edges (tail_vertex);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> edges_heads <span class="keyword">ON</span> edges (head_vertex);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;字段名A&gt; REFERENCES &lt;表名T&gt; &lt;字段名B&gt; -- 表示字段A存在，T表中必须存在相同的值字段B</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> edges (tail_vertex); <span class="comment">-- 建立索引</span></span><br></pre></td></tr></table></figure><h2 id="数据存储与检索"><a href="#数据存储与检索" class="headerlink" title="数据存储与检索"></a>数据存储与检索</h2><p>总体来说存储引擎分为两大类，OLTP（针对事务处理）的架构和OLAP（针对分析型）。OLTP系统面向最终用户，可能收到大量请求。为了处理负载，应用程序在每个查询中只涉及少量记录。应用程序基于某种键来请求记录，而存储引擎使用索引来查找所请求键的数据，<strong>磁盘寻道</strong>时间是瓶颈。OLAP又业务分析师使用，处理的查询请求数目远低于OLTP系统，但每条查询需要在短时间扫描数百万记录。<strong>磁盘带宽</strong>（而不是寻道时间）是瓶颈，面向列的存储对于这种工作负载比较流行。</p><ul><li><p>磁盘寻道时间：是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3-15ms。<a href="https://tech.meituan.com/2017/05/19/about-desk-io.html" target="_blank" rel="noopener">来源</a></p></li><li><p>磁盘带宽：正相关影响吞吐量（单位时间可以成功传输的数据数量）。</p></li></ul><p>OLTP方面，有两个主要流派的存储引擎家族：日志结构的存储引擎（BitCask, SSTables, LSM-tree, LevelDB, Cassandra, HBase, Lucene）和面向页的存储引擎(B Tree，用于MongoDB, B+树用于MySQL)。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>一个简易的database，实现了get和set：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">db_set</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>, <span class="variable">$2</span>"</span> &gt;&gt; database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">db_get</span></span>()&#123;</span><br><span class="line">    grep <span class="string">"^<span class="variable">$1</span>,"</span> database | sed -e <span class="string">"s/^<span class="variable">$1</span>,//"</span> | tail -n 1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：日志文件存储Key-Value存储对需要从头到尾扫描整个数据库文件来查找键的出现位置。</p><p>因此，加速读查询，索引是必要的。但是并不是索引越多越好，因为每个索引都会减慢写速度。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote><p>哈希索引基于哈希表。哈希表是一种查找算法，希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素。因而必须要有一个确定的映射：数据的关键字key&lt;=&gt;数据元素位置。这种映射关系称为散列函数h(key)。最普通的散列函数：除留余数法h(key) = key MOD p, p&lt;=m。哈希冲突（不同key经由哈希函数生成的值相同）通常用<a href="https://cloud.tencent.com/developer/article/1454891" target="_blank" rel="noopener">拉链法</a>解决。</p></blockquote><p>为何不直接用哈希表来直接索引数据？哈希表存储了映射：键&lt;=&gt;数据文件的字节偏移量。查找某个key时，使用hash map找到文件中的偏移量，即存储位置，再读取其value。这就是Bitcask的做法。</p><p>Bitcask适合<strong>键的值频繁更新</strong>的场景。例如key是某个视频的url，value是播放的次数。有很多写操作，但没有很多key，也就是需要<strong>所有key都能保存在内存</strong>中。注意，这里key-value是追加式（日志的机制），那么怎样才能避免用尽磁盘空间呢？就是把具有相同key的记录<strong>压缩</strong>，只保留每个键最近的更新。这种实现方式是将日志分解成一定大小的段，当文件达到一定大小就关闭它并后续写入到新的段文件中。多个段也可以合并压缩，合并过程中，写请求还是在旧段上，但是合并后，写请求切换到新的合并后的段。每个段都有自己的内存哈希表，为了找到键的值，从最新的段开始依次检查。</p><p>追加式的日志看起来浪费空间，为什么不原地更新？</p><ul><li>追加和分段合并是“顺序写”，比随机写入快很多。</li><li>不必担心重写时发生崩溃。</li><li>避免碎片化问题</li></ul><p>坏处：<strong>哈希表必须全部放入内存</strong>，有大量键就gg，（注意value很占空间没有问题，因为哈希表只是key&lt;=&gt;存储位置）。很难在磁盘上维护哈希表。<strong>区间查询效率不高</strong>，只能逐个查找每个键。</p><h4 id="SSTables和LSM-Tree"><a href="#SSTables和LSM-Tree" class="headerlink" title="SSTables和LSM-Tree"></a>SSTables和LSM-Tree</h4><p>SSTable（Sorted String Table)在每个存储段都是一组key-value序列的日志结构的基础上，要求kv对的顺序按键<strong>排序</strong>。利用B树可以在磁盘上维护排序结构，而利用红黑树或AVL树可以在内存中排序。</p><p>SSTable优点：</p><ul><li>合并段可以并发读取多个输入段文件，比较每个文件第一个键，把最小的键拷贝到输出文件，重复这个过程。如果重复键出现在多个输入段，保留最新段的值，丢弃旧段的值。</li><li>查找特定键时，不再需要在内存中保存所有键的索引。比如查找handwork，知道handbag和handsome就知道要找的offset在中间。</li></ul><p>读写规则：</p><ol><li>写入时，添加到内存中的平衡树数据结构中，这个内存中的树被称为<strong>内存表（memtable）</strong></li><li>内存表大于某个threshold（通常几MB)时，将其作为SSTable<strong>写入磁盘</strong>。由于树已经维护了按键排序的kv，写磁盘比较高效。</li><li>处理读请求，先内存表，再最新磁盘段，再次新磁盘段。</li><li>后台周期性合并压缩</li></ol><p>问题：数据库崩溃，内存表丢失。解决：磁盘上保留日志，每个写入追加到日志，可以乱序，崩溃后恢复内存表。当内存表写入SSTable写入磁盘，相应日志可以丢弃。</p><h4 id="从SSTable到LSM-Tree"><a href="#从SSTable到LSM-Tree" class="headerlink" title="从SSTable到LSM-Tree"></a>从SSTable到LSM-Tree</h4><p>以上算法是LevelDB和RocksDB使用的。类似还被用于Cassandra和HBase，这两个引擎都收到Google Bigtable论文的启发（SSTable和内存表memtable）。</p><p>Log-Structured Merge-Tree。基千合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎。</p><p>Lucene是Elasticsearch和Solr等全文搜索系统使用的索引引擎。键是单词，值是保护该单词的文档ID的列表（倒排表）。在Lucene中这个映射保存在类SSTable的排序文件中，这些文件可以根据需要在后台合并。</p><p>优化：查找不存在的键，先SSTable，再最新磁盘段，再次新磁盘段……使用<a href="https://segmentfault.com/a/1190000021136424" target="_blank" rel="noopener">布隆过滤器</a>（不存在某个键，很快告诉你结果）。大小分级（HBase）和分层压缩（levelDB），Cassandra支持这两种压缩。前者让较小较新的SSTables连续合并到旧和较大的SSTables。后者让键的范围分裂成多个更小的SSTables，旧数据被移到单独的“层级”，这样压缩可以逐步进行并节省磁盘空间。</p><p>LSM-tree的基本思想是保存在后台合并的一系列SSTable。数据按排序存储，可区间查询，不用存全部索引，磁盘顺序写入，高吞吐量。</p><h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h4><p>B-tree将数据库分解成固定大小的块或页,传统上大小为4 KB。<strong>页是内部读／写的最小单元。 这种设计更接近底层硬件， 因为磁盘也是以固定大小的块排列</strong>。某一页被指定为B-tree的根；每当查找索引中的一个键时，总是从这里开始。。 该页面包含若干个键和对子页的引用。每个孩子都负责一个连续范围内的键， 相邻引用之间的键可以指示这些范围之间的边界。</p><p>一个页面引用另一个页面，引用指向磁盘地址而非内存。</p><p>B-tree中一个页所包含的子页引用数觉称为分支因子（branching factor)。</p><p>注意插入后可能的分裂过程，子页满了，分裂成两个half-full的页，父页也需要更新以包含分裂之后的新的键范围。该算法确保树<strong>保持平衡</strong>，<strong>具有n个键的B-tree总是具有O(logn)的深度</strong>。不需要非常深的页面层次就可以找到所需的页。分支因子为500的4KB页的四级树可以存储高达256 TB。计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500^4 * 4 * 1024 / (1e12) = 256</span><br></pre></td></tr></table></figure></p><h4 id="B树可靠性"><a href="#B树可靠性" class="headerlink" title="B树可靠性"></a>B树可靠性</h4><p>B-Tree的写是覆盖磁盘上的旧页，这与日志结构索引（LSM-Tree）不同，因为后者只追加不修改。B树的覆盖不会改变页的磁盘存储位置。被覆盖时引用的引用不变。</p><p>分裂时，需要更新对两个新子页的引用，如果部分页写入后发生崩溃，最终会导致索引破坏，为了恢复，常见B-Tree的实现需要支持磁盘上额外的数据结构：预写日志（write-ahead log, WAL)。这是仅支持追加的，每个B-tree的修改必须先更新WAL然后再修改树本身的页。</p><p>B树并发控制：latches锁存器（轻量级的锁）。LSM更简单，因为它们在后台执行所有合并，而不会干扰前端的查询，并且会不时地用新段原子地替换旧段。</p><h4 id="对比B树和LSM树"><a href="#对比B树和LSM树" class="headerlink" title="对比B树和LSM树"></a>对比B树和LSM树</h4><p>LSM树：</p><ul><li>写入更快，因为有较低的write-amplification写放大（在数<br>据库内，由于一次数据库写入请求导致的多次磁盘写），部分缘由顺序方式写入紧凑的SSTable文件，而不必重写树中的多个页。（顺序写&gt;随机写）</li><li>读取慢，因为必须不同压缩阶段检测多个不同的数据结构和SSTable</li></ul><p>B树：</p><ul><li>读取更快</li><li>每个键都恰好<strong>唯一</strong>对应索引的某个位置，LSM可能在不同段中有相同键的多个副本</li></ul><h4 id="其它索引结构"><a href="#其它索引结构" class="headerlink" title="其它索引结构"></a>其它索引结构</h4><p>二级索引使用CREATE INDEX命令。以便可以在每个表中找到属于同一个索引的所有行。</p><p>聚集索引：直接存储索引行，无额外跳转，MySQL的InnoDB的表的主键是聚集索引。非聚集索引：value可以是对其它地方存储的行的引用（具体位置称为堆文件），在有多个二级索引时，可以<strong>避免复制数据</strong>，实际数据仍保存在一个位置。</p><p>前者需要额外空间，加快了读取速度，后者反之。</p><h3 id="事务处理与分析处理"><a href="#事务处理与分析处理" class="headerlink" title="事务处理与分析处理"></a>事务处理与分析处理</h3><p>OLTP (online transaction processing) 在线事务处理。</p><p>OLAP (online analytic processing) 在线分析处理。</p><p>公司放弃使用OLTP系统用于分析目的，而是在单独的数据库上运行分析，这个单独的数据库被称为<strong>数据仓库（Data Warehousing）</strong>。</p><p>可以理解为，对于终端用户操作交互的是OLTP系统的数据库（电商网站-&gt;销售数据库，车辆路径规划-&gt;地理数据库）；而OLAP系统将这些数据库中的信息<strong>提取</strong>出来，进行数据<strong>转换</strong>和<strong>加载</strong>（Extract-Transform-Load，ETL）到数据仓库中，由商业分析员进行查询。</p><h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><p>分析人们购买新鲜水果或糖果的倾向是否取决于一周中的某天<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    dim_date.weekday, dim_product.category, </span><br><span class="line">    <span class="keyword">SUM</span>(fact_sales.quantity) <span class="keyword">AS</span> quantity_sold</span><br><span class="line"><span class="keyword">FROM</span> fact_sales</span><br><span class="line">    <span class="keyword">JOIN</span> dim_date <span class="keyword">ON</span> fact_sales.date_key = dim_date.date_key</span><br><span class="line">    <span class="keyword">JOIN</span> dim_product <span class="keyword">ON</span> fact_sales.product_sk = dim_product.product_sk</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    dim_date.year = <span class="number">2013</span> <span class="keyword">AND</span> </span><br><span class="line">    dim_product.category <span class="keyword">IN</span> (<span class="string">'Fresh fruit'</span>, <span class="string">'Candy'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    dim_date.weekdat, dim_product.category</span><br></pre></td></tr></table></figure></p><p>想要高效执行这个查询，可以在fact_sales.date_key和fact_sales.product_sk上使用索引，告诉哪里找特定产品的所有销售。但这依然会从磁盘加载所有行（一行所有的一百多个属性）到内存，解析，再过滤不符合所需条件的行。<br><strong>在大多数OLTP数据库中，存储以面向行的方式布局，来自表的一行所有值彼此相邻存储。文档数据库的文档也被存储为一个连续的字节序列</strong>。</p><p>面向列存储，就不需要将一行中的所有值存储在一起，而是将每列的索引值存储在一起。只加载相关列的所有行，再过滤不符合所需条件的行，就快很多。</p><blockquote><p>面向列的存储布局依赖一组<strong>列文件</strong>，每个文件以相同顺序保存着数据行。 因此，如果需要重新组装整行，可以从每个单独的列文件中获取第23个条目，并将它们放在一起构成表的第23行。</p></blockquote><ul><li>列压缩</li></ul><p>常见技术：bitmap encoding位图压缩，位图可以进行run-length encoding游程编码。具体见书上的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHERE product_sk IN (30, 68, 69);</span><br><span class="line">加载3个bitmaps，然后按位或。</span><br><span class="line"></span><br><span class="line">WHERE product_sk = 31 AND store_sk = 3:</span><br><span class="line">加载两个bitmaps然后按位与。（思考为什么这个也行）</span><br></pre></td></tr></table></figure><ul><li>列存储的排序</li></ul><p>排序可以区间查询，也可以进一步压缩列，压缩游程（run-length encoding）。</p><ul><li>列存储的写操作</li></ul><p>插入一行后，如果想要像B树一样原地更新不太可能，因为必须重写所有列文件，一致地更新所有列。因此要使用LSM-tree，首先进入内存存储区，再添加到已排序的结构中，再写入磁盘。<strong>这个过程与面向行还是面向列无关</strong>。当累积了足够多的写入时，将与磁盘上的列文件合并，并批量写入新文件。这是Vertica采取的方式。</p><h2 id="数据编码与演化"><a href="#数据编码与演化" class="headerlink" title="数据编码与演化"></a>数据编码与演化</h2><p>代码更迭对于服务端应用程序，需要执行滚动升级rolling update（分阶段发布staged rollout)，即对少数几个节点部署新版本，检查是否正常，然后逐步在所有节点上升级新的代码。无需暂停。对于客户端应用程序，只能寄望于用户，然而他们在一段时间内可能不会马上安装更新。这意味着新旧版本的代码和数据格式可能会在系统共存。因此需要双向的兼容性。</p><ul><li>向后兼容Backward compatibility：较新代码可以读取由旧代码编写的数据。</li><li>向前兼容：较旧代码可以读取由新代码编写的数据。</li></ul><h3 id="数据编码格式"><a href="#数据编码格式" class="headerlink" title="数据编码格式"></a>数据编码格式</h3><p>内存中：数据保存在对象，结构体，列表，哈希表和树中；这些数据结构对CPU高效访问与操作进行了优化。（指针）</p><p>数据写入文件或用网络发送时，必须编码为某种自包含的字节序列（JSON）。相反的过程为解码。</p><p>Java java.io.Serializable, python pickle类似的可以完成编码解码，但是问题是编码往往与特定的编程语言绑定在一起，并且解码过程中需要实例化任意类，会导致安全问题。攻击者可能会远程执行任意代码。</p><ul><li>JSON: JS的一个子集，在Web中内置支持</li><li>XML</li><li>CSV： 语言无关的格式，功能较弱</li></ul><h4 id="Apache-Thrift和Protocol-Buffers"><a href="#Apache-Thrift和Protocol-Buffers" class="headerlink" title="Apache Thrift和Protocol Buffers"></a>Apache Thrift和Protocol Buffers</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userName"</span>: <span class="string">"Martin"</span>,</span><br><span class="line">    <span class="attr">"favoriteNumber"</span>: <span class="number">1337</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [<span class="string">"daydreaming"</span>, <span class="string">"hacking"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thrify用IDL接口定义语言来描述模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">    1: required string  userName,</span><br><span class="line">    2: optional i64     favoriteNumber,</span><br><span class="line">    3: optional list&lt;string&gt;    interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Protocol Buffers等价模式(.proto文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Person&#123;</span><br><span class="line">    required string user_name       = 1;</span><br><span class="line">    optional int64 favorite_number  = 2;</span><br><span class="line">    repeated string interests       = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两者都有对应的代码生成工具，生成支持多种编程语言的类<a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/" target="_blank" rel="noopener">参考链接</a>。</p><p>如何用此二者实现向前兼容和向后兼容？</p><ul><li>添加新的字段到模式，给每个字段一个新的标记号码，当旧代码试着读取新代码写入的数据，包括一个不能识别的标记号码（新字段），就忽略。这样可以实现向前兼容</li><li>新代码总是可以读取旧的数据，如果添加新字段，无法使其成为必需字段，因为旧代码不会写入添加新字段，因此新字段需可选或有默认值</li></ul><p>改变数据类型？<br>int64 -&gt; int32 截断<br>int32 -&gt; int64 补0</p><p>Avro适合Hadoop，有两种模式语言（Avro IDL）和基于JSON的语言。</p><p>以上三种的模式语言比XML和JSON简单，支持更详细的验证规则。</p><h3 id="数据流模式"><a href="#数据流模式" class="headerlink" title="数据流模式"></a>数据流模式</h3><p>发送一些数据到非共享内存的另一个进程时，都需要编码为字节序列，方式有：</p><ul><li>通过数据库</li><li>通过服务调用</li><li>通过异步消息传递</li></ul><h4 id="基于服务的数据流：REST和RPC"><a href="#基于服务的数据流：REST和RPC" class="headerlink" title="基于服务的数据流：REST和RPC"></a>基于服务的数据流：REST和RPC</h4><p>Web：客户端（Web浏览器）向Web服务器发出请求，发出GET请求来下载HTML, CSS, JS, 图像等，发出POST请求提交数据到服务器。API包含一组标准的协议和数据格式（HTTP,URL,SSL/TLS,HTML)。</p><p>在<strong>Web浏览器内运行的Javascript应用程序</strong>也可以向服务器发出网络请求，并且可以使用XMLHttpRequest成为HTTP客户端（Ajax）。这种情况下的服务器响应通常不是HTML而是便于客户端应用程序进一步处理的编码数据JSON。</p><p>服务器本身可以是另一项服务的客户端（Web应用服务器作为数据库的客户端）。这种方法用于将大型数据库按照功能区域分解为较小的服务，这样当一个服务需要另一个服务的某些功能或数据时，就会向另一个服务发出请求。这种构建应用程序的方式被称为<strong>微服务体系架构</strong>。</p><p>面向服务/微服务的关键在于，通过使服务可以独立部署和演化，让应用程序更易于更改和维护。每个服务由一个团队拥有。换句话说，应当<strong>期望新旧版本的服务器和客户端同时运行，因此服务器和客户端的数据编码必须在不同版本的服务API之间兼容</strong>。</p><h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><p>REST是一个基于HTTP的设计理念，强调简单的数据格式，使用URL来标识资源，使用HTTP功能进行缓存控制、身份验证和内容类型协商。根据REST原则设计的API称为RESTful。Swagger可以用来描述RESTful API并生成文档。</p><p>SOAP是一种基于XML的协议，用于发出网络API请求。独立于HTTP。SOAP Web服务的API称为WSDL（web services description language，一种基于XML的语言）来描述。</p><p>RPC虽然强调让远程过程调用和调用本地方法一样，但是并没有那么简单。需要考虑远程与本地调用的差异：网络延迟，大数据的指针，语言转换。</p><h4 id="异步消息传递"><a href="#异步消息传递" class="headerlink" title="异步消息传递"></a>异步消息传递</h4><p>使用消息代理（RabbitMQ,Kafka）或Actor（Akka，Orleans，Erlang OTP），节点之间通过互相发送消息进行通信，消息由发送者编码并由接收者解码。</p><p>与直接RPC相比，使用消息代理有以下几个优点：</p><ul><li>接收方不可用或过载，它可以充当缓冲区，提高系统可靠性。</li><li>可以自动将消息重新发送到崩溃的进程，防止丢失。</li><li>避免了发送方需要知道接收方的IP地址和端口号（虚拟机云部署特别有用）。</li><li>支持发送一条消息给多个接收方。</li><li>逻辑上解耦</li></ul><p>与RPC差异在于消息传递通常是<strong>单向</strong>的，发送方通常不期望收到消息的回复。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RunSpec——一个跑步app设计</title>
      <link href="/blog/2021/05/01/RunSpec%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%B7%91%E6%AD%A5app%E8%AE%BE%E8%AE%A1/"/>
      <url>/blog/2021/05/01/RunSpec%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E8%B7%91%E6%AD%A5app%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="RunSpec——一个基于Kotlin前端，Kafka-Spark-MongoDB后台的跑步app设计"><a href="#RunSpec——一个基于Kotlin前端，Kafka-Spark-MongoDB后台的跑步app设计" class="headerlink" title="RunSpec——一个基于Kotlin前端，Kafka+Spark+MongoDB后台的跑步app设计"></a>RunSpec——一个基于Kotlin前端，Kafka+Spark+MongoDB后台的跑步app设计</h1><a id="more"></a><p><a href="https://github.com/Spycsh/RunSpec" target="_blank" rel="noopener">点击项目地址</a></p><p>本文主要记录了一个跑步app的设计过程，该<a href="https://github.com/Spycsh/RunSpec" target="_blank" rel="noopener">项目</a>是一个课余项目，主要是我为了加深对分布式应用架构的理解而写的。项目主体用Kotlin写前端安卓，前端安卓会读取用户安卓手机传感器中的数据并且传递到后台，后台的Kafka作跑步者数据的消息队列用以解耦与缓冲，再以Spark用以数据分析和存储到MongoDB中。由于笔者水平和时间有限，部分功能还在学习实践探索中。以下将对各个模块进行介绍。</p><h2 id="adviser-根据OpenWeather-API的跑步建议的模块"><a href="#adviser-根据OpenWeather-API的跑步建议的模块" class="headerlink" title="adviser - 根据OpenWeather API的跑步建议的模块"></a>adviser - 根据OpenWeather API的跑步建议的模块</h2><p>该模块是是一个极简的springboot项目，主要功能是根据当前经纬度调用OpenWeather API找到当前天气并且提供一个API。根据该API得到的天气可以为跑者在开跑前提供一些建议。</p><h2 id="android-安卓客户端"><a href="#android-安卓客户端" class="headerlink" title="android - 安卓客户端"></a>android - 安卓客户端</h2><p>Kotlin客户端，主要有三个界面。Home页面显示了用户的经纬度，天气情况，Top 5的跑步点（预设的POI，即point of interest，每当有用户经过POI，就会增加热度，对这个热度进行排序，选取前五个）。Dashboard页面展示了步数、跑步距离、跑步用时、经过的地方。Setting页面用来debug。</p><h2 id="producer-接收app数据并且转交给Kafka队列的模块"><a href="#producer-接收app数据并且转交给Kafka队列的模块" class="headerlink" title="producer - 接收app数据并且转交给Kafka队列的模块"></a>producer - 接收app数据并且转交给Kafka队列的模块</h2><p>由于目标是庞大的用户群体产生的实时跑步数据，因此使用Kafka来作解耦与缓冲的中间件。前端采集到数据后，发布这些数据给producer模块的Kafka broker再由processor模块消费。同时producer模块利用reslet建立了一些REST API来返回该用户历史跑过的POI，Top5的POI，和用户当前跑过的POI。</p><h2 id="processor-用Spark对实时数据进行分析并存储的模块"><a href="#processor-用Spark对实时数据进行分析并存储的模块" class="headerlink" title="processor - 用Spark对实时数据进行分析并存储的模块"></a>processor - 用Spark对实时数据进行分析并存储的模块</h2><p>订阅了Kafka broker的processor模块将对用户实时的跑步数据进行一个分析和存储。这里使用Spark来进行分布式处理较为妥当。首先Spark对mongoDB有原生操作的的<a href="https://docs.mongodb.com/spark-connector/v1.1/java-api/" target="_blank" rel="noopener">connector</a>，处理起来较为便捷。此处由于缺乏对相关例子的研究，并没有用到这个connector。而是简单地用insertOne逐条存储到MongoDB的runnerData表中。当然，对于预设的POI进行了<a href="https://spark.apache.org/docs/1.6.1/api/java/org/apache/spark/broadcast/Broadcast.html" target="_blank" rel="noopener">广播</a>，用以在不同的executor上处理数据流时可以由多个task共享一个POI，进行更快速的计算。同时，计算POI和用户经纬度的距离，若小于阈值，再判断是否已有同一用户id，同一tripId经过该点的记录，否则该POI热度加一。将这个count存入数据库表runnerPOIData中。</p><h2 id="statisticsboard-POI跑步数据显示面板"><a href="#statisticsboard-POI跑步数据显示面板" class="headerlink" title="statisticsboard - POI跑步数据显示面板"></a>statisticsboard - POI跑步数据显示面板</h2><p>主要是一个springboot项目。它可以在<code>localhost:8081</code>可视化POI的热度，也可以检测经过POI的用户的记录表。数据每5秒通过stomp websocket推送到面版，再由leaflet.js在页面左边进行渲染可视化。页面右侧是一个表格，记录了trip Id，跑者Id，POI Id，距离与时间。</p><blockquote><p><a href="https://github.com/Spycsh/RunSpec" target="_blank" rel="noopener">RunSpec</a>项目如何在kafka<strong>集群</strong>中，确保顺序收到跑步数据runnerData？</p></blockquote><p>最简单的方法，一个partition对应一个topic，所有属于这个topic的数据发到同一个partition里。</p><p>另一种方法，key(也就是userId)先hash再对集群partition数取余，相同结果的分配到同一个partition，虽然消费者随机读一个partition，但是能保证相同userId的跑步记录不会出现记录顺序错误的问题，这样一来，虽然我们依然不能保证linearizable的收到所有跑者的跑步记录，但是我们可以保证同一个跑者不会出现数据顺序错误。倘若有3个server，也就是三个broker，对应的topic runnerData有三个topic。</p><p>但这样一旦节点数增加，key取余对应的partition就不一样了，原来有3个分区，现在有4个，数据就存放到不同的partition了，就会出错，一种方法是只改变分区与节点的对应关系，不改变分区与key的映射。</p><blockquote><p><a href="https://github.com/Spycsh/RunSpec" target="_blank" rel="noopener">RunSpec</a>项目如何处理跑步路径海量数据点的压缩？</p></blockquote><p>由于考虑到存储与实时处理的压力，一般需要某种抽稀算法来压缩路径，也就是只存储一些路径上的关键点（比如折线的拐点等）而不用存储路径上的所有点。常见的一种方法是Douglas–Peucker算法，一种方法是垂直限距法。这个项目使用了垂直限距法作为基础，并且进行了一些改动，使其能实时地压缩数据点。我们首先规定一个threshold，并建立一个thinnedList，thinnedList存放的正是所有压缩后留下的点，即所有关键点，利用这些关键点就能大致地画出轨迹，而不至于带来大的存储压力，还要建立一个window，数据点流都会写到window里，可以当它是一个临时的list，每次都用来处理点到直线距离从而判断一个点是否是关键点。算法简述如下：把第一个点（开始点）放入thinnedList，后面的点不断加入window list，直到window大小等于2时，取thinnedList的最后一个点A，window的两个点B、C，计算B到A、C的直线距离，若大于threshold，则B是一个关键点，放入thinnedList，或直接存入mongo，反之，则点B近似在A、C组成的一条直线上，丢弃不作处理。后面的点不断加入window list，每当window size等于2时就可以判断一个点的去留，因此除了最后一个点，我们将获取中间所有的点的压缩路径。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dilutingRealTime</span><span class="params">(RunnerData runnerData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(thinnedList.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            thinnedList.add(runnerData);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(window.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            window.add(runnerData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(window.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> distance = pointToLineDistance(</span><br><span class="line">                    Double.parseDouble(window.get(<span class="number">0</span>).getLatitude()),</span><br><span class="line">                    Double.parseDouble(window.get(<span class="number">0</span>).getLongitude()),</span><br><span class="line">                    Double.parseDouble(thinnedList.get(thinnedList.size()-<span class="number">1</span>).getLatitude()),</span><br><span class="line">                    Double.parseDouble(thinnedList.get(thinnedList.size()-<span class="number">1</span>).getLongitude()),</span><br><span class="line">                    Double.parseDouble(window.get(<span class="number">1</span>).getLatitude()),</span><br><span class="line">                    Double.parseDouble(window.get(<span class="number">1</span>).getLongitude())</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (distance &gt; <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">                thinnedList.add(window.get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            window.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ubiquitous computing and IoT 普适计算与IoT</title>
      <link href="/blog/2021/04/13/ubiquitous-computing-%E6%99%AE%E9%80%82%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/"/>
      <url>/blog/2021/04/13/ubiquitous-computing-%E6%99%AE%E9%80%82%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ubiquitous-computing-amp-IoT"><a href="#ubiquitous-computing-amp-IoT" class="headerlink" title="ubiquitous computing &amp; IoT"></a>ubiquitous computing &amp; IoT</h1><a id="more"></a><p>With the booming development of 5G technology and the Internet, peopleare  witnessing  the  era  of  the  intelligent  world  that  everything  is  connected.Internet  of  things  (IoT)  and  Ubiquitous  computing  (UbiComp)  are  two  hottopics under such circumstances.  The article [1] written by R.M.C. Andrade etal. is a good material to help readers learn about the relevant concepts of IoTand ubiquitous computing and provide examples of real-world applications andmetrics to measure the characteristics of IoT and UbiComp.  This article reviewwill simply summarize the arguments of the article and offer my opinions on thepros and cons of this article. </p><p>In the introduction of the article [1] written by R.M.C. Andrade et al, Ubiq-uitous Computing (UbiComp) is a concept occuring before the emergence of IoTand basically UbiComp is to let people use services and technologies withoutperceiving  them.   As  they  point  out,  UbiComp  emphasizes  on  Human-Thinginteractions.  IoT shares many commonalities with UbiComp such as Human-Thing interactions but on the other hand, IoT is at a more complex level be-cause it also takes Thing-Thing interactions into considerations.  However, theyhold the argument that Human-Thing interactions are significantly impacted byThing-Thing interactions.  Meanwhile, they raise the argument that the mea-sures that focus on the characteristics of UbiComp, can also be applied to IoT. </p><p>To address these arguments, the authors, in the chapter of background, pro-vides further explanations on 5 general characteristics, namely context-awareness,mobility,  transparency,  attention and calmness of ubiquitous applications outof 27 essential quality characteristics identified in previous work of the authors[2].  To support the rationality for measuring of the characteristics, the authorsrefer to their previous studies, in which they provide detailed calculating func-tions  for  each  characteristic.   Simultaneously,  the  authors point out  that  IoTis composed of six elementary building blocks, namely identification,  sensing,communication,  computation,  services and semantics.  These six elements aretightly related to Thing-Thing interaction, which also allows broader communi-cation over Internet, and is not like Machine-To-Machine (M2M) which simplysupports connection on local wired or wireless networks.  By analyzing these sixelements the authors insist that two UbiComp features, context awareness andadaptability can be mapped to IoT domain as measures of the characteristicsof IoT, which respectively capture the context information to serve users andmake changes based on the information.  Another important feature presented is the spontaneous interaction, which is related to adapted behaviors of the IoTdevices in or out of the environment.</p><p>This article then provides some experiments and evaluates on their results. To summarize, three UbiComp applications have been made which have threemain functionalities to block video based on battery level (GREat Tour), to mutedevices when the user is in an office and it is the time for the meeting specified onthe user’s agenda (GREatMute), to print documents at the nearest printer forusers (GREatPrint).  Meanwhile, two IoT applications are made to respectivelyenable users to control the air conditioners and lamp manually or automaticallyby motions (Automa GREat) and report the presence of people in a particularroom (GREat Room). A comparison is made on the three UbiComp applicationsand the two IoT applications regarding to six more detailed measures mentionedbefore (adaptability, context-awareness etc.).  The article insists that measurescome from UbiComp can be applied to IoT applications.</p><p>I would argue that the applications given are indeed typical ones in relevantareas. It is also reasonable to measure on the characteristics based on the metricsbeforehand.  However, the evaluation result cannot necessarily indicate that themeasures that come from UbiComp can be fully applied to IoT applications.  Itis not persuasive that GREatRoom is an IoT application rather than a UbiCompapplication, since it also provide services without people manually or externallyperceive or manipulate it (UbiComp).  In that case, if we classify GREarRoomas  a  UbiComp  application,  the  result  of  AutomaGREat  cannot  support  theargument because two measures of AutomaGREat are zero percentage and itwould be hard to convince people that the two measures really matters to othertypical IoT applications.  One solution I would suggest to resolve the problem isto provide another indeed typical IoT application that has a non-zero adaptationdegree and correctness.</p><p>In the final discussion, the article lists questions and answers to them, includ-ing firstly the commonalities of UbiComp and IoT applications, secondly the in-teraction problems such as synchrony of IoT data, lack of conflicts handling, de-lay of communication, thirdly the characteristics and measures of Thing-Thinginteraction  such  as  synchronicity,  responsiveness,  reliability,  battery,  context-Awareness,  interoperability  and  difficulty  of  installation,  fourthly  the  majorchallenges to the interaction in IoT such as interoperability, consistency of theinteractions, verification of interest conflicts, and evaluation.</p><p>To sum up, the article serves as a good material to let readers learn aboutthe concepts of UbiComp and IoT, the commonalities and differences betweenthem, the typical applications and how the charateristics can be measured as acriterion for practitioners.  The article also point out the challenges for buildingUbiComp and IoT applications, and motivate researchers to think of adaptingthier UbiComp applications to IoT uses in future study.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]  R. M. Andrade, R. M. Carvalho, I. L. de Ara ́ujo, K. M. Oliveira, and M. E.Maia, “What changes from ubiquitous computing to internet of things in in-teraction evaluation?”  inInternational Conference on Distributed, Ambient,and Pervasive Interactions.    Springer, 2017, pp. 3–21.</p><p>[2]  R.   M.   Carvalho,   R.   M.   de   Castro   Andrade,   K.   M.   de   Oliveira,I. de Sousa Santos, and C. I. M. Bezerra, “Quality characteristics and mea-sures  for  human–computer  interaction  evaluation  in  ubiquitous  systems,”Software Quality Journal, vol. 25, no. 3, pp. 743–795, 2017.</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>分布式系统原理</title>
      <link href="/blog/2021/04/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2021/04/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统原理"><a href="#分布式系统原理" class="headerlink" title="分布式系统原理"></a>分布式系统原理</h1><a id="more"></a><p>本文基于ID2203 Distributed Systems, Advanced Course课程，对整个分布式领域的问题进行一个总结。课程参考了<a href="https://www.springer.com/gp/book/9783540288466" target="_blank" rel="noopener">Introduction to Reliable Distributed Programming</a>, <a href="https://www.amazon.com/Intro-Distributed-Algorithms-2ed-Gerard/dp/0521794838" target="_blank" rel="noopener">Introduction to Distributed Algorithms</a> 等书籍。前者更偏向代码实现，书中的伪代码清晰易懂，有兴趣的读者可以买一本看看。</p><p>待更。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>电影推荐系统设计</title>
      <link href="/blog/2021/04/02/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/blog/2021/04/02/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="电影推荐系统设计"><a href="#电影推荐系统设计" class="headerlink" title="电影推荐系统设计"></a>电影推荐系统设计</h1><a id="more"></a><p>本文出发点是总结市面上比较流行的电影推荐系统后端设计的整个流程，包括阐释Kafka/Redis/Spark/ES等工具的作用、在哪里用、怎么去用这些问题，并且加入自己的一些思考。</p><p><a href="https://github.com/Spycsh/MovieRecommenderSystem" target="_blank" rel="noopener">项目地址</a></p><h2 id="项目管理Maven"><a href="#项目管理Maven" class="headerlink" title="项目管理Maven"></a>项目管理Maven</h2><p>Apache Maven是一个软件项目管理和理解工具，它基于项目对象模型（POM）的概念，可以用以管理项目的构建，报告与文档。</p><p>本项目是一个Maven项目，采用父子项目的结构形式。Maven项目中子项目就是一个Maven module，可以通过右键-&gt;New-&gt;Module-&gt;Maven然后设置即可创建。pom文件中可以设置父子项目的信息。在主目录MovieRecommenderSystem下，我们创建一个Maven module名为recommender，再在recommender下建立五个Maven module名为DataLoader（数据加载），StatisticsRecommender(统计推荐），OfflineRecommender（离线推荐），ContentRecommender(基于内容的推荐)，StreamingRecommender（流式推荐）。</p><p>同时，在pom文件中，也可以引入相关的jar包依赖。比如spark-core, spark-sql, spark streaming，mongodb的驱动等等。</p><h2 id="数据加载DataLoader"><a href="#数据加载DataLoader" class="headerlink" title="数据加载DataLoader"></a>数据加载DataLoader</h2><p>DataLoader主要处理把csv文件的数据集加载到数据库MongoDB中。由于我们现有的数据集是三个csv文件，分布存储了电影信息，评分信息和标签信息。为此我们创建了三个case class，Movie、Rating、Tag，其中参数与csv的headers一一对应。Movie有电影id（mid），名字，描述，时长，发行日期，拍摄日期，语言，派别，演员，导演十个参数；Rating有用户id（uid），电影id，电影评分score，评论时间戳timestamp四个参数；Tag有用户id，电影id，tag名，时间戳四个参数。</p><p>由于数据集很大，使用Spark来读取到MongoDB中是一个好的选择，否则数据全都存在内存中就崩了。Spark可以尽可能地使用本地的线程分布式地读取数据并存储在MongoDB中。在SparkContext指定数据的路径，并且对csv文件进行一些split和toDF操作得到一个DataFrame，再对DataFrame进行write-&gt;option-&gt;mode-&gt;format-&gt;save就可以存储MongoDB即可。其中option带有mongo的uri和表名，mode表示存储的形式（可以是overwrite）。此外，还需要对每张表的mid，uid建立索引，指定descending或ascending。建立索引能大大加快查找数据的速度<a href="https://blog.tankery.me/development/why-we-need-indexes-for-database" target="_blank" rel="noopener">[reference]</a>. </p><p>在这个模块中，我们使用了MongoDB作为数据库，Spark作为数据读写工具存储到MongoDB。当然，我们也可以把数据存储到ElasticSearch中，以供用户搜索。一般说来，对于读多写少的存储ES是可以替代MongoDB的<br><a href="https://www.zhihu.com/question/25535889" target="_blank" rel="noopener">[reference]</a>。我们可以将这些固定的表写入ES，向用户提供更快的全文检索等搜索服务。</p><h2 id="统计推荐StatisticsRecommender"><a href="#统计推荐StatisticsRecommender" class="headerlink" title="统计推荐StatisticsRecommender"></a>统计推荐StatisticsRecommender</h2><p>StatisticsRecommender统计推荐和OfflineRecommender离线推荐都是使用Azkaban进行<strong>定时</strong>的触发执行的模块。本段主要介绍统计推荐模块。</p><p>统计推荐模块对上文DataLoader存储在mongo中的数据进行一个分析，从而得到一下四个推荐结果：</p><ol><li>最热电影  </li></ol><p>一个电影的热度通常用点击量或者评论量来衡量。这里用spark sql统计排序Rating表中具有同一个电影id（mid）的数据的行数，返回一个dataframe，把它写入mongo的RateMoreMovies表。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>, <span class="keyword">count</span>(<span class="keyword">mid</span>) <span class="keyword">as</span> <span class="keyword">count</span> <span class="keyword">from</span> ratings <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>最近的最热电影  </li></ol><p>与上面类似，但是排序还要优先考虑评论时间（timestamp）<br>首先注册一个spark udf名为changeDate，对原来表中的timestamp转换成yyyyMM的形式, 得到ratingOfMonth表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>, score, changeDate(<span class="built_in">timestamp</span>) <span class="keyword">as</span> yearmonth <span class="keyword">from</span> ratings</span><br></pre></td></tr></table></figure></p><p>再对ratingOfMonth表每个yearmonth，统计每个电影出现个数，对yearmonth、个数排序。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>, <span class="keyword">count</span>(<span class="keyword">mid</span>) <span class="keyword">as</span> <span class="keyword">count</span>, yearmonth <span class="keyword">from</span> ratingOfMonth <span class="keyword">group</span> <span class="keyword">by</span> yearmonth, <span class="keyword">mid</span> <span class="keyword">order</span> <span class="keyword">by</span> yearmonth <span class="keyword">desc</span>, <span class="keyword">count</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></p><p>返回结果写入mongo的RateMoreRecentlyMovies表。</p><ol start="3"><li>Top电影</li></ol><p>Top电影考虑的不是评论数而是评分的高低，也就是由平均评分进行一个排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>, <span class="keyword">avg</span>(score) <span class="keyword">as</span> <span class="keyword">avg</span> <span class="keyword">from</span> ratings <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></p><p>当然有时我们也可以确保评分个数大于某个数量，因为如果电影只有一条五星评分不足以断定它是Top电影。只需要加上having count(mid)&gt;阈值即可</p><ol start="4"><li>每个类别的Top电影</li></ol><p>之前已经计算了Top电影得到了一个名为averageMoviesDF的dataframe，将其与movieDF通过mid进行inner join操作得到一个movieWithScore（含有movie整体信息，包括我们需要的genre信息，以及avg score）。</p><p>考虑到有些电影的派别字段有多个类别genres（用竖线分割），我们就应该先对一个里面有所有的genre的list，和movieWithScore做一个笛卡尔积，然后做一个filter，对每个genre和movieRow（movieWithScore的一行），过滤掉movieRow的genres字段中不含有genre的记录。然后再将整个数据集的数据量减小，只留下必要的记录，生成RDD[genre, Iter[mid, avg score]]，再对genre做groupBy，sortWith平均分，即可得到最后的每个类别的Top电影的集合，将它保存在mongo里。</p><h2 id="离线推荐OfflineRecommender"><a href="#离线推荐OfflineRecommender" class="headerlink" title="离线推荐OfflineRecommender"></a>离线推荐OfflineRecommender</h2><p>StatisticsRecommender统计推荐和OfflineRecommender离线推荐都是使用Azkaban进行<strong>定时</strong>的触发执行的模块。本段主要介绍离线推荐模块。</p><p>统计推荐使用sql对于显性数据进行分析，而本模块使用了spark ML来做一个基于隐语义模型的协同过滤（CF）的推荐。实际上CF这一块主要分为itemCF和userCF，前者就是两个相似的电影，如果user看了一个那么另一个就可以被推荐；而后者就是两个相似的user，如果一个user看了一个movie那么这个movie也可以被推荐给另一个user。这里由于我们没有考虑user标签，所以采用的是itemCF的方式来进行离线推荐。</p><p>那么怎么断定两个电影相似？首先要找到features。给定训练集（user,product,rating)的元组和超参数rank、iterations、lambda，spark ML的ALS算法可以让我们训练出一个model。这个model可以得到一些item的features（productFeatures），我们也可以用这个model直接predict出每个user对每个product的rating。这个有什么用呢？因为原本user不可能对所有movie都评分，user对movie的评分矩阵必然是稀疏的<a href="https://www.zhihu.com/question/31509438" target="_blank" rel="noopener">[reference]</a>，但是为了得到每个user对每个movie的评分，ALS算法通过一定规律找到了features，填补了原来没有评分的地方。这样我们很轻易就可以进行一个排序然后得到一个用户的电影推荐列表了。最后存入了mongo的userRecs表。</p><p>另外，相似电影也可以通过features信息得到。两个电影都有等长的features列，进行一个余弦相似度的计算（阈值&gt;0.6）就可以得到相似电影矩阵。由于短时间相似电影矩阵都不会发生变化，可以存入mongo的MovieRecs表为实时推荐服务。</p><h2 id="实施推荐StreamingRecommender"><a href="#实施推荐StreamingRecommender" class="headerlink" title="实施推荐StreamingRecommender"></a>实施推荐StreamingRecommender</h2><p>StreamingRecommender提供了流式推荐服务，是针对用户<strong>评分行为</strong>的实时推荐模块。简单说来，就是当用户 u 对电影 p 进行了评分，将触发一次对 u 的推荐结果的更新。为此，我们先创建一个kafka流，用以实时接收评分message（UID|MID|SCORE|TIMESTAMP）。并且同时定义stream的LocationStrategies（分区分配方式）和ConsumerStrategies（消费者接收什么topics）<a href="https://spark.apache.org/docs/2.1.0/streaming-kafka-0-10-integration.html" target="_blank" rel="noopener">[reference]</a>，每当用户评分后，Flume-ng会采集到日志并且推送到kafkaStream，算法会对每个RDD的uid和mid</p><ol><li><p>根据uid找到redis中存储的最近K次电影评分，得到一个Array[(Int, Double)]，即(mid, score)的array</p></li><li><p>根据mid找到mongoDB中存储的N个最相似的电影（mongoDB中已有通过OfflineRecommender模块ALS算法计算出的相似电影表），并且过滤掉已经看过的电影），得到一个Array[Int]，即候选电影的array</p></li><li><p>融合步骤1的用户最近看过的K次电影和步骤2中找到的每个候选电影，计算出得分并排序成一个推荐列表。得分需要参考相似度，因为我们希望推荐和用户最近看过相关的电影；但得分也同时需要参考评分，因为可能虽然候选电影相似，但是评分爆低的电影我们也不希望推荐给用户；</p></li><li><p>保存Array[(Int,Double)]，也即mid和上面计算的得分score的元组数组到MongoDB。</p></li></ol><p>其中有用到redis(jedis), mongoDB, spark, kafka。步骤1使用redis存储<strong>最近K次电影评分</strong>，好处是因为redis的高速缓存，由于redis是一个内存数据存储，它不能存储非常大的数据，通常数据库内存满了就会通过LRU等淘汰策略，这对读写“最近K次的电影评分”来说，是相当符合的，步骤2使用mongoDB存储<strong>相似电影矩阵</strong>是因为，mongoDB是基于磁盘的数据存储，无需担心空间的限制，因此存在mongoDB中会更好。使用kafka是因为kafka是一个基于分布式日志的高吞吐、低延迟的发布/订阅消息队列，考虑到同时有一万个用户的电影评分数据（UID|MID|SCORE|TIMESTAMP)需要处理，而这些处理很花费时间，利用kafka做一个中介来暂时存储这些数据，而不是先存入mongoDB然后再读出来计算，会大大增加处理速度，减少数据库压力。</p><p>总的说来，当用户评分后，评分数据会通过kafka然后通过我们的实时推荐算法进行处理。当中需要用到redis存储的最近K次评分与mongo存储的相似电影表来计算score并排序得到推荐列表。然后把这个推荐列表存储到mongo里面，之后我们渲染到前端就可以看到推荐结果了。</p><h2 id="内容推荐ContentRecommender"><a href="#内容推荐ContentRecommender" class="headerlink" title="内容推荐ContentRecommender"></a>内容推荐ContentRecommender</h2><p>ContentRecommender是基于内容的推荐。考虑我们通过DataLoader模块存储了Movie表。我们可以假设关键属性是类型genres，描述，演员，导演。尤其是genres，我们可以用来进行冷启动的（首次注册时，询问用户他们喜欢的类型用以建立他们的用户个人资料）。我们可以简单地对类型应用one-hot编码，但通常不同的类型应具有不同的权重。例如，大多数战争电影都是动作电影，因此带有战争标签的电影应该更有价值。在这种情况下，我们可以使用tf-idf算法而不是ALS来解决问题。</p><p>在该系统中，tf-idf用于genres，并在MongoDB中生成一个名为ContentMovieRecs的表，并且该部分还可以与Streaming推荐器模块中实现的Kafka Streaming结合使用。</p><p>tf-idf是正相关与term frequency，负相关于inverse document frequency，它原来的意思是说，当一个词语出现在一个文档中越多（term frequency），它越有价值；但同时如果一个词语出现在多个文档中都很多（inverse document frequency），比如the，a，an这种，它越没有价值，即使tf很高也没有用。类比于我们的genres这个属性，可能一个用户看了许多动作片，但如果很多影片genre中都有动作片这个标签，动作片这个标签就没有那么有价值。利用spark ML中的HashingTF，IDF，Tokenizer可以找到电影tag（genre）的features，然后再计算余弦相似度就可以得到相似电影矩阵，提供给StreamingRecommender进行实时推荐了。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Distributed Systems revision</title>
      <link href="/blog/2021/03/18/Distributed-Systems-revision/"/>
      <url>/blog/2021/03/18/Distributed-Systems-revision/</url>
      
        <content type="html"><![CDATA[<h1 id="Distributed-Systems-revision"><a href="#Distributed-Systems-revision" class="headerlink" title="Distributed Systems revision"></a>Distributed Systems revision</h1><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Why study distributed systems? (2)</p><ul><li>Partial Failures<ul><li>Network (dropped msgs, partitions)</li><li>Node failures</li></ul></li><li>Concurrency<ul><li>Nodes execute in parallel</li><li>Msgs travel asynchronously</li></ul></li></ul><p>Two Generals’ Problem</p><p>Concensus?</p><ul><li>All correct nodes eventually decide</li><li>Every node decides the same</li><li>Only decide on proposed values</li></ul><p>Database</p><ul><li>Concurrent changes to same data</li><li>Nodes should agree on changes</li></ul><p>Use a kind of concensus: atomic commit {commit, abort}</p><p>Given Atomic Broadcast, can use it to solve concensus</p><p>=&gt; consensus cannot be solved in asynchronous system if a single node may crash</p><ul><li>No bound on time to deliver a msg</li><li>No bound on time to compute</li><li>Clocks are not synchronized</li></ul><p>=&gt; consensus solvable in synchronous system with up to N-1 crashes</p><ul><li>Known bound on time to deliver a msg</li><li>know bound on time to compute</li><li>known lower and upper bounds in physical block drift rate</li></ul><p>Partially synchronous system</p><ul><li>with up to N/2 crashes</li></ul><p>Consensus and Atomic Broadcast solvable with failure detectors</p><p>Byzantine algorithms tolerate up to 1/3 Byzantine processes</p><h2 id="Basic-Abstraction"><a href="#Basic-Abstraction" class="headerlink" title="Basic Abstraction"></a>Basic Abstraction</h2><p>Distributed algorithms are implemented as middleware between network(OS) and the application.</p><p>1) Network protocols aren’t enough</p><ul><li>TCP only offered for one-to-one communication<br>How to group communication</li></ul><p>Abstractions in this course<br>Reliable Broadcast – Causal order broadcast – Total order broadcast</p><p>2) N-N communication isn’t enough</p><ul><li>Need reliable high-level services</li></ul><p>Shared memory<br>Consensus<br>Atomic commit<br>RSM</p><p>Reliable Distributed abstractions<br>ex: reliable broadcast (ensure the msg sent to a all or one); atomic commit (reach the same decision on whether to commit or abort a transaction)</p><ul><li>Event-based Component Model<br>Events(3) Msgs, Timers, Conditions</li></ul><p>Two types of events<br>Requests (Inputs) Indications (Outputs)</p><p>Stack of Components in a single process</p><p>Example:<br>Implements: JobHandler, intance jh<br>upon event &lt;jh, Submit|job&gt; do<br>    process(job)<br>    trigger&lt;jh, Confirm|job&gt;</p><p>How to specify a distributed service? (4)</p><ul><li>Interface (aka Contract, API)<ul><li>Requests</li><li>Responses</li></ul></li><li>Correctness Properties<ul><li>Safety</li><li>Liveness</li></ul></li></ul><p>safety 有限时间内可以被违背<br>= safty is false for an execution E if there exists a prefix such that all extensions are false<br>liveness 无限时间内才可以被达成<br>= liveness is true for an execution E if for all prefixes there exists an extension that is true</p><ul><li>Model<ul><li>Assumptions on failure</li><li>Assumptions on timing (amount of synchrony)</li></ul></li></ul><p>failure types (4) crash-stop, omissions, crash-recovery, byzantine:<br>Omission failure covers both (1) Send omission (Not send what has to be sent), (2) Receive omission<br>In Crash recovery failures, a process is faulty in an execution if it crashes and never recovers or recovers infinitely often. (amnesia: the recovered nodes might not be able to restore all of state)<br>In Byzantine failures, a process may behave arbitrarily: sending or updating its state as not specified by its algorithm, and behave maliciously (collude)</p><p>Byzantine &gt; Crash-recovery &gt; Omission &gt; Crash</p><p>Channel failure modes (5)</p><ol><li>Fair-Loss Links</li></ol><ul><li>Channels delivers any message sent with non-zero probability (no network partitions)<br>  FL1. Fair-Loss: if m is sent inf often by pi to pj, and neither      crash, then m is delivered infinitely often by pj<br>  FL2. Finite duplication<br>  FL3. No creation: No msg is delivered unless it was sent</li></ul><ol start="2"><li>Stubborn Links</li></ol><ul><li>Channels delivers any message sent infinitely many times<br>  SL1. Stubborn delivery: correct pi msg -&gt; pj, pj delivers infinitely<br>  SL2. No creation</li></ul><ol start="3"><li>Perfect Links</li></ol><ul><li>Channels that delivers any message sent exactly once<br>  PL1. Reliable Delivery: correct pi msg -&gt; pj, pj eventually deliver<br>  PL2. No duplication: deliver once<br>  PL3. No creation</li></ul><p>use stubborn links to implement<br>keep log of received msgs in Delivered</p><p>FIFO Perfect links<br>FIFO. Ordered Delivery</p><ol start="4"><li>Logged Perfect Links</li></ol><ul><li>Channels delivers any message into a receiver’s persistent store (msg log)</li></ul><ol start="5"><li>Authenticated Perfect Links</li></ol><ul><li>Channels delivers any message m sent from process p to process q, that guarantees the m is actually sent from p to q</li></ul><p>Timing: Clocks =&gt; Lower and upper bounds on clock rate-drift and clock skew with regarding to real time<br>Causal order<br>a -&gt; b<br>(1) a occurs before b on the same process<br>(2) if a is a send(m) and b deliver(m), then a -&gt; b<br>Causal order is transitive<br>Two events are concurrent if not a -&gt; b and not b -&gt; a</p><p>Partial &amp; Total Orders<br>Partial -&gt; doesn’t order concurrent events<br>Total -&gt; any two distinct clock values are ordered (adding pid)</p><ul><li>Implementation<ul><li>Composed of other services</li><li>Adheres to interface and satisfies correctness</li><li>Has internal events</li></ul></li></ul><h2 id="Failure-Detectors"><a href="#Failure-Detectors" class="headerlink" title="Failure Detectors"></a>Failure Detectors</h2><p>Distributed algorithms are implemented as middleware between network(OS) and the application.</p><p>1) Network protocols aren’t enough</p><ul><li>TCP only offered for one-to-one communication<br>How to group communication</li></ul><p>Abstractions in this course<br>Reliable Broadcast – Causal order broadcast – Total order broadcast</p><p>2) N-N communication isn’t enough</p><ul><li>Need reliable high-level services</li></ul><p>Shared memory<br>Consensus<br>Atomic commit<br>RSM</p><p>Reliable Distributed abstractions<br>ex: reliable broadcast (ensure the msg sent to a all or one); atomic commit (reach the same decision on whether to commit or abort a transaction)</p><ul><li>Event-based Component Model<br>Events(3) Msgs, Timers, Conditions</li></ul><p>Two types of events<br>Requests (Inputs) Indications (Outputs)</p><p>Stack of Components in a single process</p><p>Example:<br>Implements: JobHandler, intance jh<br>upon event &lt;jh, Submit|job&gt; do<br>    process(job)<br>    trigger&lt;jh, Confirm|job&gt;</p><p>How to specify a distributed service? (4)</p><ul><li>Interface (aka Contract, API)<ul><li>Requests</li><li>Responses</li></ul></li><li>Correctness Properties<ul><li>Safety</li><li>Liveness</li></ul></li></ul><p>safety 有限时间内可以被违背<br>= safty is false for an execution E if there exists a prefix such that all extensions are false<br>liveness 无限时间内才可以被达成<br>= liveness is true for an execution E if for all prefixes there exists an extension that is true</p><ul><li>Model<ul><li>Assumptions on failure</li><li>Assumptions on timing (amount of synchrony)</li></ul></li></ul><p>failure types (4) crash-stop, omissions, crash-recovery, byzantine:<br>Omission failure covers both (1) Send omission (Not send what has to be sent), (2) Receive omission<br>In Crash recovery failures, a process is faulty in an execution if it crashes and never recovers or recovers infinitely often. (amnesia: the recovered nodes might not be able to restore all of state)<br>In Byzantine failures, a process may behave arbitrarily: sending or updating its state as not specified by its algorithm, and behave maliciously (collude)</p><p>Byzantine &gt; Crash-recovery &gt; Omission &gt; Crash</p><p>Channel failure modes (5)</p><ol><li>Fair-Loss Links</li></ol><ul><li>Channels delivers any message sent with non-zero probability (no network partitions)<br>  FL1. Fair-Loss: if m is sent inf often by pi to pj, and neither      crash, then m is delivered infinitely often by pj<br>  FL2. Finite duplication<br>  FL3. No creation: No msg is delivered unless it was sent</li></ul><ol start="2"><li>Stubborn Links</li></ol><ul><li>Channels delivers any message sent infinitely many times<br>  SL1. Stubborn delivery: correct pi msg -&gt; pj, pj delivers infinitely<br>  SL2. No creation</li></ul><ol start="3"><li>Perfect Links</li></ol><ul><li>Channels that delivers any message sent exactly once<br>  PL1. Reliable Delivery: correct pi msg -&gt; pj, pj eventually deliver<br>  PL2. No duplication: deliver once<br>  PL3. No creation</li></ul><p>use stubborn links to implement<br>keep log of received msgs in Delivered</p><p>FIFO Perfect links<br>FIFO. Ordered Delivery</p><ol start="4"><li>Logged Perfect Links</li></ol><ul><li>Channels delivers any message into a receiver’s persistent store (msg log)</li></ul><ol start="5"><li>Authenticated Perfect Links</li></ol><ul><li>Channels delivers any message m sent from process p to process q, that guarantees the m is actually sent from p to q</li></ul><p>Timing: Clocks =&gt; Lower and upper bounds on clock rate-drift and clock skew with regarding to real time<br>Causal order<br>a -&gt; b<br>(1) a occurs before b on the same process<br>(2) if a is a send(m) and b deliver(m), then a -&gt; b<br>Causal order is transitive<br>Two events are concurrent if not a -&gt; b and not b -&gt; a</p><p>Partial &amp; Total Orders<br>Partial -&gt; doesn’t order concurrent events<br>Total -&gt; any two distinct clock values are ordered (adding pid)</p><ul><li>Implementation<ul><li>Composed of other services</li><li>Adheres to interface and satisfies correctness</li><li>Has internal events</li></ul></li></ul><h2 id="Reliable-Broadcast"><a href="#Reliable-Broadcast" class="headerlink" title="Reliable Broadcast"></a>Reliable Broadcast</h2><p>Fail-stop &lt;=&gt; synchronous (P + PL_Link)<br>Fail-silent &lt;=&gt; aynchronous (PL)<br>Fail-noisy &lt;=&gt; partially synchronous (*P + PL)<br>Fail-recovery &lt;=&gt; (stubborn links or a persistent logs)</p><p>Quorums</p><ul><li>A set with at least floor(N/2) + 1 processes<br>resilience f max number of faulty processes &lt; N/2</li></ul><p>no deliver guarantees whether sender fails or not</p><p>5 reliable broadcast abstractions<br>Best-Effort: Guarantees reliability only if sender is correct<br>Reliable broadcast: Guarantees reliability independent of whether sender is correct<br>Uniform reliable broadcast: Also considers behavior of failed nodes<br>FIFO reliable broadcast: Reliable broadcast with FIFO delivery order<br>Causal reliable broadcast: Reliable broadcast with causal delivery order</p><p>Best-effort broadcast:<br>If p_i is <correct> and broadcast then eventually all <correct> processes deliver; (Best effort validity) + No duplication + No creation</correct></correct></p><p>Reliable broadcast: (Best-effort + Agreement)考虑了发送者fail但有correct的node deliver的情况，这种情况下也必须其它correct的node都deliver<br>&lt;==&gt;If p_i is correct then eventually all correct processes deliver m. If p_i is faulty then either all correct processes eventually deliver m, or no correct process delivers m;</p><p>Algo: Fail-Stop, Lazy Reliable Broadcast<br>Use P</p><p>Agreement: If a correct node delivers m, then every correct process delivers m</p><p>Uniform Reliable broadcast:<br>Reliable broadcast + Uniform Agreement (发送者fail，只要有node deliver，不管crash or correct，别的correctnode都deliver）<br>If a process delivers message m, then every correct process delivers m (Uniform agreement, take “keeping uniform with faulty process which delivers m” into consideration)</p><ul><li>one time unit is the longest message delay in E</li></ul><p>Complexity of lazy reliable broadcast<br>N processes<br>Best case: O(N) msgs<br>Worst case: O(N^2) msgs<br>Time complexity<br>Best case: 1 time unit<br>Worst case: 2 time units</p><p>Eager Reliable Broadcast</p><p>In lazy rb, we only use completness of P, not related to correctness<br>Q: replace P with *P?</p><p>A: replace P with diamond P will lead to:<br>“Pk gets info that Pi has crashed” <-> false (Pi do not crash at all, although Pk will eventually get that Pi is alive, it currently thinks Pk is crashed.</-></p><p>So:<br>Pk rebroadcast all msgs of Pi (it is unnecessary)</p><p>only affect performance, not affect correctness</p><p>For Uniform Eager Reliable Broadcast<br>We add a ack list; when all acks received, urb deliver.</p><p>Uniform agreement need P.</p><p>Majority-ACK Uniform RB &lt;==&gt;fail-silent<br>Resilience less than N/2</p><p>for fail-stop algorithm<br>has resilience = N - 1<br>all acks</p><p>weaker constraints on ACK less resilience tradeoff</p><h2 id="Causal-Broadcast"><a href="#Causal-Broadcast" class="headerlink" title="Causal Broadcast"></a>Causal Broadcast</h2><p>For Chat application<br>We should maintain a causal (happen-before) order on the context<br>Uniform broadcast does not remedy this.<br>! Causal reliable broadcast solves this</p><p>Causality of message<br>C1 (FIFO order) Some process pi broadcasts m1 before broadcasting m2<br>C2 (Network order) Some process pi delivers m1 and later broadcasts m2<br>C2 (transitivity) There is a message m’ such that m1 -&gt; m’ and m’ -&gt; m2</p><p>Causal Broadcast<br>CB: If node pi delivers m1, then pi must have delivered every message causally preceding -&gt; m1 before m1</p><p>CB’: If pj delivers m1 and m2 (保证要deliver), and m1 -&gt; m2, then pj must deliver m1 before m2</p><p>满足CB’ 不满足CB的情况：图</p><ol><li>实现在rb基础上，使用P做GC<br>Fail-Silent No waiting causal broadcast</li></ol><ul><li>Each message m carries ordered list of causally preceding messages in past_m</li></ul><p>message size grows, uaw Perfect detector P to garbage collect old messages</p><ol start="2"><li>实现在FIFO-rb上<br>Fail-Silent Causal Broadcast</li></ol><ul><li>Each msg carries a history, history is set of all causally preceding messages, and a vector timestamp</li></ul><p>Only deliver m once VCm ≤ VCi<br>Do Not deliver if VCm &gt; VCi or VCm ≠ VCi </p><ul><li><p>Single-Source FIFO order<br>Intuitively: Msgs from same node delivered in order sent<br>For all msgs m1 and m2 and all pi and pj,<br>  if p i broadcasts m1 before m2, and if pj delivers m2, then pj<br>  delivers m1 before m2<br>This formulation doesn’t require delivery of both msgs</p></li><li><p>Total Order<br>Intuitively: Everyone delivers everything in exact same order<br>For all messages m1 and m2 and all pi and pj,<br>if both pi and pj deliver both messages, then they deliver them in<br>the same order<br>This formulation doesn’t require delivery of both msgs<br>Everyone delivers same order, maybe not send order!</p></li></ul><p>如果不是single-source fifo必不是total order</p><p>Hierarchy 图</p><h2 id="Distributed-Shared-Memory"><a href="#Distributed-Shared-Memory" class="headerlink" title="Distributed Shared Memory"></a>Distributed Shared Memory</h2><p><a href="https://en.wikipedia.org/wiki/Shared_register" target="_blank" rel="noopener">wiki</a>The memory location which is concurrently accessed (read/write/CAS) is sometimes called a register.</p><p>DSM interface (4)<br>read invokation, read response, write invocation, write response</p><p>Regular Register (1, N)</p><ul><li>Termination</li></ul><ul><li>Each read and write of a correct node completes</li></ul><ul><li>Validity<br>Read returns last value written if</li></ul><ul><li>Not concurrent with another write and</li><li>Not concurrent with a failed write<br>Otherwise may return <strong>last</strong> or <strong>concurrent</strong> “value”</li></ul><hr><ol><li><p>Read-One Write-All (1, N) algorithm<br>read locally没有RTT，之后的算法都是read globally<br>P22 Postpone write responses to ensure<br>the writer does not return until it knows that the reader delivers the value that is broadcasted<br>写有1个RTT<br>2 communication steps (broadcast and Ack from all)<br>O(N) messages<br>resilience: N-1<br>然而却要Perfect Failure Detector，下面的就不用FD</p></li><li><p>Majority voting (1,N) algorithm<br>Each process stores the value of all registers<br>=&gt; write(r, v)<br>UPDATE PHASE<br>ts++(ts is a sequence number initialized to zero at the writer and incremented at each write)<br>timestamp-value pair, tvp = (ts, v)<br>send 一个update request<br>pj updates r = max(r, (ts, v)) and responds with ACK<br>QUERY PHASE<br>pi sends query, receives response (ts,v), picks max(ts, v)</p></li></ol><p>!Avoid old writes overiting new write<br>write will be ignored if it has lower timestamp</p><p>2 communication steps (one round trip)<br>O(N) messages<br>resilience: f &lt; floor(N/2)</p><p>Atomic/Linearizability vs. Sequential Consistency<br>sequential order vs. global time order<br>看例子</p><p>Majority voting算法是regular register但是如何保证Atomic的？</p><ol start="3"><li><p>(SWMR)Read-Impose Write Majority (1, N)<br>P66 When reading, also do an update (if ts same, then just return) before responding<br>读后写，写上一个写的值</p></li><li><p>(MWMR linerizable)Atomic Register Read-impose write-consult-majority (N, N)具有linearizability</p></li></ol><ul><li>Before writing, read from majority to get last ts</li><li>Do a query phase to get the latest timestamp before the update phase</li><li>为了synchronize ts</li><li>Two concurrent writes with same ts? compare process identifier<br>write operation<br>query + update phase<br>write needs 2 trips<br>One for the timestamp<br>One for broadcast-ACK<br>写前读，读上一个ts + 读后写，写上一个写的值<br>read needs 2 round-trips<br>one for read<br>one for impose if necessary</li></ul><ol start="5"><li>(MWMR sequential consistent)==&gt;LT<br>Logical Time algorithm (LT)<br>(N,N) Seq Consistent<br>Writes in 1 RTT and reads in 2 RTTs<br>Tolerates f&lt;n/2 faulty processes<br>Linearizability in logical time allows compositionality</li></ol><p>tvp = ((lt, i), v)<br>((10,1),5) timestamp 10, pid 1,value 5</p><p>Livness(3)<br>Wait-free (no deadlocks, no live-locks, no starvation)<br>Lock-free/non-blocking (no deadlocks, no live locks, maybe starvation)<br>Obstruction free/solo-termination (no deadlocks, maybe live-locks, maybe starvation)</p><p>总结<br>Distributed Algorithms</p><p>===&gt;the weak model (regular register)</p><ul><li>SWMR (Single write multiple read) regular registers</li></ul><p>Bogus algo (did not work)<br>Centralized(no failures)<br>Read-One Write-All Algorithm (P)<br>Majority Voting(No FD)</p><p>===&gt;the strong model(atomic register)<br>atomic register</p><ul><li><p>SWMR linearizable registers<br>  read-impose idea</p></li><li><p>MWMR linearizable registers<br>  read-impose write-consult</p></li><li>MWMR sequentially consistent registers<br>  read-impose write-consult-majority</li></ul><p>Compare the performance and resilience of algorithms</p><h2 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h2><p>Single Value Consensus properties (4)<br>Validity: Any value decided is a value proposed<br>Agreement: No two correct nodes decide differently<br>termination: Every correct node eventually decides<br>integrity: A node decides at most once</p><p>do not care about crashed nodes</p><p>怎样避免orphan message（之前propose的值后到了，不应该再decide了）<br><strong>Invariant</strong><br>adopt if proposer p is ranked higher than lastprop<br>otherwise p has crashed and should be ignored</p><p>Implements: Hierarchical Consensus(c)<br>Uses:<br>beb + P<br>第几轮就是第几个process decide和broadcast</p><p>Validity: Always decide own proposal or adpoted value<br>Integrity: Rounds increase monotonically, A node only decide once in the round it is leader<br>Termincation: Every correct node makes it to the round it is leader, if some leader fails, completeness of P ensures progress. If leader correct, validity of BEB ensures delivery<br>Agreement: No two correct nodes decide differently</p><p>How many failures can it tolerate? N-1</p><p>Uniform Consensus properties (4)<br>Uniform Agreement (care about crashed nodes)</p><p>Possible with weaker FD than P?<br>Yes! use Strong Detector (S)<br>Strong completeness<br>Weak Accuracy: the “accurate” corect leader will BEB value and final decision is v by all</p><p>Eventually perfect detector, cannot solve<br>consensus with resilience t ≥ n/2 </p><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Single Value Uniform Consensus</p><ul><li>Validity (only proposed -&gt; decided)</li><li>Uniform Agreement (No diff decide)</li><li>Integrity (at most once)</li><li>Termination (eventually decide a value)</li></ul><p>not solvable in Fail-Silent (aynchronous sytem model)</p><p>所以assume<br>Partially synchronous system + fail-noisy model + Message duplication, loss, re-ordering</p><p>use omega(evetual leader election to elect a single proposer)</p><ul><li>Proposer imposes its proposal to everyone</li><li>Everyone decides<br>问题是<br>serveral processes might initially be proposers<br>多个process都能propose<br>使用abortable consensus 解决<br>omega ensures evetually 1 proposer succeeds (liveness)</li></ul><p>PAXOS<br>proposers (impose proposal to set of acceptors)<br>acceptors (may accept values issued by proposers)<br>learner (will decide depending on acceptors acceptances)</p><p>centralized因为面临单点故障，不行</p><p>there will be a single proposer at least providing obstruction-free progress<br>不能无脑选第一个<br>distinguish proposals with unique seq number (ballot number)<br>不能restart（这样就chose了两个值）</p><hr><p>P1 An acceptor accepts first proposal it receives (ensures obstruction-free progress and validity)<br>P2 If v is chosen, every higher proposal chosen has value v (ensures agreement, integrity trivial to implement)<br>P2a( lemma方便实现) every higher proposal accepted has value v<br>P2b (加强) every higher proposal issued has value v<br>P2c If any proposal (n,v) is issued, there is a majority set S of acceptors such that either<br>(a) no one in S has accepted any proposal numbered less than n<br>(b) v is the value of the highest proposal among all proposals less than n accepted by acceptors in S</p><p>A proposer at round n needs a query phase to get the value of highest round number + a promise that the state of S does not change until round n</p><p>总体流程</p><ol><li>proposer pick unique seq n, send prepare(n) to acceptors</li><li>acceptors 承认不会接收n以下的proposals（freeze）, 发送最高n的accepted proposal</li><li>proposer收到majority的promise, 取最高n的proposed value (如果没有就任取一个v（说明第一次）)进行accept(n, v)</li><li>acceptor接收了(n, v)，如果无接收prepare m&gt;n, 则accept proposal (ack); 否则reject(nack)</li><li>Proposer 接收到majority的response，decide否则abort</li></ol><p>可能abort的点</p><ul><li>Contention (multiple proposals competing)</li><li>Message loss (not getting an ack)</li><li>process failue (proposer dies)</li></ul><p>Optimizations</p><ul><li>Paxos (AC) in a nutshell</li></ul><p>Necessary:<br>rej accept(n,v) if answered prepare(m): m&gt;n</p><p>Optimizations:</p><ol><li>rej prepare(n) if answered prepare(m): m&gt;n</li><li>rej accept(n,v) if answered accept(m,u): m&gt;n</li><li>reject prepare(n) if answered accept(m, u): m&gt;n</li><li>ignore old msgs to proposals that got majority</li></ol><p>Proposer skips the accept phase if a majority of acceptors return the same value v<br>performance++</p><p>只要有stable storage可以应用到fail recover model</p><h2 id="RSM-Replicated-State-Machine"><a href="#RSM-Replicated-State-Machine" class="headerlink" title="RSM (Replicated State Machine)"></a>RSM (Replicated State Machine)</h2><p>multi-paxos:</p><p>ProCmds = {}<br>Log = &lt;&gt;<br>s0(initial state)<br>proposed = false</p><p>A client q wants to execute a command C, it reliably rb-broadcast &lt;C, Pid_q&gt; to all servers<br>upon delivery &lt;C,Pid_q&gt; at pj, the command pair is added to ProCmds unless it is already in Log</p><p>Validity<br>● If process p decides v then v is a sequence of proposed commands<br>(without duplicates)<br>Uniform Agreement<br>● If process p decides u and process q decides v then one is a prefix of<br>the other<br>Integrity<br>● If process p decides u and later decides v then u is a strict prefix of v<br>Termination (liveness)<br>● If command C is proposed by a correct process then eventually every<br>correct process decides a sequence containing C</p><p>Agree on (non-duplicate) commands<br>allow to issue the same command C multiple times</p><p>Initial state<br>Propoer:<br>np:=0 proposer’s current round number<br>vp:=&lt;&gt; proposer’s current value (empty sequence)</p><p>Acceptor:<br>npromise:=0 promise not to accept in lower rounds<br>na:=0 round number in which a value is accepted<br>va:=&lt;&gt; accepted value(empty sequence)</p><p>Learner<br>vd:=&lt;&gt; decided value(empty sequence)</p><p>看ppt图</p><p>依然有一些问题<br>● A proposer can run only one proposal until decide before taking the<br>next proposal. No pipelining of proposals<br>● Multiple proposers may lead to live-locks (liveness violation)<br>● Two round-trips for each sequence chosen </p><p>use BLE to make a single proposer running for a longer period of time as a leader</p><p>BLE1: Eventually every correct process trusts some correct correct process if a majority are correct<br>BLE2: Eventually no two correct processes trust different correct processes</p><p>We assume initially fail-noisy<br>but net is weaker model that may drop msg and process crash and recover</p><p>Majority requirement</p><ul><li>Each correct process will trust a leader only if the leader’s max ballot is among the collected ballots from a majority of processes</li><li>Monotonically increasing ballots<br>Every process p that do not receive the leader’s ballot (n, pidL) among collected ballots consider the leader has crashes p increases his own ballot (n+1, pidp)</li></ul><p>Eventual agreement&lt;=&gt; BLE2<br>Completeness&lt;=&gt; BLE1</p><h2 id="Leader-Based-Sequence-Paxos"><a href="#Leader-Based-Sequence-Paxos" class="headerlink" title="Leader Based Sequence Paxos"></a>Leader Based Sequence Paxos</h2><p>Assume eventual leader election abstraction with a ballot number BLE<br>BLE satisfies completeness and eventually accuracy and also monotonically unique ballots</p><p>P4 inefficient</p><ul><li>有多个proposer时，conflicts和restarts are likely (higher load -&gt; more conflicts)</li><li>2 round of msgs for each value chosen (Prepare, Accept)</li></ul><p>Solution:</p><ul><li>pick a leader (L,n) where n is a unique higher round number</li><li>the leader acts as sole Proposer for round n</li><li>After first Prepare (if not aborted) only perform Accepts until aborted by another Leader where n’ &gt; n</li></ul><p>Allow issuing and accepting multiple proposals in round n</p><p>Initial State for Sequence Paxos</p><ul><li><p>Proposers<br>nL=0, vL=      leader’s current round number, proposed value<br>propCmds=&lt;&gt;     leader’s current set of proposed commands(empty set)<br>las=[0]^N     length of longest accepted sequence per acceptor<br>lc=0        length of longest chosen sequence<br>state={(leader, prepare), (leader, accept), follower}</p></li><li><p>Acceptor<br>nprom=0     Pomise not to accept in lower rounds<br>na=0         round number in which a value is accpeted<br>va=&lt;&gt;        Accepted value(empty sequence)</p></li><li><p>Learner    Decide value(empty sequence)</p></li></ul><p>Removing redundancy of vL, va and vd</p><p>removing vL:<br>When p becomes a leader, it is possible to remove the need to<br>store the sequences vL and va separately at the leader </p><p>removing vd: at decide phase</p><p>add a new assumption<br>A3: FIFO Perfect Links</p><p>partially sync for BLE</p><p>but async for LBSP</p><h2 id="Reconfiguration"><a href="#Reconfiguration" class="headerlink" title="Reconfiguration"></a>Reconfiguration</h2><p>A replicated state machine is running on a set of N processes</p><p>Impossible to know if a process is faulty or slow in asychronous system</p><ul><li>must be able to replace any process</li></ul><p>this is called reconfiguration</p><p>Each configuration is conceptually an instance of Sequence-Paxos<br>replicas in configuration c1 = {r11,r12,r13,r14}<br>A process may act as multiple replicas in different configurations<br>e.g. p1 is {r01, r11, r21}</p><p>if seq v is issued in round n then v is an extension of all sequences chosen in rounds &lt;= n</p><p>stop-sign - last command - final sequence</p><p>rij: replica j in config i</p><p>Overlapping configurations</p><p> A process have replicas in multiple configurations<br>But can only be running in one configuration at any<br>time</p><h2 id="Time-and-Clocks-in-DS"><a href="#Time-and-Clocks-in-DS" class="headerlink" title="Time and Clocks in DS"></a>Time and Clocks in DS</h2><p>Motivation for using physical clocks<br>Consider a slightly stronger system model:</p><ul><li>Computation: no bounds on time to take a step</li><li>Communication: no bounds on latency</li><li>Clocks: Lower and upper bounds on clock rate</li></ul><ol><li>Time-based leader leases</li></ol><p>network partition P17<br>one is elected as leader but the original leader never hears about that</p><p>A propose p to become leader: sends a request (prepare) to acceptors</p><ul><li>An acceptor gives a time-based leader lease to p, lasting for 10 seconds</li><li>If a proposer gets leases from a majority of acceptors, then proposer holds lease on group and becomes a leader</li><li>In the time until the first acceptor lease expires, the proposer knows that no other proposer can hold the lease on the group<br>此时leader可以从local state里读然后直接返回</li></ul><p>两个问题<br>asynchronous network<br>clock drift</p><p>P34<br>如果proposer（receive lease的人）时钟比较快，那么leader会先取消自己的时钟，所以不会影响safety</p><p>反之，如果acceptor（give lease的人）时钟比较快，就会影响safety</p><ol start="2"><li>Shared memory using clocks</li></ol><p>Review of shared memory:<br>Leases at proposer<br>The Read-Impose Write-Consult_Majority algorithm does 2 round-trips to a majority of processes for both reads and writes<br>…</p><p>need synchronized clocks</p><p>Interval Clocks<br>Ci(t) = (lo, hi)</p><p>the correct time t is guaranteed to be in interval<br>Ci(t).lo &lt;= t &lt;= Ci(t).hi</p><p>Ci read at t1, Cj read at t2, and t1 &lt; t2<br>Ci(t1).lo &lt; Cj(t2).hi</p><p>use ICs to remove <strong>query phase in write operations</strong></p><ol><li>p1 must wait until ts(o1).t &lt;= C1(t1).lo   </li><li>ts(o2).t = C2(t2).hi   (invoke write o2)</li></ol><p>因为t1 &lt; t2 所以 C1(t1).lo &lt; C2(t2).hi<br>Hence: ts(o1) &lt; ts(o2)</p><h2 id="Consistent-Snapshot"><a href="#Consistent-Snapshot" class="headerlink" title="Consistent Snapshot"></a>Consistent Snapshot</h2><p>failure recovery and reconfiguration</p><p>SNAP -&gt; Restart system from snapshot<br>    -&gt; restart system with new configuration</p><p>S1: Termination: Eventuallt every process records its state<br>S2: Validity: All recorded states correspond to a consistent cut of the execution</p><p>Chandy Lamport Algorithm</p><ul><li>FIFO Reliable Channels</li><li>Single Initiating Process pi</li><li>Strong Connectivity 强连通</li></ul><p>Design goal:<br>Obstruction-free: run concurrently but not alter underlying computation</p><p>Intuition:<br>Disseminate a special message to mark events before and after the consistent cut</p><p>Termination is still satisfied if the protocol is initiated by a set of processes that can reach all tasks.</p><p>Epoch Snapshotting:<br>make production-grade data processing systems reliable</p><p>Previous approaches</p><ul><li>Complex Workarounds (e.g., duplicate elimination, input logging, acks) </li><li>Strong Assumptions (idempotent operations, key vs task level causal order) </li><li>External State Management (transactional external commits per action</li></ul><p>Epoch-based stream execution the intuition<br>for each epoch<br>input: deterministic input streams &amp; task states<br>stream processing system<br>success: commit system configuration<br>failure: abort and start from previous epoch</p><p>consistent cut is not enough<br>epoch cut support the large stream processing system</p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dirty read, phantom read, and unrepeatable read</title>
      <link href="/blog/2021/02/22/dirty-read-phantom-read-and-unrepeatable-read/"/>
      <url>/blog/2021/02/22/dirty-read-phantom-read-and-unrepeatable-read/</url>
      
        <content type="html"><![CDATA[<h1 id="dirty-read-phantom-read-and-unrepeatable-read"><a href="#dirty-read-phantom-read-and-unrepeatable-read" class="headerlink" title="dirty read, phantom read, and unrepeatable read"></a>dirty read, phantom read, and unrepeatable read</h1><a id="more"></a><p>脏读dirty read：读取未提交的数据。B发起事务，B写后，A读（读取未提交的数据），但B之后回滚了，再提交，A再读，不一致。</p><p>不可重复读unrepeatable read：前后多次读取不一致。A读，B写，B提交，A再读，不一致。<strong>针对update操作</strong>。</p><p>幻读phantom read：前后多次读取，数据总量不一致。A读数据库行数，B插入或删除某一行，A再读行数，不一致。 <strong>针对insert和delete操作</strong></p><p><strong>解决方案</strong>：</p><p>根据数据库事务四大性质中的隔离性：隔离性级别被分为read_uncommit，read_commit，read_repeatable，Serializable用以解决以上的问题。它们的区别是：read_uncommit没有解决任何问题，read_commit解决了脏读，read_repeatable解决了脏读和不可重复读，Serializable解决了三种情况。</p><p>read_commit：在上文的情况下，B写的整个事务周期，A都不能读。只有B发起事务前和提交事务后A才能读，这样就不会出现B写时A读从而读取不一致的情况。（Sql Server , Oracle使用的就是read_commit级别）</p><p>read_repeatable: 保证了不出现脏读，并且保证不可重复读。A读时，就对行加锁，B不能写这条数据。直到A多次读完后，B才能写。（MySQL使用的就是read_repeatable级别）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* （参数可以为：Read uncommitted，Read committed， Repeatable，Serializable） */</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> Repeatable;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`users`</span> <span class="keyword">WHERE</span> <span class="string">`id`</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></p><p>serializable：保证了不出现脏读、不可重复读和幻读。A读时，对表加锁，B不能添加或删除其它数据行。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">Serializable</span>;</span><br></pre></td></tr></table></figure></p><p>参考</p><p><a href="">https://cloud.tencent.com/developer/article/1450773</a></p><p><a href="">https://segmentfault.com/a/1190000016566788</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Disributed Framework and Dubbo</title>
      <link href="/blog/2021/01/28/Disributed-Framework-and-Dubbo/"/>
      <url>/blog/2021/01/28/Disributed-Framework-and-Dubbo/</url>
      
        <content type="html"><![CDATA[<h1 id="Distributed-Framework-and-Dubbo"><a href="#Distributed-Framework-and-Dubbo" class="headerlink" title="Distributed Framework and Dubbo"></a>Distributed Framework and Dubbo</h1><a id="more"></a><h2 id="What-is-Distributed-System"><a href="#What-is-Distributed-System" class="headerlink" title="What is Distributed System?"></a>What is Distributed System?</h2><p>a collection of independent comptuters which serve like a coherent system to users.</p><h2 id="Framework-transition-and-why-we-need-Distributed-Framework"><a href="#Framework-transition-and-why-we-need-Distributed-Framework" class="headerlink" title="Framework transition and why we need Distributed Framework?"></a>Framework transition and why we need Distributed Framework?</h2><h3 id="All-in-One-Architecture"><a href="#All-in-One-Architecture" class="headerlink" title="All in One Architecture"></a>All in One Architecture</h3><p>Initially, we have one simple application, on which all the functionalities are integrated, when we have only a few users. At that time, ORM is necessary because it simplify the CRUD processes.</p><p>When there are more and more users, we surely need more servers to bear more pressure (One application Multiple servers). Therefore we need more servers ro bear the pressure together (use Ngnix to balance overload). However that will cause two problems:</p><ul><li><p>Difficult to extend<br>When we modify one func of one server, we need to package the whole application again to other servers.</p></li><li><p>Difficult to collaborate</p></li></ul><h3 id="Vertical-Architecture"><a href="#Vertical-Architecture" class="headerlink" title="Vertical Architecture"></a>Vertical Architecture</h3><p>different modules of applications (e.g. User/Shopping Cart/Payment), assign different number of servers to modules based on demands. We will meet the problems and we should also:  </p><ul><li><p>View/ Logics should be divided </p></li><li><p>Applications cannot be fully seperated, some should interact</p></li></ul><h3 id="RPC-Architecture"><a href="#RPC-Architecture" class="headerlink" title="RPC Architecture"></a>RPC Architecture</h3><p>But there yield another problem, how to interact between Web view and Services logics as they are divided?</p><p>Answer: Use RPC (Remote Process Call).</p><p>Therefore, we need a distributed service framework to handle the RPC. And we also need a <strong>scheduler</strong> to balance the load.</p><h2 id="RPC-problems"><a href="#RPC-problems" class="headerlink" title="RPC problems"></a>RPC problems</h2><p>RPC is a method that used by one service on one server A to call the procedure on another server B.</p><p>Both server A and B should have its own stub (helper) to handle the sending messages(functions/parameters)and returning messages(results). The RPC is an aynchronous process. To send or receive the messages the stub should firstly serialize or deserialize the objects.</p><p>The core problems in an RPC framework:</p><ul><li>how efficient to establish connection</li><li>how efficient to serialize/deserialize</li></ul><h2 id="RPC-framework-Dubbo"><a href="#RPC-framework-Dubbo" class="headerlink" title="RPC framework - Dubbo"></a>RPC framework - Dubbo</h2><p><a href="https://dubbo.apache.org/en/" target="_blank" rel="noopener">https://dubbo.apache.org/en/</a></p><p><img src="https://raw.githubusercontent.com/apache/dubbo-website/master/static/imgs/architecture.png" alt="arch"></p><p>Dubbo is a framework with following features:</p><ul><li>Interface-based High-performance RPC</li><li>Intelligent load balance</li><li>Automatic service registration and discovery (“recommend”)</li><li>High extensibility (micro-kernal and plugin design)</li><li>Runtime traffic routing (blue-green deployment, some requests use new services, some use old services)</li><li>Visualization</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Byzantine Leader Election</title>
      <link href="/blog/2021/01/24/Byzantine-Leader-Election/"/>
      <url>/blog/2021/01/24/Byzantine-Leader-Election/</url>
      
        <content type="html"><![CDATA[<h1 id="Why-in-Byzantine-Leader-Election-N-gt-3f"><a href="#Why-in-Byzantine-Leader-Election-N-gt-3f" class="headerlink" title="Why in Byzantine Leader Election, N &gt; 3f"></a>Why in Byzantine Leader Election, N &gt; 3f</h1><a id="more"></a><p>Given<br>N: number of the processes<br>f: number of the Byzantine processes</p><p>In the paper “Practical Byzantine Fault Tolerance”, we get the conclusion that 3f+1 is the minimum number of replicas that allow an asynchronous system to provide the safety and liveness properties when up to f replicas are faulty. This many replicas are needed because it must be possible to proceed after communicating with n-f replicas, since f replicas might be faulty and not responding. However, it is possible that the f replicas that did not respond are not faulty and therefore f of those that responded might be faulty. Even so, there must still be enough responses that those from non-faulty replicas outnumber those from faulty ones, i.e., n-2f&gt;f. Therefore n&gt;3f.</p><p>理解起来其实很困难，总给人一种哪里不对的感觉。比如为什么不能直接大多数N &gt; 2f 就能解决呢？只要有f+1个正确节点都表态(+)，即使有f个拜占庭节点都投反对票(-)，那正确节点也占多数，最后不也达成了正确的一致性吗？</p><p>但是这忽略了系统的一个根本问题：什么时候才能达成一致性呢？拜占庭节点之所以叫拜占庭节点，就是说它所做的是不可控的（表态可以是表态+或-或者干脆不表态）。也就是说，如果我规定某个节点A（可能是正常也可能是拜占庭节点）要知道大多数的意见，A需要收集N个消息（包括自己），但是拜占庭可能不回复，因此就永远收集不了N-f个消息，无限等待。我们当然不希望无限等待一个永远不回复的拜占庭节点，因此我们的quorum就必须规定为最大N-f。当我们收集到最多N-f个消息后，我们就必须能够通过多数派判断选票结果。</p><p>因此，考虑到拜占庭节点的不确定性，除了本身N-f即形成quorum，我们还要考虑回复消息的至多f个拜占庭节点，除去这些节点，也即N-2f这些节点必是正确节点，这些节点的个数要大于f个拜占庭节点从而形成正确的consensus，也即N-2f&gt;f，也即N&gt;3f。</p><p>例子：</p><p>前提：由于f个拜占庭节点可能都挂，f个拜占庭节点可能不回复，所以必须收集到最多N-f个消息就已经决定结果了，也就是最大的quorum大小Q（极限情况）</p><p>f=1时，<br>N=3，不行，因为收到2个消息时，可能一正一误，无法判断。<br>N=4，可以，因为收到3个消息，必有两正一误，或三正，都可以得出正确结果。<br>N&gt;4，可以，收到N-1个消息，必有N-1 &gt; 2 * 1，quorum中正确节点数总是大于拜占庭节点数</p><p>f=2时，<br>N=5，不行，因为收到3个消息时，可能一正两误。<br>N=6，不行，因为收到4个消息时，可能两正两误，无法判断。<br>N=7，可以，因为收到5个消息，必有三正，大于两误，可以得出正确结果。<br>N&gt;7，可以，收到N-2个消息，必有N-2 &gt; 2 * 2，quorum中正确节点数总是大于拜占庭节点数</p><p>…</p><p>由以上每种情况最后一行类推，N-f &gt; 2 * f，可知<br>N &gt; 3f</p><blockquote><p>补充：没有拜占庭情况，即crash-stop, crash noisy, crash-recovery, crash silent情况<br>N=2f+1, Q=(N+1)/2<br>有拜占庭情况，<br>N=3f+1，Q=N-f也等于2f+1<br><!-- N>3f+1，Q>=(N+f+1)/2 --></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVM公式推导和原理解析</title>
      <link href="/blog/2020/12/16/SVM%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/blog/2020/12/16/SVM%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="SVM公式推导和原理解析"><a href="#SVM公式推导和原理解析" class="headerlink" title="SVM公式推导和原理解析"></a>SVM公式推导和原理解析</h1><a id="more"></a><p><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/12/16/SVM%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/1.jpg"></p><p><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/12/16/SVM%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E5%92%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多分类AUC计算</title>
      <link href="/blog/2020/11/07/%E5%A4%9A%E5%88%86%E7%B1%BBAUC%E8%AE%A1%E7%AE%97/"/>
      <url>/blog/2020/11/07/%E5%A4%9A%E5%88%86%E7%B1%BBAUC%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>一般涉及到的是binary classification的AUC计算,这里给出的计算方法即可用于binary也可用于多分类问题。</p><a id="more"></a><p>input: 给定的dataframe, 实际预测的correctlabels<br>output: AUC 面积</p><p>举个例子，给定的dataframe是</p><table><thead><tr><th>d</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>0</td><td>0.50</td><td>0.50</td><td>0.00</td></tr><tr><td>1</td><td>0.50</td><td>0.25</td><td>0.25</td></tr><tr><td>2</td><td>0.50</td><td>0.25</td><td>0.25</td></tr><tr><td>3</td><td>0.25</td><td>0.50</td><td>0.25</td></tr><tr><td>4</td><td>0.25</td><td>0.25</td><td>0.50</td></tr></tbody></table><p>A,B,C代表三个类，其中的数字代表着预测该类的概率  </p><p>而corrrectlabels也即实际预测的结果是[“B”,”A”,”B”,”B”,”C”]<br>这两者作为input可以计算output的AUC面积</p><p>以下是求面积的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pos_neg_instance_scores</span><span class="params">(prediction_column, correct_labels, column_name)</span>:</span></span><br><span class="line">    prediction_column_array = np.array(prediction_column)</span><br><span class="line">    binary_AUC = [column_name == i <span class="keyword">for</span> i <span class="keyword">in</span> correct_labels] </span><br><span class="line">    print(<span class="string">'binary_AUC='</span>, binary_AUC)</span><br><span class="line">    <span class="comment"># positive_instance_scores =&gt; Col-Name (predicted class) matches with the correct class</span></span><br><span class="line">    positive_instance_scores = prediction_column_array[binary_AUC]</span><br><span class="line">    <span class="comment"># negative_instance_scores =&gt; Col-Name (predicted class) DOES NOT match with the correct class</span></span><br><span class="line">    negative_instance_scores = prediction_column_array[~np.array(binary_AUC)]</span><br><span class="line">    print(positive_instance_scores)</span><br><span class="line">    print(negative_instance_scores)</span><br><span class="line">    <span class="keyword">return</span> positive_instance_scores, negative_instance_scores</span><br><span class="line"></span><br><span class="line"><span class="comment"># fpr=False_Positive_Rate</span></span><br><span class="line"><span class="comment"># tpr=True_Positive_Rate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tpr_fpr</span><span class="params">(prediction_column, correct_labels, column_name)</span>:</span></span><br><span class="line">    positive_instance_scores, negative_instance_scores = find_pos_neg_instance_scores(prediction_column, correct_labels, column_name)</span><br><span class="line"><span class="comment">#     print(positive_instance_scores)</span></span><br><span class="line"><span class="comment">#     print(negative_instance_scores)</span></span><br><span class="line">    scores_extended = [<span class="number">0</span>]</span><br><span class="line">    scores_extended += sorted(prediction_column)</span><br><span class="line">    scores_extended += [<span class="number">1</span>]</span><br><span class="line">    print(<span class="string">'scores_extended='</span>,scores_extended)</span><br><span class="line">    dict_tpr_fpr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> predicted_score <span class="keyword">in</span> scores_extended:</span><br><span class="line">        <span class="keyword">if</span>(len(negative_instance_scores)==<span class="number">0</span>):</span><br><span class="line">            count_false_pos_instances = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_false_pos_instances = np.sum(negative_instance_scores &gt;= predicted_score)/len(negative_instance_scores)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len(positive_instance_scores)==<span class="number">0</span>):</span><br><span class="line">            count_true_pos_instances = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count_true_pos_instances = np.sum(positive_instance_scores &gt;= predicted_score)/len(positive_instance_scores)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#dict_tpr_fpr[predicted_score] = [count_false_pos_instances, count_true_pos_instances]</span></span><br><span class="line">        dict_tpr_fpr[predicted_score] = [count_true_pos_instances, count_false_pos_instances]</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'dict_tpr_fpr='</span>,dict_tpr_fpr)</span><br><span class="line">    list_reversed_tpr_fpr = [i <span class="keyword">for</span> i <span class="keyword">in</span> reversed(list(dict_tpr_fpr.values()))]</span><br><span class="line">    print(<span class="string">'list_reversed_tpr_fpr='</span>, list_reversed_tpr_fpr)</span><br><span class="line">    <span class="keyword">return</span> list_reversed_tpr_fpr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_AUC</span><span class="params">(list_reversed_tpr_fpr)</span>:</span></span><br><span class="line">    <span class="comment"># AUC = Area under ROC curve</span></span><br><span class="line">    AUC = <span class="number">0</span></span><br><span class="line">    n_tpr_fpr = len(list_reversed_tpr_fpr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_tpr_fpr - <span class="number">1</span>):        </span><br><span class="line">        <span class="keyword">if</span>(list_reversed_tpr_fpr[i][<span class="number">1</span>] != list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># if fpr is changing but tpr is not changing then the area is a square=a*b=(tpr[i+1]-0)*(fpr[i+1]-fpr[i])</span></span><br><span class="line">            <span class="keyword">if</span>(list_reversed_tpr_fpr[i][<span class="number">0</span>] == list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">0</span>]):</span><br><span class="line">                AUC += list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">0</span>]*(list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">1</span>] - list_reversed_tpr_fpr[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># if both are changing then the area is a trapezoid=(a+b)*h/2=(tpr[i]+tpr[i+1])*(fpr[i+1]-fpr[i])/2</span></span><br><span class="line">                AUC += (list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">0</span>] + list_reversed_tpr_fpr[i][<span class="number">0</span>])*(list_reversed_tpr_fpr[i + <span class="number">1</span>][<span class="number">1</span>] - list_reversed_tpr_fpr[i][<span class="number">1</span>])/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> AUC</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc</span><span class="params">(df, correctlabels)</span>:</span></span><br><span class="line">    AUC = <span class="number">0</span></span><br><span class="line">    class_frequency = dict()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> correctlabels:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> class_frequency:</span><br><span class="line">            class_frequency[i] = (<span class="number">1</span>/len(correctlabels))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            class_frequency[i] += (<span class="number">1</span>/len(correctlabels))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">        prediction_vector = df[col]</span><br><span class="line">        list_reversed_tpr_fpr = get_tpr_fpr(prediction_vector, correctlabels, col)</span><br><span class="line">        area_col = calculate_AUC(list_reversed_tpr_fpr)</span><br><span class="line">        AUC += class_frequency[col] * area_col</span><br><span class="line">    <span class="keyword">return</span> AUC</span><br></pre></td></tr></table></figure><p>测试代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predictions = pd.DataFrame(&#123;<span class="string">"A"</span>:[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.25</span>,<span class="number">0.25</span>],<span class="string">"B"</span>:[<span class="number">0.5</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>],<span class="string">"C"</span>:[<span class="number">0.0</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">correctlabels = [<span class="string">"B"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"AUC: &#123;&#125;"</span>.format(auc(predictions,correctlabels)))</span><br></pre></td></tr></table></figure></p><p>步骤说明：<br>第一步即调用auc方法计算class_frequency，即利用frequency作为<strong>权重</strong>将所有类的AUC相加。(Calculate the weighted AUC by summing the individual AUCs weighted by the relative<br>frequency of each class (as estimated from the correct labels)  </p><p>接下来就是计算每个类的AUC了,实际上是每个类的binary AUC, 也即对于这个类的FPR和TPR点所围面积的和 <a href="https://zh.wikipedia.org/wiki/ROC%E6%9B%B2%E7%BA%BF" target="_blank" rel="noopener">概念链接</a>。 </p><p>因此，首先我们必须计算TPR和FPR点的坐标，也就是<code>get_tpr_fpr</code>函数，先找到其中判断对positive与错negative的scores（<code>find_pos_neg_instance_scores</code>函数），再对prediction_column（这里需要在首尾加一个0和一个1，好帮助后面的面积计算）中的每个prediction_score，判断它和判断negative 或positive instance的score的关系。得到count_false_pos_instances和count_true_pos_instances的两句实际上就是FPR（在所有实际为阴性的样本中，被错误地判断为阳性之比率FPR=FP/(FP+TN)）和TPR（在所有实际为阴性的样本中，被错误地判断为阳性之比率TPR=TP/(TP+FN)）的计算过程。 </p><p>这一步之后再进行个从小到大的排序，其实就得到了所有的score对应的TPR和FPR pair 也即点坐标，只要画出点坐标连接后下方在坐标轴上的面积（以TPR为纵轴，FPR为横轴），就可以得到AUC的面积了。而这一步则用<code>calculate_AUC</code>函数自动计算得到。</p><p>得到了每一个类的AUC，再做一个weight sum就是最后的多分类AUC面积。</p><p>更简单的多分类方法（概率方法）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auc</span><span class="params">(df,correctlabels)</span>:</span></span><br><span class="line">    new_df=df.copy()</span><br><span class="line">    lens=len(correctlabels)</span><br><span class="line">    cols=new_df.columns.tolist()</span><br><span class="line">    <span class="keyword">if</span> len(cols)&lt;<span class="number">3</span>: <span class="comment">#binary ;only Pos and Neg</span></span><br><span class="line">        pos=[ i <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)  <span class="keyword">if</span> correctlabels[i]==cols[<span class="number">0</span>]]</span><br><span class="line">        neg=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)  <span class="keyword">if</span> correctlabels[i]!=cols[<span class="number">0</span>]]                    </span><br><span class="line">        print(pos,neg)</span><br><span class="line">        one=new_df[cols[<span class="number">0</span>]]</span><br><span class="line">        auc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pos:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> neg:</span><br><span class="line">                <span class="keyword">if</span> one[i] &gt; one[j]:</span><br><span class="line">                    auc += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> one[i] == one[j]:</span><br><span class="line">                    auc += <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> auc / (len(pos)*len(neg))</span><br><span class="line">    <span class="keyword">else</span>:      <span class="comment"># CLASS &gt;=3   Pos / non-Pos</span></span><br><span class="line">        aucs=[]</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">            pos=[ i <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)  <span class="keyword">if</span> correctlabels[i]==col]</span><br><span class="line">            nonpos=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)  <span class="keyword">if</span> correctlabels[i]!=col]                      </span><br><span class="line">            print(pos,nonpos)</span><br><span class="line">            one=new_df[col]</span><br><span class="line">            auc = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> pos:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> nonpos:</span><br><span class="line">                    <span class="keyword">if</span> one[i] &gt; one[j]:</span><br><span class="line">                        auc += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> one[i] == one[j]:</span><br><span class="line">                        auc += <span class="number">0.5</span></span><br><span class="line">            auc=auc/(len(pos)*len(nonpos))</span><br><span class="line">            aucs.append(auc)</span><br><span class="line">        weights=[correctlabels.count(col)/len(correctlabels) <span class="keyword">for</span> col <span class="keyword">in</span> cols ]</span><br><span class="line">        print(weights)</span><br><span class="line">        print(aucs)</span><br><span class="line"></span><br><span class="line">        weights=np.array(weights)</span><br><span class="line">        aucs=np.array(aucs)</span><br><span class="line">        avg_auc=np.sum(aucs*weights)</span><br><span class="line">        <span class="keyword">return</span> avg_auc</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">predictions = pd.DataFrame(&#123;<span class="string">"A"</span>:[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.25</span>,<span class="number">0.25</span>],<span class="string">"B"</span>:[<span class="number">0.5</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.25</span>],<span class="string">"C"</span>:[<span class="number">0.0</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">correctlabels = [<span class="string">"B"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"AUC: &#123;&#125;"</span>.format(auc(predictions,correctlabels)))</span><br></pre></td></tr></table></figure></p><p>简单的二分类AUC计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_auc</span><span class="params">(prob, labels)</span>:</span></span><br><span class="line">    f = list(zip(prob, labels))</span><br><span class="line">    rank = [values2 <span class="keyword">for</span> values1, values2 <span class="keyword">in</span> sorted(f, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])]</span><br><span class="line">    rankList = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(rank)) <span class="keyword">if</span> rank[i] == <span class="number">1</span>]</span><br><span class="line">    posNum = <span class="number">0</span></span><br><span class="line">    negNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labels)):</span><br><span class="line">        <span class="keyword">if</span> (labels[i] == <span class="number">1</span>):</span><br><span class="line">            posNum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            negNum += <span class="number">1</span></span><br><span class="line">    auc = (sum(rankList) - (posNum * (posNum + <span class="number">1</span>)) / <span class="number">2</span>) / (posNum * negNum)</span><br><span class="line">    <span class="keyword">return</span> auc</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">model = BernoulliNB()</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line">prediction = model.predict_proba(x_val)</span><br><span class="line">auc = cal_auc(prediction[:, <span class="number">1</span>], np.array(y_val))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>computer network</title>
      <link href="/blog/2020/08/03/computer-network/"/>
      <url>/blog/2020/08/03/computer-network/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络知识点"><a href="#计算机网络知识点" class="headerlink" title="计算机网络知识点"></a>计算机网络知识点</h1><a id="more"></a><p>用户态（应用层HTTP,FTP,DNS,HTTPS)<br>核心态(传输层tcp, 网络层ip, 链路层)</p><p>二、链路层</p><p>功能：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正</p><ul><li><p>以太网帧格式<br>7字节前导码（同步）<br>1字节帧开始符<br>6子节MAC目标地址<br>6子节MAC源地址<br>一个4子节标签（可选）<br>2字节以太类型（0x0800 IPv4; 0x0806 ARP)<br>负载46-1500字节<br>CRC冗余校验<br>帧间距12字节<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/EthernetFrame.jpg" alt="1"></p></li><li><p>MTU（Maximum transmission Unit) 数据链路层最大数据包大小，单位：字节。即无需进一步分片就能穿过这条“路径”的最大传输单元的最大值。如果不要分片，设置数据报的DF位（Don’t fragment），路径上任何需要将分组进行分片的设备都会将这种数据报丢弃并返回一个“数据报过大”的ICMP响应到源地址。</p></li></ul><ul><li><p>arp协议 address resolution protocol 实现ip地址到MAC地址的映射，即询问目标IP地址对应的MAC地址，然后放入ARP缓存表。<br>原理：把带有目标ip地址的arp请求广播到局域网上所有主机，并接受响应获取mac地址。存入arp缓存表一段时间。<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/arp报文格式.png" alt="2"><br>目的MAC地址：占6字节，表示接收方设备的硬件地址，在请求报文中该字段值全为0，即00-00-00-00-00-00，表示任意地址，因为现在不知道这个MAC地址。</p></li><li><p>基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议（2字节以太类型（0x0800 IPv4; 0x0806 ARP)）</p></li></ul><p>三、网络层<br>功能：1、路由选择（规划路线）<br>2、存储、交换、转发（路由器通过路由表转发包，如果接收速度大于转发速度就缓存）3、拥塞控制 4、呼叫准入（所有路由器的许可）</p><ul><li><p>ip首部格式：<br>如图第二行，16位序列号：如有分片，下一个序列号与上一个相同，若无分片，下一个序列号等于上一个加一。<br>3三个bit位：第一位保留，未使用。第二位是DF（Don’t Fragment），如果为1，表示未发生分片。第三位是MF（More Fragment），如果为1，表示发生了分片，并且除了分片出的最后一个报文中此标志为0，其余报文中此标志均为1。<br>13位片位移：分片相对于原始ip数据报开始处的偏移。</p></li><li><p>8位生存时间TTL（time to live), 防止数据报兜圈子，不断减去在路由器间传递的时间，直到零就丢弃数据报，不再转发。</p></li><li>16位首部检验和<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/ip报文格式.png" alt="3"></li></ul><blockquote><p>掌握IP分片<br>一个长4000B的IP数据报，数据部分3980B,到达了一个路由，需要转发到一个MTU为1500B的链路上，这样就得分片了。分片数目是3片。每个片都是一个数据报。假设标识是777，那么数据报分片结果是：<br>分片一：标识：777，MF=1，DF=0,片偏移=0，有效数据：1480B(编号0~1479)<br>分片二：标识：777，MF=1,DF=0,片偏移=185，185<em>8=1480，有效数据：1480B(编号1480~2959)<br>分片三：标识：777，MF=0,DF=0,片偏移370，370</em>8=2960，有效数据：1020B(编号2960~3979)</p></blockquote><ul><li>IP路由表<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/IP分组转发流程.jpg" alt="4"></li></ul><p>分组转发流程</p><ol><li>从数据报首部提取主机的IP地址D，得到目的网络地址N（子网掩码存储在路由表中，与IP地址D进行逻辑与即可得到N）</li><li>若N是与此路由器直接相连的某个网络地址，直接交付</li><li>若路由表中有目的地址为D的特定主机路由/到达网络N的路由，则把数据报传送给表中指明的下一跳路由</li><li>若路由表中有一个默认路由，则把数据报传送给路由表所指明的默认路由器</li><li>报告转发分组出错</li></ol><ul><li><p>IP内部网关协议RIP<br>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/RIP路由表建立.jpg" alt="5"></p></li><li><p>ICMP查询2种+差错5种<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/ICMP报文类型.png" alt="6"></p></li></ul><p>四、传输层<br>UDP协议：特点，首部字段</p><p>TCP协议：特点+首部字段+可靠机制<br>首部（校验和。。。）</p><p>连接基础</p><ul><li><p>三次握手</p><!-- ![5](computer-network/TCP三次握手.png) --><p>目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。主要防止资源的浪费。</p></li><li><p>四次挥手（为什么）</p><!-- ![6](computer-network/TCP四次挥手.png) --><p>关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，我们也未必全部数据都发送给对方了，所以我们不可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，我们的ACK和FIN一般都会分开发送。</p></li></ul><p>同时打开、同时关闭、半关闭</p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<code>半连接队列</code>。<br>当然还有一个<code>全连接队列</code>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。<a href="https://juejin.im/post/6844903958624878606" target="_blank" rel="noopener">来源链接</a></p><p><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/tcp-ip-handshark.png" alt="7"></p><p>tcp流量控制机制：<br>滑窗、<br><img src="https://raw.githubusercontent.com/Spycsh/blog/master/2020/08/03/computer-network/滑窗.jpg" alt="8"></p><ul><li>在未收到ACK确认之间都必须暂时保留在发送窗口内，以便超时重传使用</li></ul><p>慢启动、拥塞避免、快速重传、快速恢复<br>超时重传</p><p>伪包头</p><p>五、应用层<br>域名解析<br>DNS协议名字空间、DNS指针查询（反向查找或逆向解析）、DNS缓存</p><blockquote><p>DNS查询过程实例<br>1）客户端将<a href="http://www.redhat.com的查询提交给本地DNS服务器（递归查询）。" target="_blank" rel="noopener">www.redhat.com的查询提交给本地DNS服务器（递归查询）。</a><br>2）本地DNS服务器检查区域数据库，由于该服务器没有redhat.com的授权，它将查询传递到根服务器（“.”DNS服务器），请求解析主机名称。根名称服务器把“com”DNS服务器IP地址返回给本地DNS服务器（迭代查询）。<br>3）本地DNS服务器将请求发给“com”DNS服务器，该服务器根据请求将“redhat.com”DNS服务器IP地址返回给本地DNS服务器（迭代查询）。<br>4）本地DNS服务器向“redhat.com”DNS服务器发送请求，由于该服务器具有“<a href="http://www.redhat.com”记录，它将www.redhat.com的IP地址返回给本地DNS服务器。" target="_blank" rel="noopener">www.redhat.com”记录，它将www.redhat.com的IP地址返回给本地DNS服务器。</a><br>5）本地DNS服务器将<a href="http://www.redhat.com的IP地址发送给客户端。" target="_blank" rel="noopener">www.redhat.com的IP地址发送给客户端。</a></p></blockquote><p>FTP数据流、控制流：<br>端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流</p><p>两种工作模式：PASV+PORT</p><blockquote><p>   1、主动FTP：<br>命令连接：客户端 &gt;1024端口 -&gt; 服务器 21端口<br>数据连接：客户端 &gt;1024端口 <- 服务器="" 20端口="" 2、被动ftp：="" 命令连接：客户端="">1024端口 -&gt; 服务器 21端口 </-></p></blockquote><p>数据连接：客户端 &gt;1024端口 -&gt; 服务器 &gt;1024端口</p><p>我自己的理解是主动模式的话，客户端随意起一个大于1024端口去连服务器的21端口，然后告诉服务器我已经准备好数据连接了，你过来连我的数据端口吧，然后服务器用自己的20端口去连客户端的端口，注意此时客户端其实为了响应，是随意启用了一个自己不用的端口，即大于1024的端口。</p><p>被动模式：从头到尾都是客户端去连服务器，服务器一直处于响应状态。客户端打开两个大于1024的端口，然后第一个端口去连服务器的21号端口，告诉服务器：“你准备好了吗？我要向你传输数据了。然后服务器说我好了，客户端用自己事先开好的第二个端口去连接服务器，注意此时服务器的数据端口已经不是20了，服务器为了响应请求，随机开了一个大于1024端口<br>(<a href="https://blog.51cto.com/9237101/1911032" target="_blank" rel="noopener">https://blog.51cto.com/9237101/1911032</a>)</p><p>FTP指令和响应码<br>FTP断电续传、匿名ftp</p><p>HTTP<br>报文格式：请求报文、响应报文、请求头各种字段、响应头各种字段<br>http状态码</p><p>HTTPS<br>详细握手<br>摘要算法、数字签名、数字证书</p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go基础</title>
      <link href="/blog/2020/07/21/go%E5%9F%BA%E7%A1%80/"/>
      <url>/blog/2020/07/21/go%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="go-programming-基础"><a href="#go-programming-基础" class="headerlink" title="go programming 基础"></a>go programming 基础</h1><a id="more"></a><h2 id="Why-go"><a href="#Why-go" class="headerlink" title="Why go"></a>Why go</h2><p>1.Code run fast<br>2.Garbage collection<br>3.Simpler objects<br>4.Concurrency is efficient</p><p>Software Translation</p><ul><li>machine language: CPU instructions represented in binary</li><li>Assembly language: CPU ~ with mnemonics (easier to read)</li><li>High level language</li></ul><p>Compilation<br>Translate instructions while code is executed</p><ul><li>C++, C, Java (compiler) Translation occurs once</li><li>Java(compiled to bytecode then be interpreted), Python (interpreter) Translation occurs every execution</li></ul><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>Go is weakly OOP language</p><p>Go use structs instead of class</p><ul><li>No contructor, generics and inheritance</li></ul><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p>Performance Limits:<br>Moore’s Law<br>More transistors used to lead to higher clock frequencies<br>Power/temperature constraints</p><p>Parallelism<br>GPU thounsands of cores</p><ul><li>Concurrency is the management of multiple tasks at the same time</li><li>Key requirement for large systems</li><li>Concurrent programming enables parallelism<br>-&gt; Management of task execution<br>-&gt; Communication between tasks<br>-&gt; Synchronization between tasks</li></ul><p>Go includes concurrency primitives<br><code>Goroutines</code> represent concurrent tasks<br><code>Channels</code> are used to communicate between tasks<br><code>Select</code> enables task sysnchronization<br>Concurrency primitives are efficient and easy to use</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Package Main<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"hellow world\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Commands:</p><ul><li><code>go build</code> - compiles the program to .exe file</li><li><code>go doc</code> print documentation</li><li><code>go fmt</code> format indentation</li><li><code>go get</code> package</li><li><code>go run</code></li><li><code>go test</code></li></ul><h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>var x int = 100<br>var x, y int = 100</p><p>var x = 100 (auto infer)</p><p>x := 100</p><p>Define and alias for a type<br>type Celsius float64<br>type IDnum int</p><h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><p>A pointer is an address to data in memory</p><p><code>&amp;</code> returns the address of a variable/function</p><p><code>*</code> operator returns the data at the address<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">ip = &amp;x</span><br><span class="line">y = *ip</span><br></pre></td></tr></table></figure></p><p>New</p><ul><li>new() function creates a variable and returns a pointer to the variable<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*ptr = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Hi %s"</span>, x)</span><br></pre></td></tr></table></figure><p>x = int32(y)</p><h2 id="String-Package"><a href="#String-Package" class="headerlink" title="String Package"></a>String Package</h2><p>CompareTo(a, b)</p><p>Contains(s, substr)</p><p>HasPrefix(s, prefix)</p><p>Index(s, substr)</p><p>Replace(s, old, new, n)</p><p>ToLower(s)</p><p>TrimSpace(s)</p><p>returns a new string</p><h2 id="Strconv-Package"><a href="#Strconv-Package" class="headerlink" title="Strconv Package"></a>Strconv Package</h2><p>Atoi(s) -converts string s to int</p><p>Itoa(s) -convert int to string</p><p>FormatFloat(f, fmt,prec, bitSize) - convert flot to string</p><p>ParseFloat(s, bitSize) - Converts a string to a floating point number</p><h2 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h2><ul><li>Expression whose value is known at compile time</li><li>Type is inferred from righthand side (boolean, string number)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1.3</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    y=<span class="number">4</span></span><br><span class="line">    z=<span class="string">"Hi"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>iota (like enumerate)</p><ul><li>generate a set of related but distinct constants</li><li>Ofter represents a property which has several distinct values<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Grades <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    A Grade = <span class="literal">iota</span>  <span class="comment">// 0</span></span><br><span class="line">    B               <span class="comment">// 1</span></span><br><span class="line">    C               <span class="comment">// 2</span></span><br><span class="line">    D</span><br><span class="line">    F</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Allergen <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    IgEggs Allergen = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 &lt;&lt; 0 which is 00000001</span></span><br><span class="line">    IgChocolate                         <span class="comment">// 1 &lt;&lt; 1 which is 00000010</span></span><br><span class="line">    IgNuts                              <span class="comment">// 1 &lt;&lt; 2 which is 00000100</span></span><br><span class="line">    IgStrawberries                      <span class="comment">// 1 &lt;&lt; 3 which is 00001000</span></span><br><span class="line">    IgShellfish                         <span class="comment">// 1 &lt;&lt; 4 which is 00010000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Control-flow"><a href="#Control-flow" class="headerlink" title="Control flow"></a>Control flow</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"aa"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Printf(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Printf(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"nocase"</span>) <span class="comment">// auto break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><ul><li>Scan reads user input</li><li>Takes a pointer as an argument</li><li>Typed data is written to pointer</li><li>Returns number of scanned item</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appleNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Number of apples?"</span>)</span><br><span class="line">num, err := fmt.scan(&amp;appleNum)</span><br><span class="line">fmt.Printf(appleNum)</span><br></pre></td></tr></table></figure><h2 id="Composite-Data-types"><a href="#Composite-Data-types" class="headerlink" title="Composite Data types"></a>Composite Data types</h2><h3 id="Arrays-fixed-length"><a href="#Arrays-fixed-length" class="headerlink" title="Arrays: fixed length"></a>Arrays: fixed length</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">x:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// infers size from number of initializers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"ind %d, val %d"</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><ul><li>A “window” on an underlying array</li><li><p>Variable size, up to the whole array</p></li><li><p><code>Pointer</code> indicates the start of the slice</p></li><li><code>Length</code></li><li><code>Capacity</code> is the max number of elts(elements)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>&#125;</span><br><span class="line">s1:=arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s2:=arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s))<span class="comment">// 3 7</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sli := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// this is a slice because no ... or number in the bracket</span></span><br></pre></td></tr></table></figure><h3 id="init-a-slice-directly"><a href="#init-a-slice-directly" class="headerlink" title="init a slice directly"></a>init a slice directly</h3><ul><li><p><code>make()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)   <span class="comment">// 10 is the length</span></span><br><span class="line"></span><br><span class="line">sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">15</span>) <span class="comment">// 15 is the capacity</span></span><br></pre></td></tr></table></figure></li><li><p><code>append()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sli = <span class="built_in">append</span>(sli, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><ul><li>Implementation of a hash map</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> idMap <span class="keyword">map</span>[<span class="keyword">string</span>][<span class="keyword">int</span>]</span><br><span class="line">idMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">idMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"joe"</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idMap[<span class="string">"joe"</span>] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(idMap, <span class="string">"joe"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id, p := idMap[<span class="string">"joe"</span>]   <span class="comment">// id is value, p is True/False the key in the map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(idMap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> idMap&#123;</span><br><span class="line">    fmt.Println(key, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><p>Person Struct<br>Name, Address, phone</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">struct</span> Person&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    addr <span class="keyword">string</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 Person</span><br><span class="line"></span><br><span class="line"><span class="comment">// dot notation to access struct fields</span></span><br><span class="line">p1.name = <span class="string">"joe"</span></span><br><span class="line">x1 = p1.addr</span><br><span class="line"></span><br><span class="line"><span class="comment">// init a struct</span></span><br><span class="line">p1 := <span class="built_in">new</span>(Person)</span><br><span class="line"></span><br><span class="line">p1 := Person(name: <span class="string">"joe"</span>, addr: <span class="string">"a st."</span>, phone: <span class="string">"123"</span>)</span><br></pre></td></tr></table></figure><h2 id="Protocols-and-Format"><a href="#Protocols-and-Format" class="headerlink" title="Protocols and Format"></a>Protocols and Format</h2><ul><li>Request for Comments (RFC)</li><li>Definition of Internet protocols and format<br>e.g.</li></ul><ul><li>HTML Hypertext Markup Language</li><li>URI Uniform Resource Identifier</li><li>HTTP Hypertext Transfer Protocol</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line">http.Get(www.baidu.com)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net"</span></span><br><span class="line">net.Dial(<span class="string">"tcp"</span>, <span class="string">"uci.edu:80"</span>)   <span class="comment">//make a tcp connect with the url</span></span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JavaScript Object Notation</p><ul><li><p>Go struct<br>p1 := Person(name:”joe”, addr: “a st.”)</p></li><li><p>equivalent JSON object<br>{“name”:”jow, “addr”:”a st.”}</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 := Person(name:<span class="string">"joe"</span>, addr:<span class="string">"aaa"</span>)</span><br><span class="line">barr, err:=json.Marshal(p1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 Person</span><br><span class="line">err := json.Unmarshal(barr, &amp;p2)</span><br></pre></td></tr></table></figure><ul><li><code>Marshal()</code> returns JSON representation as []byte</li><li><code>Unmarschal()</code> pointer passed to GO object and object must fit JSON  []byte </li></ul><h2 id="Files-Read-Write"><a href="#Files-Read-Write" class="headerlink" title="Files (Read, Write)"></a>Files (Read, Write)</h2><ul><li>Linear access, not random access</li></ul><p>Open, Read, write close seek(move read/write head)</p><p><code>ioutil File Read</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dat, e := ioutil.ReadFile(<span class="string">"test.txt"</span>)   <span class="comment">// content, error</span></span><br><span class="line"><span class="comment">// Explicit open/close are not needed</span></span><br><span class="line"><span class="comment">// Large files cause a problem (in RAM)</span></span><br><span class="line"></span><br><span class="line">dat = <span class="string">"JoJO"</span></span><br><span class="line">err:= ioutil.WriteFile(<span class="string">"out.txt"</span>, dat, <span class="number">0777</span>)    <span class="comment">// permission</span></span><br></pre></td></tr></table></figure><p><code>os.Open()</code></p><p><code>os.Close()</code></p><p><code>os.Read()</code> reads from a file into byte[]</p><p><code>os.Write()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"dt.txt"</span>)</span><br><span class="line">barr :=<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>) <span class="comment">// read 10 byte</span></span><br><span class="line">nb, err := f.Read(barr)</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">"outfile.txt"</span>)</span><br><span class="line"></span><br><span class="line">barr:=[]<span class="keyword">byte</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">nb,err:=f.Write(barr)   <span class="comment">// write any unicode sequence</span></span><br><span class="line">nb,err:=f.WriteString(<span class="string">"Hi"</span>)</span><br></pre></td></tr></table></figure><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Helllo, world."</span>)    <span class="comment">// main function called automatically</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Abstraction is hiding details that are less important</li></ul><h2 id="Call-by-Reference"><a href="#Call-by-Reference" class="headerlink" title="Call by Reference"></a>Call by Reference</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(y *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    *y = *y + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x:=<span class="number">2</span></span><br><span class="line">    foo(&amp;x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pros: copying time(no need to pass a whole array)<br>cons: data encapsulation</p><h2 id="Passing-Array-Arguments"><a href="#Passing-Array-Arguments" class="headerlink" title="Passing Array Arguments"></a>Passing Array Arguments</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x [3]<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Print(foo(a))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// modify by passing array pointers (messy and unnecessary)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x *[3]<span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    (*x)[<span class="number">0</span>] = (*x)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a:=[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    foo(&amp;a)</span><br><span class="line">    fmt.Print(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using slices in go!!!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(sli [])</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sli[<span class="number">0</span>] = sli[<span class="number">0</span>] +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;   <span class="comment">// no size</span></span><br><span class="line">    foo(a)</span><br><span class="line">    fmt.Print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="First-Class-Values"><a href="#First-Class-Values" class="headerlink" title="First-Class Values"></a>First-Class Values</h2><ul><li>Functions can be treated like other types</li></ul><ul><li>Variables can be declared as a func</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcVar <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">incFn</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    funcVar = incFn</span><br><span class="line">    fmt.Print(funcVar(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Functions as Arguments</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyIt</span><span class="params">(afunct <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">val</span> <span class="title">int</span>) <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> afunct(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Anonymous Functions</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyIt</span><span class="params">(afunct <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">val</span> <span class="title">int</span>) <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> afunct(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v:= applyIt(<span class="function"><span class="keyword">func</span> <span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;<span class="keyword">return</span> x+<span class="number">1</span>&#125;, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Function Defines a Function<br>ex: compute the distance between a point to a origin (variable)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeDistOrigin</span><span class="params">(o_x, o_y <span class="keyword">float64</span>)</span>  // 参数类型</span></span><br><span class="line"><span class="function">                <span class="title">func</span><span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span></span>&#123; <span class="comment">// 返回类型是一个函数</span></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(math.Pow(x-o_x, <span class="number">2</span>) + math.Pow(y-o_y, <span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Dist1 := MakeDistOrigin(<span class="number">0</span>,<span class="number">0</span>)    <span class="comment">// return a function which can compute the distance from given point to (0,0)</span></span><br><span class="line">    Dist2 := MakeDistOrigin(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    fmt.Println(Dist1(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">    fmt.Println(Dist2(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>environment along with a function</li></ul><h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><ul><li>function + its environment</li><li>when functions are passed/ returned, their environment comes with them</li></ul><p>in the previous example<br>o_x, o_y are the environment</p><p>闭包的好处</p><ol><li>希望一个变量长期保存内存中</li><li>避免全局变量污染</li><li>私有成员的存在。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拍卖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeComparePrice</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123; <span class="comment">// 返回类型是一个函数,指定这个函数的参数类型和返回类型</span></span><br><span class="line">    o_price := <span class="number">5.0</span> <span class="comment">// := 是申明新的变量并赋值</span></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">(price <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> o_price &lt; price &#123;</span><br><span class="line">            o_price = price <span class="comment">// =是改变原来的o_price,这里不能使用o_price := price这样就是新的一个o_price</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o_price</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    comparePrice := makeComparePrice()</span><br><span class="line">    fmt.Println(comparePrice(<span class="number">4</span>))    <span class="comment">// 5</span></span><br><span class="line">    fmt.Println(comparePrice(<span class="number">6</span>))    <span class="comment">// 6</span></span><br><span class="line">    fmt.Println(comparePrice(<span class="number">980.424</span>))  <span class="comment">// 980.424</span></span><br><span class="line">    fmt.Println(comparePrice(<span class="number">1.23</span>))     <span class="comment">// 980.424</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Variadic-and-Deferred"><a href="#Variadic-and-Deferred" class="headerlink" title="Variadic and Deferred"></a>Variadic and Deferred</h2><ul><li>variable argument number</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(val ...<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    maxV := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> vals&#123;</span><br><span class="line">        <span class="keyword">if</span> v&gt;maxV&#123;</span><br><span class="line">            maxV = V</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(getMax(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">    vslice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(getMax(vslice...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>defer <code>calling</code> function</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i:=<span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Prinln(i+<span class="number">1</span>)   <span class="comment">// 2</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Classes-and-Encapsulation"><a href="#Classes-and-Encapsulation" class="headerlink" title="Classes and Encapsulation"></a>Classes and Encapsulation</h2><p><code>Encapsulation</code></p><ul><li>data can be protected from the programmer</li><li>data can be accessed by only methods</li></ul><p>Associating Methods with Data</p><ul><li><p>Method has a <code>receiver type</code> that it is associated with</p></li><li><p>Use dot notation to call the method</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mi MyInt)</span> <span class="title">Double</span><span class="params">()</span> <span class="title">int</span></span>&#123;   <span class="comment">// MyInt is the receiver type, this type has a method named Double(), we can call it by dot notation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(mi*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v:=MyInt(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(v.Double())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>use struct<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Point type</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">float64</span></span><br><span class="line">    y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Point类定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">DistToOrig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t := math.Pow(p.x, <span class="number">2</span>) + math.Pow(p.y,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := Point(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    fmt.Println(p1.DistToOrig())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Controlling-Access"><a href="#Controlling-Access" class="headerlink" title="Controlling Access"></a>Controlling Access</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintX</span><span class="params">()</span></span>&#123;fmt.Println(x)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"data"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    data.PrintX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Controlling-Access-to-Structs"><a href="#Controlling-Access-to-Structs" class="headerlink" title="Controlling Access to Structs"></a>Controlling Access to Structs</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">float64</span></span><br><span class="line">    y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">InitMe</span><span class="params">(xn, yn <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">    p.x = xn</span><br><span class="line">    p.y = yn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">Scale</span><span class="params">(v <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">    p.x = p.x* v</span><br><span class="line">    p.y = p.y* v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p data.Point</span><br><span class="line">    p.InitMe(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    p.Scale(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong, just the copy, do not change x coord at all</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    p1.OffsetX(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// large receiver!!</span></span><br><span class="line"><span class="keyword">type</span> Image [<span class="number">100</span>][<span class="number">100</span>] <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i1:= GrabImage()</span><br><span class="line">    il.BlurImage()  <span class="comment">// 10000 ints copied to BlurImage()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Point)</span> <span class="title">Offset</span><span class="params">(v <span class="keyword">float64</span>)</span></span>&#123;</span><br><span class="line">    p.x = p.x + v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h2><ul><li>Ability for an object to have different forms depending on the context</li></ul><p>Overriding<br>Subclass redefines a method inherited from the superclass</p><p>-polumorphic</p><p>Interfaces</p><ul><li>Name, parameters, return values</li><li>Implementation is NOT defined</li></ul><p>Satisfying an Interface<br>implement all the methods(similar to inheritance with overriding)</p><p>additional functions permitted</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape2D <span class="keyword">interface</span>&#123;</span><br><span class="line">    Area() <span class="keyword">float64</span></span><br><span class="line">    Perimeter() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Triangle&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t Triangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;...&#125;    <span class="comment">// match to the func in Shape2D interface automatically</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t Triangle)</span> <span class="title">Perimeter</span> <span class="title">float64</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="Concrete-vs-Interface-Types"><a href="#Concrete-vs-Interface-Types" class="headerlink" title="Concrete vs Interface Types"></a>Concrete vs Interface Types</h2><p>(data &amp; methods) vs (methods)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;Speak()&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;name <span class="keyword">string</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Speaker里的Speak函数，无需指定Speaker名。有一个associated type是实现类型Dog</span></span><br><span class="line"><span class="comment">// x相当于Dog实现了Speaker的Speak函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s1 Speaker</span><br><span class="line">    <span class="keyword">var</span> d1 Dog&#123;<span class="string">"Brian"</span>&#125;</span><br><span class="line"></span><br><span class="line">    s1 = d1</span><br><span class="line">    s1.Speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// var d1 *Dog       //legal, d1 has no concrete value, ca still call the Speak()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d*Dog)</span> <span class="title">Speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"&lt;noise&gt;"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(d.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 Speaker</span><br><span class="line"><span class="keyword">var</span> d1 *Dog</span><br><span class="line">s1 = d1</span><br><span class="line">s1.Speak()</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 任意实现Shape2D的图形都可以用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FitInYard</span><span class="params">(s Shape2D)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.Area()&gt;<span class="number">100</span> &amp;&amp; s.Perimeter()&gt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同图Type不同功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DrawRect</span><span class="params">(r Rectangle)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DrawTriangle</span><span class="params">(t Triangle)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DrawShape</span><span class="params">(s Shape2D)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">// rect, ok:= s.(Rectangle)</span></span><br><span class="line">    <span class="comment">// if ok&#123;</span></span><br><span class="line">    <span class="comment">//     DrawRect(rect)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// tri, ok:= s.(Triangle)</span></span><br><span class="line">    <span class="comment">// if ok&#123;</span></span><br><span class="line">    <span class="comment">//     DrawTriangle(tri)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">switch</span>:=sh:=s.(<span class="keyword">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> Rectangle:</span><br><span class="line">            DrawRect(sh)</span><br><span class="line">        <span class="keyword">case</span> Triangle:</span><br><span class="line">            DrawTriangle(tri)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-Interface"><a href="#Error-Interface" class="headerlink" title="Error Interface"></a>Error Interface</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handling Errors</span></span><br><span class="line">f, err := os.Open(<span class="string">"/harris/test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Why-use-concurrency"><a href="#Why-use-concurrency" class="headerlink" title="Why use concurrency"></a>Why use concurrency</h2><ul><li><p>Parallel Execution<br>Two programs execute in parallel if they execute at exactly the same time. (At time t, an instruction is being performed for both P! and P2) CPU1, CPU2</p></li><li><p>Von Neumann Bottleneck<br>a limitation on throughput on personal computer<br>With the processing becoming faster for processors, the memory transfer rates meet a limitation.</p></li></ul><p>To solve that:<br>Cache, Prefetching, Multithreading, DDR SDRAM</p><p>P = alpha * CFV^2</p><p>alpha is percent of time switching<br>C is capacitance<br>F is the clock frequency<br>V is voltage swing</p><p>Other concurrent tasks can operate while one task is waiting</p><h2 id="Processes-vs-Threads"><a href="#Processes-vs-Threads" class="headerlink" title="Processes vs. Threads"></a>Processes vs. Threads</h2><ul><li>Threads share some context</li><li>Many threads can exist in one process</li></ul><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><ul><li>Like a thread in Go</li><li>Many Goroutines execute within a single OS thread</li></ul><p>switch the go routines like threads</p><h2 id="Interleaving"><a href="#Interleaving" class="headerlink" title="Interleaving"></a>Interleaving</h2><ul><li>Order of execution within a task is unknown</li><li>Order of execution <code>between</code> concurrent tasks is unknown</li><li>Interleaving of instructions between tasks is unknown</li></ul><p><code>Web</code><br>Threads are largely independent but not completely independent (some communication between)<br>Web server, one thread per client</p><p><code>Image processing</code><br>blur the pixels<br>1 thread per pixel block (GPU does)</p><p>some pixel values are shared between the neighbors</p><h2 id="Create-a-Goroutine"><a href="#Create-a-Goroutine" class="headerlink" title="Create a Goroutine"></a>Create a Goroutine</h2><ul><li>One goroutine is created automatically to execute the main()</li><li>Other goroutines are created using the go keyword</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> foo()    <span class="comment">// 使用go关键词, Main goroutine 不会block</span></span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>when the main goroutine end, all other goroutines will exit</p><h2 id="Exit-goroutines"><a href="#Exit-goroutines" class="headerlink" title="Exit goroutines"></a>Exit goroutines</h2><p>Early Exit<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Printf(<span class="string">"New routine"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Main routine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Only “Main routine” is printed because Main finished before the new goroutine started.</li></ul><h2 id="Delayed-Exit"><a href="#Delayed-Exit" class="headerlink" title="Delayed Exit"></a>Delayed Exit</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Printf(<span class="string">"New routine"</span>)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)  <span class="comment">// Adding a delay to wait is bad because assumptions may be wrong</span></span><br><span class="line">    fmt.Printf(<span class="string">"Main routine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h2><ul><li><p>Using global events whose execution is viewed by all threads, simultaneously</p></li><li><p>GLOBAL EVENT is viewed by all tasks at the same time</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">x = x+<span class="number">1</span></span><br><span class="line">GLOBAL EVENT</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> GLOBAL EVENT <span class="comment">// x has been updated</span></span><br><span class="line">    <span class="built_in">print</span> x</span><br></pre></td></tr></table></figure><p>Wait groups</p><ul><li>Sync package contains functions to synchronize between goroutines</li><li><code>sync.WaitGroup</code> forces a goroutine to wait for other goroutines</li><li>contains an internal counter</li></ul><ul><li>increment counter for each goroutine to wait for</li><li>decrement counter when each goroutine completes</li><li>Waiting goroutine cannot continue until counter is 0</li></ul><p>Using waitgroup</p><p>Add() increments the counter<br>Done() decrements the counter<br>Wait() blocks until counter == 0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> foo(&amp;wg)</span><br><span class="line">wg.Wait() <span class="comment">// wait on one thread</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在foo里</span></span><br><span class="line">wg.Done()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(wg *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"New routine"</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> foo (&amp;wg)    <span class="comment">// 传递引用，免得copy一大堆过去</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">"Main routine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><ul><li>Transfer data between goroutines</li><li>Channels are typed</li><li>Use make() to create a channel<br>c:=make(chan int)</li><li>send and receive data usign the &lt;-</li><li>Send data on a channel<br>c&lt;-3</li><li>receive data from a channel<br>x := &lt;- c</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prod</span><span class="params">(v1 <span class="keyword">int</span>, v2 <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    c &lt;- v1 * v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> prod(<span class="number">1</span>, <span class="number">2</span>, c)</span><br><span class="line">    <span class="keyword">go</span> prod(<span class="number">3</span>, <span class="number">4</span>, c)    <span class="comment">// In the same channel c</span></span><br><span class="line">    a:= &lt;-c</span><br><span class="line">    b:=&lt;-c</span><br><span class="line">    fmt.Println(a*b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。</li><li>而 buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong></li></ul><p>Unbuffered Channel cannot hold datta in transit<br>Sendind blocks until data is received<br>Receiving blocks until data is sent</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">3</span>  <span class="comment">// no buffer, has to wait for task 2 to receive</span></span><br><span class="line"></span><br><span class="line">One hour later</span><br><span class="line"></span><br><span class="line">Task <span class="number">2</span></span><br><span class="line">x := &lt;- c  <span class="comment">// wait task 1 to send</span></span><br></pre></td></tr></table></figure><p>So a <code>Wait()</code> should be here</p><h2 id="Channel-Capacity"><a href="#Channel-Capacity" class="headerlink" title="Channel Capacity"></a>Channel Capacity</h2><ul><li>channels can obtain a limited number of objects</li><li>Capacity is the number of objects it can hold in transit</li></ul><p>c:=make(chan int, 3)</p><ul><li>Sending only blocks if buffer is full</li><li>receiving only blocks if buffer is empty </li></ul><p>生产者线程-&gt;有限的缓冲区-&gt;消费者线程</p><ul><li>在缓冲区为空时，消费者不能再消费</li><li>缓冲区满时，生产者不能再进行生产</li></ul><h2 id="Iterate-through-a-channel"><a href="#Iterate-through-a-channel" class="headerlink" title="Iterate through a channel"></a>Iterate through a channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="keyword">range</span> c&#123;    <span class="comment">// i is the read value</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>iterates when sender calls close(c)</li></ul><h2 id="Receiving-from-Multiple-Goroutines"><a href="#Receiving-from-Multiple-Goroutines" class="headerlink" title="Receiving from Multiple Goroutines"></a>Receiving from Multiple Goroutines</h2><ul><li>Multiple channels may be used to receive from multiple sources</li></ul><h2 id="Select-Statement"><a href="#Select-Statement" class="headerlink" title="Select Statement"></a>Select Statement</h2><ul><li><p>May have a choice of which data to use<br>-First come First served</p></li><li><p>use the select statement to wait on the first data from a set of channels</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只选第一个</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a = &lt;- c1:</span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    <span class="keyword">case</span> b = &lt;- c2:</span><br><span class="line">        fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a = &lt;- inchan:</span><br><span class="line">        fmt.Println(<span class="string">"Received a"</span>)</span><br><span class="line">    <span class="keyword">case</span> b = &lt;- outchan:</span><br><span class="line">        fmt.Println(<span class="string">"Send b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Select with an Abort Channel</p><p>Producer-consumer<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;    <span class="comment">//infinite for loop keep receiving</span></span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> a &lt;- c:</span><br><span class="line">            fmt.Println(a)  <span class="comment">// keep receivinf and processing</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-abort:       <span class="comment">// abort channel maybe enter quit, 如果有东西到abort channel上了，就会return</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a=&lt;-c1:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">case</span> b=&lt;-c2:</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">default</span>:    <span class="comment">// default case do not block</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutual-Exclusion"><a href="#Mutual-Exclusion" class="headerlink" title="Mutual Exclusion"></a>Mutual Exclusion</h2><p>Two goroutines write to a shared variable can interfere with each other.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not corrent!!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)   <span class="comment">// create 2 goroutines</span></span><br><span class="line">    <span class="keyword">go</span> inc()</span><br><span class="line">    <span class="keyword">go</span> inc()</span><br><span class="line">    wg.Wait()   <span class="comment">// wait for the two routines</span></span><br><span class="line">    fmt.Println(i)  <span class="comment">// i should equal 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seems no problem and i should equal 2??</p><p><strong>Granularity of Concurrency</strong><br>i = i+1 might be three machine instructions<br>read i<br>increment<br>write i</p><p>Interleaving machine instructions<br>|Task 1|Task2|i|<br>|—|—|—|<br>|read i||0|<br>||read i|0|<br>|inc||1|<br>|write i||1|<br>||inc|1|<br>||write i|1|</p><p>Correct Sharing</p><ul><li>Don’t let 2 goroutines write to a shared variable at the same time</li><li>Mutual Exclusion</li></ul><p>Sync.Mutex</p><ul><li>A Mutex ensures mutual exclusion</li><li>uses a binary semaphore</li><li>Flag up - shared variable is in use</li><li><p>Flag down - shared variable is available</p></li><li><p><code>Lock()</code> method puts the flag up - shared variale i use</p></li><li><code>Unlock()</code> method puts the flag down<br>When Unlock() is called, a Lock() can be proceed</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mut.Lock()</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    mut.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronous-Initialization"><a href="#Synchronous-Initialization" class="headerlink" title="Synchronous Initialization"></a>Synchronous Initialization</h2><p>Initialization must happen once and before everything else<br>Sync.Once</p><ul><li>Has one method, <code>once.Do(f)</code></li><li>Function f is executed only one time even if it is ccalled in multiple gotoutines</li><li>All calls to once.Do() block until the first returns</li></ul><ul><li>Ensures that init executes first</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> dostuff()</span><br><span class="line">    <span class="keyword">go</span> dostuff()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> on sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Pringln(<span class="string">"Init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dostuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">    on.Do(setup)</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line"><span class="comment">// Init</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h2 id="Deadlock-example"><a href="#Deadlock-example" class="headerlink" title="Deadlock example"></a>Deadlock example</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dostuff</span><span class="params">(c1 <span class="keyword">chan</span> <span class="keyword">int</span>, c2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    &lt;- c1</span><br><span class="line">    c2 &lt;- <span class="number">1</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> dostuff(ch1, ch2)</span><br><span class="line">    <span class="keyword">go</span> dostuff(ch2, ch1)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang detects when all goroutine are deadlocks, but cannot detect subset of goroutines are deadlocks</p><h2 id="Dining-Philosophers-Problem"><a href="#Dining-Philosophers-Problem" class="headerlink" title="Dining Philosophers Problem"></a>Dining Philosophers Problem</h2><p>Each chopstick is a mutex<br>Each philosopher is associated with a goroutine and two chopsticks</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChopS <span class="keyword">struct</span>&#123; sync.Mutex&#125;</span><br><span class="line"><span class="keyword">type</span> Philo <span class="keyword">struct</span>&#123;</span><br><span class="line">    leftCS, rightCS *ChopS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Philo)</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="comment">// All people will lock the chopstick on their left side firstly</span></span><br><span class="line">        p.leftCS.Lock()</span><br><span class="line">        p.rightCS.Lock()</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"eating"</span>)</span><br><span class="line"></span><br><span class="line">        p.rightCS.UnLock()</span><br><span class="line">        p.leftCS.UnLock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line">CSticks := <span class="built_in">make</span>([]*ChopS, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++&#123;</span><br><span class="line">    CStick[i] = <span class="built_in">new</span>(ChopS)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">philos := <span class="built_in">make</span>([]*Philo, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++&#123;</span><br><span class="line">    philos[i] = &amp;Philo&#123;CSticks[i], CSticks[(i+<span class="number">1</span>)%<span class="number">5</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start eating</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++&#123;</span><br><span class="line">    <span class="keyword">go</span> philos[i].eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个人拿最小的<br>Solution<br>change to &amp;Philo{CSticks[min(i, (i+1)%5)], CSticks[max(i, (i+1)%5)]}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Internet programming</title>
      <link href="/blog/2019/10/14/Internet-programming/"/>
      <url>/blog/2019/10/14/Internet-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="Internet-programming-笔记"><a href="#Internet-programming-笔记" class="headerlink" title="Internet programming 笔记"></a>Internet programming 笔记</h1><a id="more"></a><h2 id="note1"><a href="#note1" class="headerlink" title="note1"></a>note1</h2><p><code>http</code>: hypertext transfer protocol, the underlying protocol used by the WWW and this protocol defines how messages are formatted and transmitted,</p><p>and what actions Web servers and browsers should take in response to various commands.</p><p><code>https</code>: http over secure</p><p><code>session</code>: a temporary and interactive information interchange between two or more communicating devices or between computer and user.</p><p><code>Internet</code> vs <code>WWW</code> : Internet is a global network comprised of computers( conceptualized during 1969, APRA), World Wide Web is a collection of web pages following Http that can be accessed via the Internet from any part of the world.</p><p><code>Cookie</code>: a small piece of data sent from a website and stored on the user’s computer by the user’s web browser. It can record user’s browsing activity and remember stateful information and arbitrary information that user entered into form fields.</p><p><code>JSP</code>: JSP stands for Java Server Pages, which helps developers to create dynamically web pages based on HTML, XML, or other types.</p><p><code>Servlets</code>: are Java programs that are already compiled which also creates dynamic web content.</p><p><code>HTML</code>: HyperText Markup Language, the authoring language used to create documents on the World Wide Web</p><p><code>javascript</code>: make web pages dynamic and interactive by implementing client-side scripts.</p><p><code>css</code>: Cascading Style Sheets is a language that describes the style of an HTML document.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Screen Design</title>
      <link href="/blog/2019/05/22/ScreenDesign/"/>
      <url>/blog/2019/05/22/ScreenDesign/</url>
      
        <content type="html"><![CDATA[<h1 id="A-brief-introduction-of-Screen-Design"><a href="#A-brief-introduction-of-Screen-Design" class="headerlink" title="A brief introduction of Screen Design"></a>A brief introduction of Screen Design</h1><blockquote><p>Design, 50% instinct, 50% hard work.</p></blockquote><a id="more"></a><h2 id="Gestalt-pyschology"><a href="#Gestalt-pyschology" class="headerlink" title="Gestalt pyschology"></a>Gestalt pyschology</h2><blockquote><p>The whole(unity) is greater than the sum of its parts.(Aristotle)</p></blockquote><p><br><br><div class="row">    <embed src="Handout01-GestaltPsychology.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Composition-Symmetry-and-Balance"><a href="#Composition-Symmetry-and-Balance" class="headerlink" title="Composition, Symmetry and Balance"></a>Composition, Symmetry and Balance</h2><blockquote><p>Pictures need a frame for their composition. Youe must know where is the end of the picture and where begins reality.</p></blockquote><ul><li><code>Composition with perspective</code></li><li>not in the middle</li><li>Symmetry in the composition and in the meaning</li><li>Golden section</li></ul><p><br><br><div class="row">    <embed src="Handout03_Composition.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><blockquote><p>color palettes</p></blockquote><p><br><br><div class="row">    <embed src="Handout04_Color.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p><br><br><div class="row">    <embed src="Handout05_Grid.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h2><ul><li>from <code>tangram</code> 七巧板 to logotype</li><li><code>pictogram</code> 象形符号</li></ul><p><br><br><div class="row">    <embed src="06_Logo.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h2><ul><li>Leading</li><li>captical letter</li><li>typographie</li></ul><p><br><br><div class="row">    <embed src="Handout07_Typography.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="Design-Thinking"><a href="#Design-Thinking" class="headerlink" title="Design Thinking"></a>Design Thinking</h2><p><br><br><div class="row">    <embed src="08_DesignThinking.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>DSP_SwarmIntelligence</title>
      <link href="/blog/2019/05/21/DSP-SwarmIntelligence/"/>
      <url>/blog/2019/05/21/DSP-SwarmIntelligence/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Swarm intelligence (SI) is the collective behavior of decentralized, self-organized systems, natural or artificial. The concept is employed in work on artificial intelligence. The expression was introduced by Gerardo Beni and Jing Wang in 1989, in the context of cellular robotic systems</p></blockquote><a id="more"></a><blockquote><p>How can we implement the coordination among the groups?</p></blockquote><p>flask-&gt;waterholr-&gt;on and another</p><p>predator-&gt;flask split-&gt; </p><ol start="2"><li>knowledge accumulated to concesus</li></ol><p>penguin<br>-40 together to brook the temperature<br>huddle tiny streps away<br>shift and rotate fro, back to front<br>not let the </p><p>overheat-&gt;breakdown</p><p>step by step huddle after huddle</p><p>mayfly</p><p>flock of fish collide with predator </p><blockquote><p>pheromone 信息素</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java网络编程</title>
      <link href="/blog/2019/05/18/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/blog/2019/05/18/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java网络编程"><a href="#java网络编程" class="headerlink" title="java网络编程"></a>java网络编程</h1><a id="more"></a><h2 id="任务一-TCP实现逆序字符串输出"><a href="#任务一-TCP实现逆序字符串输出" class="headerlink" title="任务一 TCP实现逆序字符串输出"></a>任务一 TCP实现逆序字符串输出</h2><blockquote><p>客户端想要发一行字符行给服务器端然后得到一个逆序的字符行。</p></blockquote><h3 id="SocketClient-java"><a href="#SocketClient-java" class="headerlink" title="SocketClient.java"></a>SocketClient.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">54321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get input stream</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get output stream</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// write string into server</span></span><br><span class="line">ps.println(sc.nextLine());</span><br><span class="line"></span><br><span class="line"><span class="comment">// print the reversed string from server</span></span><br><span class="line">System.out.println(br.readLine());</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SocketServer-java"><a href="#SocketServer-java" class="headerlink" title="SocketServer.java"></a>SocketServer.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">54321</span>);</span><br><span class="line">System.out.println(<span class="string">"Server is on, binded to 54321 port"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// get the input stream</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">String line = br.readLine();</span><br><span class="line">line = <span class="keyword">new</span> StringBuilder(line).reverse().toString();</span><br><span class="line">ps.println(line);</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>建立Socket连接</p><p> 客户端Socket指定host和port，服务器Socket使用给定的ServerSocket绑定port即可再调用accept函数，当客户端运行时，会找到指定的host:port，建立和服务器的连接</p></li><li><p>通信</p><p>服务器的输入流就是客户端的输出流，反之亦然。<br>在服务器和客户端都写一个BufferedReader（简称br）用来输入，和一个PrintStream（简称ps）用来输出。我客户端要发一个字符串，就用ps.println输出；服务器要接收就用br.readLine接收（接收就是输入流）；然后我服务器逆序一下字符串用ps输出，客户端用br再接收就是逆序的字符串了。</p></li></ol><table><thead><tr><th style="text-align:center">客户端</th><th style="text-align:center"></th><th style="text-align:center">服务器</th></tr></thead><tbody><tr><td style="text-align:center">ps输出</td><td style="text-align:center">-&gt;</td><td style="text-align:center">br接收</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">reverse字符串</td></tr><tr><td style="text-align:center">br接收</td><td style="text-align:center">&lt;-</td><td style="text-align:center">ps输出</td></tr></tbody></table><ul><li>有一个误区就是ps的println不是系统的输出，而是把这一行放到服务器和客户端的交流通道里，客户端println输出，服务器就可以用输入的方式读取了，反之亦然</li></ul><hr><h2 id="任务二-UDP实现简单计算通信"><a href="#任务二-UDP实现简单计算通信" class="headerlink" title="任务二 UDP实现简单计算通信"></a>任务二 UDP实现简单计算通信</h2><blockquote><p>使用UDP完成简单计算，比如客户端输入3*4，服务端输出12；客户端输入9/3，服务端输出3</p></blockquote><h3 id="UDPclient-java"><a href="#UDPclient-java" class="headerlink" title="UDPclient.java"></a>UDPclient.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPclient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">String pattern = <span class="string">"(\\d*)([\\+\\-\\*\\/])(\\d*)"</span>;</span><br><span class="line">Pattern r = Pattern.compile(pattern);</span><br><span class="line">Matcher m = r.matcher(s);</span><br><span class="line"><span class="keyword">int</span> consequence = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m.find())&#123;   <span class="comment">// necessary!</span></span><br><span class="line"><span class="keyword">int</span> leftInt = Integer.parseInt(m.group(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">char</span> operator = m.group(<span class="number">2</span>).charAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> rightInt = Integer.parseInt(m.group(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(operator) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            consequence = leftInt + rightInt;</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">// important!</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">consequence = leftInt - rightInt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">consequence = leftInt * rightInt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">consequence = leftInt / rightInt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consequence;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//            byte[] bytes = sc.nextLine().getBytes();</span></span><br><span class="line">    String test =sc.nextLine();</span><br><span class="line">    <span class="keyword">int</span> result1 = compute(test);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) result1);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = (<span class="string">""</span>+result1).getBytes();</span><br><span class="line">    </span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line">        packet.setAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>));</span><br><span class="line">        packet.setPort(<span class="number">55555</span>);</span><br><span class="line">        socket.send(packet);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDPserver-java"><a href="#UDPserver-java" class="headerlink" title="UDPserver.java"></a>UDPserver.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">55555</span>);</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, data.length));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在客户端计算了result，因为UDP传递的是数据包，我们把然后把这个result存放在byte数组中，再放到数据包中，用客户端socket的send发送，就可以用服务器端socket的receive接收了。可以看出，我server不用开，client也能发送，就是永远送不到server了，这就是丢包的原理。TCP则是要先建立连接，就保证了数据是能送到位的。其它UDP和TCP的区别：</p><p>1、基于连接与无连接；</p><p>2、对系统资源的要求（TCP较多，UDP少）；</p><p>3、UDP程序结构较简单；</p><p>4、流模式与数据报模式 ；</p><p>5、TCP保证数据正确性，UDP可能丢包；</p><p>6、TCP保证数据顺序，UDP不保证。</p><p><a href="https://zhuanlan.zhihu.com/p/24860273" target="_blank" rel="noopener">参考来源</a></p><hr><h2 id="任务三-多线程实现多客户端通信"><a href="#任务三-多线程实现多客户端通信" class="headerlink" title="任务三 多线程实现多客户端通信"></a>任务三 多线程实现多客户端通信</h2><blockquote><p>建立25个线程，把它建立连接的时间戳、发送信息的时间戳和2秒后断开的时间戳信息，发给服务器显示。</p></blockquote><h3 id="Server-java"><a href="#Server-java" class="headerlink" title="Server.java"></a>Server.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ServerSocket serve = <span class="keyword">new</span> ServerSocket(<span class="number">54322</span>);</span><br><span class="line">System.out.println(<span class="string">"Server is on and binded to 54322 port"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Socket socket = serve.accept();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">System.out.println(br.readLine()); <span class="comment">// receive the timestamp info of</span></span><br><span class="line"><span class="comment">// connection and sending infomation</span></span><br><span class="line"></span><br><span class="line">System.out.println(br.readLine()); <span class="comment">// receive the timestamp info of</span></span><br><span class="line"><span class="comment">// disconnection</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutipleClients-java"><a href="#MutipleClients-java" class="headerlink" title="MutipleClients.java"></a>MutipleClients.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutipleClients</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">54322</span>);</span><br><span class="line">String Stamp1 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString();</span><br><span class="line"></span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">String Stamp2 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString();</span><br><span class="line"></span><br><span class="line">ps.println(<span class="string">"Client "</span> + t.getId() + <span class="string">" connected at "</span> + Stamp1 + <span class="string">" and sent timestamp "</span> + Stamp2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String Stamp3 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString();</span><br><span class="line">ps.println(<span class="string">"Client "</span> + t.getId() + <span class="string">" disconnected at "</span> + Stamp3);</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个服务器与25个客户端进行连接，需要用while(True)使之一直处于accept状态。</p></blockquote><blockquote><p>服务器要接收两行信息，第一行客户端发来(println)的连接与发送信息时间戳，第二行是过一段时间客户端发来的结束时间戳。</p></blockquote><hr><h2 id="任务四-RMI实现远程方法调用"><a href="#任务四-RMI实现远程方法调用" class="headerlink" title="任务四 RMI实现远程方法调用"></a>任务四 RMI实现远程方法调用</h2><blockquote><p>前面我们看到的都是在客户端处理好数据送给服务器，让服务器进行输出。那有什么办法在服务器上定义一些接口，然后在本地调用呢？</p></blockquote><p>这就是RMI(remote method invocation)。本地调用方法时实质上是传给服务器该方法的引用，让服务器调用该方法，然后return给本地结果。本地有stub，是远程对象在本地的代理(proxy),类似于RPC系统中的clinet stub。</p><blockquote><p>RMI的实现首先要发现远程对象，那就必须要开启注册表(RTegistry)，什么是注册表？</p></blockquote><p>拿DNS来类比最为方便，DNS相当于一种注册表。它建立了IP地址和域名的对应，IP就是对远程对象的引用，域名就是远程对象的标识符。格式类似于 <code>rmi://host:port/name</code>。<code>host</code>指明注册表运行的注解，<code>port</code>表明接收调用的端口，<code>name</code>是一个标识该对象的简单名称。<br>下面代码用LocateRegistry.createRegistry方法确定了注册表。再进行bind或rebind操作就可以连接了。</p><h3 id="远程接口"><a href="#远程接口" class="headerlink" title="远程接口"></a>远程接口</h3><blockquote><p>IHello.java </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define remote interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helloWorld</span><span class="params">()</span><span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><blockquote><p>Hello.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the implementation class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line"><span class="keyword">return</span> ++index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><blockquote><p>HelloServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">IHello rhello = <span class="keyword">new</span> Hello();</span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">8888</span>);</span><br><span class="line">registry.bind(<span class="string">"test"</span>,rhello);  <span class="comment">// in client side rmi://localhost:8888/test</span></span><br><span class="line">System.out.println(<span class="string">"Remote Hello Object is bound succesfully!"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p>HelloClient.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">IHello rhello = (IHello) Naming.lookup(<span class="string">"rmi://192.168.31.102:8888/test"</span>);</span><br><span class="line">System.out.println(rhello.helloWorld());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SWEII_TEST</title>
      <link href="/blog/2019/05/17/SWEII-TEST/"/>
      <url>/blog/2019/05/17/SWEII-TEST/</url>
      
        <content type="html"><![CDATA[<h3 id="4-types-of-coverage-in-testing"><a href="#4-types-of-coverage-in-testing" class="headerlink" title="4 types of coverage in testing"></a>4 types of coverage in testing</h3><a id="more"></a><p><img src="/blog/blog/2019/05/17/SWEII-TEST/1.jpg" alt="1"></p><hr><p><img src="/blog/blog/2019/05/17/SWEII-TEST/2.jpg" alt="2"></p><p>branch coverage&gt;statement coverage because it can examine empty else statement</p><hr><p><img src="/blog/blog/2019/05/17/SWEII-TEST/3.jpg" alt="3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DSP_ConsistentModel_Ex</title>
      <link href="/blog/2019/05/17/DSP_ConsistenctModel/"/>
      <url>/blog/2019/05/17/DSP_ConsistenctModel/</url>
      
        <content type="html"><![CDATA[<h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><a id="more"></a><h1 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">VC</th><th style="text-align:center">LA</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">(1,0,0,0)</td><td style="text-align:center">1.1</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">(2,1,0,0)</td><td style="text-align:center">2.1</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">(3,1,0,0)</td><td style="text-align:center">3.1</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">(4,3,2,0)</td><td style="text-align:center">6.1</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">(5,5,2,2)</td><td style="text-align:center">7.1</td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">(6,5,4,2)</td><td style="text-align:center">8.1</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">(7,5,4,2)</td><td style="text-align:center">9.1</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">(0,1,0,0)</td><td style="text-align:center">1.2</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">(1,2,1,0)</td><td style="text-align:center">3.2</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">(1,3,1,0)</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">(1,4,1,2)</td><td style="text-align:center">5.2</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">(1,5,1,2)</td><td style="text-align:center">6.2</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">(4,6,2,4)</td><td style="text-align:center">9.2</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">(7,7,4,4)</td><td style="text-align:center">10.2</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">(1,0,1,0)</td><td style="text-align:center">2.3</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">(1,3,2,0)</td><td style="text-align:center">5.3</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">(3,3,3,0)</td><td style="text-align:center">6.3</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">(3,3,4,0)</td><td style="text-align:center">7.3</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">(1,0,0,1)</td><td style="text-align:center">2.4</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">(1,0,0,2)</td><td style="text-align:center">3.4</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">(4,3,2,3)</td><td style="text-align:center">7.4</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">(4,3,2,4)</td><td style="text-align:center">8.4</td></tr></tbody></table><blockquote><p>Total/Partial order</p></blockquote><ul><li>add process num the timestamp belongs</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Equicalence Partitioning Class</title>
      <link href="/blog/2019/05/02/EC/"/>
      <url>/blog/2019/05/02/EC/</url>
      
        <content type="html"><![CDATA[<p>在软件工程中，常常遇到测试数据不完全而不能有效地测试出bug的过程，这个时候需要对所有输出进行划分，同时在边界需要格外注意，多测试几组边界值。</p><ul><li>empty digits</li><li>characters</li></ul><ul><li>六位id的可写成 id = {num|num = (\d){6,6}}</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ds5</title>
      <link href="/blog/2019/04/26/ds5/"/>
      <url>/blog/2019/04/26/ds5/</url>
      
        <content type="html"><![CDATA[<h1 id="4-26笔记"><a href="#4-26笔记" class="headerlink" title="4-26笔记"></a>4-26笔记</h1><a id="more"></a><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><blockquote><p>fat client</p><ul><li>microsoft excel</li></ul></blockquote><blockquote><p>thin client</p><ul><li>automatioc flight check-in machine </li></ul></blockquote><h2 id="18"><a href="#18" class="headerlink" title="18"></a>18</h2><p>which is on client and which on server</p><h2 id="27"><a href="#27" class="headerlink" title="27"></a>27</h2><p>localhost：在计算机网络中，localhost（意为“本地主机”，指“这台计算机”）是给回路网络接口（loopback）的一个标准主机名，相对应的IP地址为127.0.0.1（IPv4）和[::1]（IPv6）。<br>127.0.0.1是回送地址，指本地机。<br>127.0.0.1是用来检测网络的自己的IP.就是说任何一台电脑来说,不管是否连接到INTERNET上,127.0.0.1对于自己来说都是自己.就是说,每台电脑都是由4位的256进制数组成的.<br>而192.168.1.102现在是本机，但本机也可以设置成其他ip地址，但127.0.0.1一定是指本机。</p><h2 id="JAVA-client-server-简单例子"><a href="#JAVA-client-server-简单例子" class="headerlink" title="JAVA client-server 简单例子"></a>JAVA client-server 简单例子</h2><h3 id="Socketclient-java"><a href="#Socketclient-java" class="headerlink" title="Socketclient.java"></a>Socketclient.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">54321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get input stream</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get output stream</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// write string into server</span></span><br><span class="line">ps.println(sc.nextLine());</span><br><span class="line"></span><br><span class="line"><span class="comment">// print the reversed string from server</span></span><br><span class="line">System.out.println(br.readLine());</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h3 id="SocketServer-java"><a href="#SocketServer-java" class="headerlink" title="SocketServer.java"></a>SocketServer.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">54321</span>);</span><br><span class="line">System.out.println(<span class="string">"Server is on, binded to 54321 port"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// get the input stream</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">String line = br.readLine();</span><br><span class="line">line = <span class="keyword">new</span> StringBuilder(line).reverse().toString();</span><br><span class="line">ps.println(line);</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础</title>
      <link href="/blog/2019/04/22/java%E5%9F%BA%E7%A1%80/"/>
      <url>/blog/2019/04/22/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-入门到放弃"><a href="#JAVA-入门到放弃" class="headerlink" title="JAVA 入门到放弃"></a>JAVA 入门到放弃</h1><a id="more"></a><h2 id="Access-modifiers-specifiers-in-java"><a href="#Access-modifiers-specifiers-in-java" class="headerlink" title="Access modifiers(specifiers) in java"></a>Access modifiers(specifiers) in java</h2><hr><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><ul><li>基类的 protected 成员是包内可见的，并且对子类可见；</li><li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</li></ul><p><a href="https://blog.csdn.net/justloveyou_/article/details/61672133" target="_blank" rel="noopener">detail</a></p><hr><h3 id="overload"><a href="#overload" class="headerlink" title="overload"></a>overload</h3><p>each overloaded method must take a unique list of the argument types</p><hr><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>（1）重写方法必须和被重写方法具有相同的参数列表（包括顺序及个数还有类型），返回类型必须和被重写方法的返回类型相同或者是返回类型的子类型。</p><p>（2）重写方法的访问控制修饰符不能比被重写方法更严格（比如一个在父类中声明为public的方法重写成一个protected的方法）。</p><p>（3）只有实例方法才能被重写，超类中的static和final方法不能被重写。</p><p>（4）重写方法不能抛出新的检查异常，或者是抛出比被重写方法声明的检查异常更广泛的检查异常。</p><p>（5）注意一种特殊情况：如果超类的方法版本中声明了检查异常，但重写的子类方法中没有声明，这时如果使用多态的方式进行调用，那么编译器认为你调用的是声明了异常的方法。</p><p>（6）尽管多态是在编译时确定对象的类型，但在编译时，还是根据父类的方法声明进行程序检查。因此，如果子类中定义的方法，在父类中没有定义，则会出项编译错误。</p><hr><h3 id="upcast"><a href="#upcast" class="headerlink" title="upcast"></a>upcast</h3><p>the act of converting a subclass reference into a baseclass reference</p><p>缺点：使用向上转型时不能调用子类特有的方法了</p><p>优点：一个父类有多个子类时，一个子类重写了许多父类的方法，可以声明一个public static函数统一对<br>每个属于父类的子类进行操作，节省代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spycsh</span></span><br><span class="line"><span class="comment"> * 2019-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String carDescription = <span class="string">"Car"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类speed方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> carDescription;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Benz:run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Benz:speed方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BMW:run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BMW:speed方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Porsche</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String carDescription = <span class="string">"Porsche is the best!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Porche:run方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Porche:speed方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Porche:price方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> carDescription;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpcastEX</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> car</span></span><br><span class="line"><span class="comment"> *  !upcast</span></span><br><span class="line"><span class="comment"> *  without upcast you need to define show method for each car brand</span></span><br><span class="line"><span class="comment"> *  save code amount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">car.run();</span><br><span class="line">car.speed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAll</span><span class="params">(Car[] e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Car i:e) &#123;</span><br><span class="line">show(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Car[] carFleet = &#123;</span><br><span class="line"><span class="keyword">new</span> Benz(),</span><br><span class="line"><span class="keyword">new</span> BMW(),</span><br><span class="line"><span class="keyword">new</span> Porsche()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showAll(carFleet);</span><br><span class="line"></span><br><span class="line">Car porsche911 = <span class="keyword">new</span> Porsche();</span><br><span class="line"><span class="comment">//porsche911.price();  // ERROR</span></span><br><span class="line"><span class="comment">// !cannot be implemented because of upcasting!</span></span><br><span class="line"><span class="comment">// baseclass don`t define price()!</span></span><br><span class="line">        </span><br><span class="line">                System.out.println(<span class="string">"test getDescription:"</span>);</span><br><span class="line"><span class="comment">// show that although upcasting, field are accessed</span></span><br><span class="line"><span class="comment">// in subclass, not baseclass.</span></span><br><span class="line">System.out.println(porsche911.getDescription());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OUTPUT</p></blockquote><p>Benz:run方法</p><p>Benz:speed方法</p><p>BMW:run方法</p><p>BMW:speed方法</p><p>Porche:run方法</p><p>Porche:speed方法</p><p>test getDescription:</p><p>Porsche is the best!</p><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static修饰方法 静态方法 属于类的方法 即访问它不需要实例对象就能访问</p><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="static-final修饰data"><a href="#static-final修饰data" class="headerlink" title="static, final修饰data"></a>static, final修饰data</h4><blockquote><p>static 强调只有一份，final 说明是一个常量，final定义的基本类型(primitive)的值是不可改变的，但是fianl定义的引用对象的值是可以改变的</p></blockquote><p>只申明final，每次new产生不同的对象<br>static, final一起使用时，只有一块存储地址<br>申明static final，每次new产生相同对象</p><h4 id="final修饰methods"><a href="#final修饰methods" class="headerlink" title="final修饰methods"></a>final修饰methods</h4><blockquote><p>把方法锁定，确保在继承中使用方法行为不变，并且不会被覆盖<br>其二是效率，如果一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。 转为内嵌调用的目的是节省开销，因为编译器发现一个final方法调用命令时，会跳过程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来替代方法调用。但是如果一个方法很大，程序很膨胀，就会看不到内嵌带来的任何性能的提高。</p></blockquote><h4 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h4><blockquote><p>当某个类的整体定义为final时，表明该类不能被继承，方法不能被覆盖，且final类中的所有方法都隐式指定为是final的，方法声明为final后还可以有效地“关闭”动态绑定。</p></blockquote><hr><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><!-- ![0](补天/collections.png) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/%E8%A1%A5%E5%A4%A9/collections.png?raw=true"></p><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><!-- ![1](补天/synchronize.png) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/%E8%A1%A5%E5%A4%A9/synchronize.png?raw=true"></p><h3 id="修饰代码块，其他试图访问该对象的线程阻塞"><a href="#修饰代码块，其他试图访问该对象的线程阻塞" class="headerlink" title="修饰代码块，其他试图访问该对象的线程阻塞"></a>修饰代码块，其他试图访问该对象的线程阻塞</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象作为锁"><a href="#对象作为锁" class="headerlink" title="对象作为锁"></a>对象作为锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有明确的对象作为锁"><a href="#没有明确的对象作为锁" class="headerlink" title="没有明确的对象作为锁"></a>没有明确的对象作为锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">         <span class="comment">// todo 同步代码块</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">参考资料</a></p><p><a href="https://www.cnblogs.com/moongeek/p/7631447.html" target="_blank" rel="noopener">消费者-生产者例子</a></p><hr><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类  </span></span><br><span class="line">btn.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;  </span><br><span class="line">          <span class="meta">@Override</span>  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;  </span><br><span class="line">              System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 或者使用 lambda expression  </span></span><br><span class="line">btn.setOnAction(event -&gt; System.out.println(<span class="string">"Hello World!"</span>));</span><br></pre></td></tr></table></figure><h3 id="排序，线程，集合用法"><a href="#排序，线程，集合用法" class="headerlink" title="排序，线程，集合用法"></a>排序，线程，集合用法</h3><p><a href="https://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="noopener">参考资料</a></p><hr><h3 id="LinkedList-和-ArrayList-区别"><a href="#LinkedList-和-ArrayList-区别" class="headerlink" title="LinkedList 和 ArrayList 区别"></a>LinkedList 和 ArrayList 区别</h3><p>LinkedList插入元素（任意位置只要断开链接再与新元素链接即可）很快，但访问中间元素需要从头或从尾开始遍历，很慢。<br>ArrayList插入元素很慢，它需要更新一遍数组，但访问元素只需要给出索引，相对较快。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ds4</title>
      <link href="/blog/2019/04/12/ds4/"/>
      <url>/blog/2019/04/12/ds4/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-04-12-笔记"><a href="#2019-04-12-笔记" class="headerlink" title="2019-04-12 笔记"></a>2019-04-12 笔记</h1><a id="more"></a><p><br><br><div class="row">    <embed src="DistSys4.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h1 id="File-IO-operation"><a href="#File-IO-operation" class="headerlink" title="File IO operation"></a>File IO operation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spycsh ●int countLines(): count line amount of file ●void print():</span></span><br><span class="line"><span class="comment"> *         print file on command line ●void copy(String filename): copy file</span></span><br><span class="line"><span class="comment"> *         content to the file ‘filename’ ●void delete(): delete the file ●void</span></span><br><span class="line"><span class="comment"> *         printDirectory(): prints the file directory ●List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> *         getOtherFiles(): returns list of other files in same directory as</span></span><br><span class="line"><span class="comment"> *         file Addtionally, create a test class which demonstrates the</span></span><br><span class="line"><span class="comment"> *         functionality of your IOFile class!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">FileIo(String fileName) &#123;</span><br><span class="line"><span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countLines</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lineNum = <span class="number">1</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="keyword">char</span>[] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr.read(a);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">lineNum += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lineNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="keyword">char</span>[] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr.read(a);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">System.out.print(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// create a new destination file with the filename</span></span><br><span class="line">File copyfile = <span class="keyword">new</span> File(filename);</span><br><span class="line">copyfile.createNewFile();</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(copyfile);</span><br><span class="line"><span class="comment">// Read the source file</span></span><br><span class="line">File sourcefile = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(sourcefile);</span><br><span class="line"><span class="keyword">char</span>[] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr.read(a);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">fw.write(c);</span><br><span class="line">&#125;</span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">file.delete();</span><br><span class="line"><span class="keyword">if</span> (file.exists() == <span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"delete fail!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"delete success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">System.out.println(file.getParent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getOtherFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; anotherFile = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// first we should get the directory</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.fileName);</span><br><span class="line">String directoryStr = file.getParent();</span><br><span class="line"></span><br><span class="line">File directory = <span class="keyword">new</span> File(directoryStr);</span><br><span class="line"></span><br><span class="line">String[] allfile = directory.list();</span><br><span class="line"><span class="keyword">for</span> (String f : allfile) &#123;</span><br><span class="line"><span class="comment">// filter given file</span></span><br><span class="line"><span class="comment">// We should use equals rather than ==</span></span><br><span class="line"><span class="comment">// because we just need to filter</span></span><br><span class="line"><span class="comment">// by comparing content</span></span><br><span class="line"><span class="keyword">if</span> (!f.equals(file.getName()))</span><br><span class="line">anotherFile.add(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> anotherFile;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SWE</title>
      <link href="/blog/2019/04/11/SWE/"/>
      <url>/blog/2019/04/11/SWE/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-04-09-笔记"><a href="#2019-04-09-笔记" class="headerlink" title="2019-04-09 笔记"></a>2019-04-09 笔记</h1><a id="more"></a><p><br><br><div class="row">    <embed src="SEII3UsabilityEngineeringProject.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><ul><li>Social acceptability: base on culture and region</li></ul><h1 id="SWING"><a href="#SWING" class="headerlink" title="SWING"></a>SWING</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.CheckBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spycsh</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitHodgepodge</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JFrame f = <span class="keyword">new</span> JFrame();</span><br><span class="line">f.setSize(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">f.setTitle(<span class="string">"FruitOrder"</span>);</span><br><span class="line"></span><br><span class="line">JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; allFruitList = <span class="keyword">new</span> HashSet&lt;String&gt;(); <span class="comment">// display all fruit choosed</span></span><br><span class="line"></span><br><span class="line">f.getContentPane().setLayout(<span class="keyword">new</span> FlowLayout());</span><br><span class="line"><span class="comment">//f.add("Nor", new Button("Nor"));</span></span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; boxList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">Collections.addAll(boxList, <span class="string">"apple banana kiwi orange melon grape"</span>.split(<span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line">JCheckBox[] cbs = <span class="keyword">new</span> JCheckBox[boxList.size()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boxList.size(); i++) &#123;</span><br><span class="line">JCheckBox cb = cbs[i] = <span class="keyword">new</span> JCheckBox(boxList.get(i));</span><br><span class="line"></span><br><span class="line">cb.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the event source( checkbox itself)</span></span><br><span class="line">JCheckBox checkBox = (JCheckBox) e.getSource();</span><br><span class="line">System.out.println(checkBox.getText() + <span class="string">" 是否选中: "</span> + checkBox.isSelected());</span><br><span class="line"><span class="keyword">if</span> (checkBox.isSelected())</span><br><span class="line">allFruitList.add(checkBox.getText());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">allFruitList.remove(checkBox.getText());</span><br><span class="line">System.out.println(allFruitList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">panel.add(cb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">JButton btn = <span class="keyword">new</span> JButton();</span><br><span class="line">btn.setText(<span class="string">"Display the order!"</span>);</span><br><span class="line">btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">JOptionPane testOpt = <span class="keyword">new</span> JOptionPane();</span><br><span class="line">testOpt.showMessageDialog(<span class="keyword">new</span> JFrame(), <span class="string">"Your oder:"</span> + <span class="string">"\n"</span> + allFruitList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">panel.add(btn);</span><br><span class="line"></span><br><span class="line">f.setContentPane(panel); <span class="comment">//</span></span><br><span class="line">f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVAFX"><a href="#JAVAFX" class="headerlink" title="JAVAFX"></a>JAVAFX</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> application;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spycsh</span></span><br><span class="line"><span class="comment"> * Main window: user can choose from 6 different fruits</span></span><br><span class="line"><span class="comment"> * After confirming the choice of fruits another window will pop up and tell the user the choice of fruits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;</span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.BorderPane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.Group;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.CheckBox;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.value.ChangeListener;</span><br><span class="line"><span class="keyword">import</span> javafx.beans.value.ObservableValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.GridPane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;</span><br><span class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> javafx.event.EventHandler;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.text.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitHodgepodge</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BorderPane root = <span class="keyword">new</span> BorderPane();</span><br><span class="line"></span><br><span class="line">GridPane gp = <span class="keyword">new</span> GridPane();</span><br><span class="line">Scene scene = <span class="keyword">new</span> Scene(gp, <span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; boxList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">Collections.addAll(boxList, <span class="string">"apple banana kiwi orange melon grape"</span>.split(<span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line">CheckBox[] cbs = <span class="keyword">new</span> CheckBox[boxList.size()];</span><br><span class="line">LinkedList&lt;String&gt; allFruitList = <span class="keyword">new</span> LinkedList&lt;String&gt;(); <span class="comment">// display all fruit choosed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// final CheckBox cb;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; boxList.size(); i++) &#123;</span><br><span class="line"><span class="comment">//            cbs[i] = boxList.poll();</span></span><br><span class="line">CheckBox cb = cbs[i] = <span class="keyword">new</span> CheckBox(boxList.get(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">//            final CheckBox cb0 = new CheckBox("checkBox");</span></span><br><span class="line"><span class="comment">//            final CheckBox cb1 = new CheckBox("aa");</span></span><br><span class="line"></span><br><span class="line">cb.selectedProperty().addListener(<span class="keyword">new</span> ChangeListener&lt;Boolean&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(ObservableValue&lt;? extends Boolean&gt; ov, Boolean old_val, Boolean new_val)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            System.out.println(cb.isSelected());&#125;</span></span><br><span class="line"><span class="keyword">if</span> (new_val) &#123;</span><br><span class="line">allFruitList.offer(cb.getText());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">allFruitList.remove(cb.getText());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(allFruitList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">gp.add(cb, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button btn = <span class="keyword">new</span> Button();</span><br><span class="line">btn.setText(<span class="string">"Display the order!"</span>);</span><br><span class="line">btn.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">Group root = <span class="keyword">new</span> Group();</span><br><span class="line">Scene scene = <span class="keyword">new</span> Scene(root, <span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line"><span class="comment">//Stage stg = new Stage();</span></span><br><span class="line"><span class="comment">//System.out.println((String)allFruitList.toString());</span></span><br><span class="line"><span class="comment">//Pattern pattern = Pattern.compile("'(\\D+)'");</span></span><br><span class="line"><span class="comment">//String i = (String)allFruitList.toString();</span></span><br><span class="line"><span class="comment">//Matcher m = pattern.matcher(i);</span></span><br><span class="line"><span class="comment">//if (m.find())&#123;</span></span><br><span class="line"><span class="comment">//Text text = new Text(100, 100, m.group(1));</span></span><br><span class="line"><span class="comment">//root.getChildren().add(text);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//String[] arr = allFruitList.toString().split("'");</span></span><br><span class="line">System.out.println();</span><br><span class="line">String orderString = <span class="keyword">new</span> String();</span><br><span class="line"><span class="keyword">for</span> (String s : allFruitList) &#123;</span><br><span class="line">orderString += s + <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Text text = <span class="keyword">new</span> Text(<span class="number">100</span>, <span class="number">100</span>, <span class="string">"final order:"</span> + <span class="string">"\n"</span> + orderString);</span><br><span class="line">root.getChildren().add(text);</span><br><span class="line">primaryStage.setScene(scene);</span><br><span class="line">primaryStage.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gp.add(btn, <span class="number">10</span>, <span class="number">0</span>); <span class="comment">// place the button</span></span><br><span class="line"></span><br><span class="line">scene.getStylesheets().add(getClass().getResource(<span class="string">"application.css"</span>).toExternalForm());</span><br><span class="line"></span><br><span class="line">primaryStage.setScene(scene);</span><br><span class="line">primaryStage.show();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">launch(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ds3h</title>
      <link href="/blog/2019/04/09/ds3h/"/>
      <url>/blog/2019/04/09/ds3h/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-04-09-笔记"><a href="#2019-04-09-笔记" class="headerlink" title="2019-04-09 笔记"></a>2019-04-09 笔记</h1><a id="more"></a><p><br><br><div class="row">    <embed src="my_ds01_Introduction.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><blockquote><p>What does a ds do?</p></blockquote><ul><li>share hardwares, software and data</li><li>let computers coordinate and synchronize</li><li>offer users an integrated computing facility not limited by location</li></ul><h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><blockquote><p>What is the essetial part?</p></blockquote><ul><li>auto scaling &amp; load balance</li><li>城市规划例子,when a computer is broken, it will be slower for the system implementation because of the boundary computation which counts on the coordinations one and another computers, so as for synchronization the system have to wait for the slowest computer, with heavier load than others, to process.</li></ul><h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><ul><li><p>(b) filters the redundant info and ensure the useful info procured to minimum.</p></li><li><p>(b) will have a higher speed of response.</p></li></ul><h2 id="P26"><a href="#P26" class="headerlink" title="P26"></a>P26</h2><blockquote><p>What is Mobility Transparency?</p></blockquote><ul><li>eg. Stream serialize deserialize</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>eigen-everthing</title>
      <link href="/blog/2019/04/08/eigen-everthing/"/>
      <url>/blog/2019/04/08/eigen-everthing/</url>
      
        <content type="html"><![CDATA[<h2 id="brief-introduction-of-eigenvalue-and-eigenvector-in-linear-algebra"><a href="#brief-introduction-of-eigenvalue-and-eigenvector-in-linear-algebra" class="headerlink" title="brief introduction of eigenvalue and eigenvector in linear algebra"></a>brief introduction of eigenvalue and eigenvector in linear algebra</h2><a id="more"></a><!-- ![0](eigen-everthing/0.jpg) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/eigen-everthing/0.jpg?raw=true"></p><ul><li><p>determinant 行列式</p></li><li><p>eigenvalue特征值/eigenvector特征向量/eigenspace特征空间(all of the eigenvectors that correspond the eigrnvalue)</p></li><li><p>null space</p></li><li><p>nontrival</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ds2</title>
      <link href="/blog/2019/04/05/ds2/"/>
      <url>/blog/2019/04/05/ds2/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-04-05-笔记"><a href="#2019-04-05-笔记" class="headerlink" title="2019-04-05 笔记"></a>2019-04-05 笔记</h1><a id="more"></a><p><br><br><div class="row">    <embed src="DistSys-2-2019.pdf" width="100%" height="550" type="application/pdf"></div><br><br></p><!-- name the pdf should not comprise space! --><ul><li>make every attribute private and Use getter and setter to access them </li></ul><h2 id="Communication-of-DS"><a href="#Communication-of-DS" class="headerlink" title="Communication of DS"></a>Communication of DS</h2><ul><li><p>synchronous: The sender may block activity until acknowledgement from receiver</p></li><li><p>big-endian大端法 small-endian小端法</p></li><li><p>ASCII, Unicode</p></li><li><p>external data representation and marshalling</p></li></ul><blockquote><p>alternative method</p></blockquote><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li>transforming in bytes and characters</li></ul><blockquote><p>encoded in unicode, must be 2 bytes not 1</p></blockquote><p>class Employee implements Serializable(In China)<br>-&gt; Seralization-&gt;deserialization-&gt;class Employee(In luebeck)</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>说明：建立一个Student类，把它用Stream的方式serialize再deserialize,<br>从而实现信息的传输。</p><p><img src="https://github.com/Spycsh/blog/blob/master/images/ds2/1.jpg?raw=true"></p><h4 id="定义Student类"><a href="#定义Student类" class="headerlink" title="定义Student类"></a>定义Student类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> studentNumber;</span><br><span class="line"><span class="keyword">private</span> String degreeCourse;</span><br><span class="line"></span><br><span class="line">Student(<span class="keyword">int</span> studentNumber, String degreeCourse) &#123;</span><br><span class="line"><span class="keyword">this</span>.studentNumber = studentNumber;</span><br><span class="line"><span class="keyword">this</span>.degreeCourse = degreeCourse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"studentNumber:"</span> + studentNumber + <span class="string">" "</span> + <span class="string">"degreeCourse:"</span> + degreeCourse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="serialize过程"><a href="#serialize过程" class="headerlink" title="serialize过程"></a>serialize过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializing</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test"</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">Student chen = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"ITB"</span>);</span><br><span class="line">oos.writeObject(chen);</span><br><span class="line">oos.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deserialize过程"><a href="#deserialize过程" class="headerlink" title="deserialize过程"></a>deserialize过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeserialize</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"test"</span>);</span><br><span class="line">ObjectInputStream oos = <span class="keyword">new</span> ObjectInputStream(fos);</span><br><span class="line">Student aStudent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">aStudent = (Student) oos.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(aStudent.toString());</span><br><span class="line">oos.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>test文件中显示乱码，是serialize后的字符流<br>deserialize后通过自己定义的toString打印可以输出原来的信息</p><h4 id="疑难"><a href="#疑难" class="headerlink" title="疑难"></a>疑难</h4><ul><li>test文件建在项目文件夹而不是src文件夹下</li><li><blockquote><p>使用ObjectInputStream反序列化的时候，ObjeectInputStream会先读取文件中的serialVersionUID，然后与本地的class文件的serialVersionUID<br>进行对比，如果这两个id不一致，反序列则失败</p></blockquote></li></ul><p>因此在Student class中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>即可</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/fnz0/p/5410856.html" target="_blank" rel="noopener">Source</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学校 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eclipse 高效代码</title>
      <link href="/blog/2019/04/04/Eclipse%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81/"/>
      <url>/blog/2019/04/04/Eclipse%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Eclipse-use-amp-code-convention"><a href="#Eclipse-use-amp-code-convention" class="headerlink" title="Eclipse use &amp; code convention"></a>Eclipse use &amp; code convention</h1><a id="more"></a><h2 id="Eclipse-use"><a href="#Eclipse-use" class="headerlink" title="Eclipse use"></a>Eclipse use</h2><h3 id="项目导出压缩包"><a href="#项目导出压缩包" class="headerlink" title="项目导出压缩包"></a>项目导出压缩包</h3><p>File-&gt;Export-&gt;General-&gt;选择要压缩的类型</p><h3 id="修改缩进等格式-CTRL-SHIFT-F"><a href="#修改缩进等格式-CTRL-SHIFT-F" class="headerlink" title="修改缩进等格式(CTRL+SHIFT+F)"></a>修改缩进等格式(CTRL+SHIFT+F)</h3><p>选中代码-&gt;Source-&gt;Format</p><h3 id="添加javadoc注释（ALT-SHIFT-J"><a href="#添加javadoc注释（ALT-SHIFT-J" class="headerlink" title="添加javadoc注释（ALT+SHIFT+J)"></a>添加javadoc注释（ALT+SHIFT+J)</h3><p>选中元素-&gt;Source-&gt;Generate Element Comment</p><h3 id="改名-ALT-SHIFT-R"><a href="#改名-ALT-SHIFT-R" class="headerlink" title="改名(ALT+SHIFT+R)"></a>改名(ALT+SHIFT+R)</h3><p>选中需要改名的元素-&gt;右键Refactor-&gt;Rename<br>.将会修改文件中所有有这个名字的元素 </p><h3 id="生成javadoc"><a href="#生成javadoc" class="headerlink" title="生成javadoc"></a>生成javadoc</h3><h2 id="code-convention"><a href="#code-convention" class="headerlink" title="code convention"></a>code convention</h2><p><a href="https://www.oracle.com/technetwork/java/codeconventions-150003.pdf" target="_blank" rel="noopener">java code convention</a></p><blockquote><ul><li>Javadoc comment<blockquote><ul><li>Header/Classes</li><li>Functions</li></ul></blockquote></li><li>Name<blockquote><ul><li>Package: student</li><li>Class&amp;Inteface: Student</li><li>variable&amp;method: inputFileSize</li><li>constant:MAXWEIGHT</li></ul></blockquote></li><li>Layout/indentation</li><li>Space</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Information about application for master degree</title>
      <link href="/blog/2019/03/19/Master/"/>
      <url>/blog/2019/03/19/Master/</url>
      
        <content type="html"><![CDATA[<h1 id="德电160硕士申请"><a href="#德电160硕士申请" class="headerlink" title="德电160硕士申请"></a>德电160硕士申请</h1><a id="more"></a><h2 id="德国"><a href="#德国" class="headerlink" title="德国"></a>德国</h2><h3 id="信息表"><a href="#信息表" class="headerlink" title="信息表"></a>信息表</h3><table><thead><tr><th style="text-align:center">大学名</th><th style="text-align:center">相关专业名称</th><th style="text-align:center">地点</th><th style="text-align:center">绩点要求</th><th style="text-align:center">托福/GRE要求</th><th style="text-align:center">申请截止日期</th><th style="text-align:center">评价</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://www.rwth-aachen.de/cms/root/Studium/Vor-dem-Studium/Zugangsvoraussetzungen/~ddxf/Zugangsvoraussetzungen-fuer-den-Master/lidx/1/" target="_blank" rel="noopener">亚琛工业大学</a></td><td style="text-align:center"><a href="http://www.rwth-aachen.de/go/id/bowk?lidx=1#aaaaaaaaaaabowl" target="_blank" rel="noopener">Media Infomatics（多媒体信息）</a></td><td style="text-align:center">波恩&amp;亚琛</td><td style="text-align:center"></td><td style="text-align:center">托福90</td><td style="text-align:center">3.1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="http://www.rwth-aachen.de/go/id/bngt?lidx=1#aaaaaaaaaaabngu" target="_blank" rel="noopener">EE,IT,CE</a></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">托福90 GREverbal超过%15，quantitive超过%75</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><a href="http://www.e-technik.tu-dortmund.de/cms1/de/Lehre_Studium/Studienangebot/Master_A_R/Master_A_R_en/Application_Bewerbung/index.html" target="_blank" rel="noopener">Dortmund 大学</a></td><td style="text-align:center">机器人自动化</td><td style="text-align:center">Dortmund</td><td style="text-align:center"></td><td style="text-align:center">80</td><td style="text-align:center">3.31</td><td style="text-align:center">机器人研究方面很强</td></tr><tr><td style="text-align:center">慕尼黑工业大学</td><td style="text-align:center">ECE</td><td style="text-align:center">慕尼黑</td><td style="text-align:center">3.5+</td><td style="text-align:center">88</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">斯图加特大学</td><td style="text-align:center">infomation technology <a href="https://www.infotech.uni-stuttgart.de/application/index.html" target="_blank" rel="noopener">官网</a> <a href="https://www.daad.de/deutschland/studienangebote/international-programmes/en/detail/3677/" target="_blank" rel="noopener">DAAD网址</a></td><td style="text-align:center">Stuttgart</td><td style="text-align:center">70%ofbest-on-scale, e.g.70%/100%; 2.8/4; 2.5/1.0 (for German Marks)</td><td style="text-align:center">托福80</td><td style="text-align:center">2.15</td><td style="text-align:center">EU citizens do not pay tuition, whereas non-EU citizens pay a tuition of 1,500 EUR per semester.（有学费要求）</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">Computer Science <a href="https://www.informatik.uni-stuttgart.de/studium/interessierte/msc-studiengaenge/msc-computer-science/admission/index.html" target="_blank" rel="noopener">官网</a> <a href="https://www.daad.de/deutschland/studienangebote/international-programmes/en/detail/4439/#tab_overview" target="_blank" rel="noopener">DAAD网址</a></td><td style="text-align:center"></td><td style="text-align:center">无</td><td style="text-align:center">托福80</td><td style="text-align:center">2.15（winter semester） 6.15(summer semester)</td><td style="text-align:center">Bachelor’s degree with a programme duration of at least six semesters in computer science, software engineering, or in a closely related subject(专业匹配度可能较低)EU citizens do not pay tuition, whereas non-EU citizens pay a tuition of 1,500 EUR per semester.（有学费要求）</td></tr><tr><td style="text-align:center">Saarland University萨尔大学</td><td style="text-align:center">Saarbrücken Graduate School of Computer Science</td><td style="text-align:center">Saarbrücken</td><td style="text-align:center">75%以上</td><td style="text-align:center">推荐GRE，托福95/120</td><td style="text-align:center">11/15；根据专业</td><td style="text-align:center">不用学费，强在：马普所，视觉信息但毕业很难，挂科率极高</td></tr><tr><td style="text-align:center">Saarland University萨尔大学<a href="https://www.daad.de/deutschland/studienangebote/international-programmes/en/result/?q=Saarland&amp;degree%5B%5D=&amp;lang%5B%5D=2&amp;fos=&amp;crossFac=&amp;cert=&amp;admReq=&amp;scholarshipLC=&amp;scholarshipSC=&amp;langDeAvailable=&amp;langEnAvailable=&amp;lvlEn%5B%5D=&amp;cit%5B%5D=&amp;tyi%5B%5D=&amp;ins%5B%5D=&amp;fee=&amp;bgn%5B%5D=&amp;dur%5B%5D=&amp;sort=4&amp;subjects%5B%5D=&amp;limit=10&amp;offset=10&amp;display=list" target="_blank" rel="noopener">DAAD网址</a></td><td style="text-align:center">Visual Computing (MSc)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Saarland University萨尔大学</td><td style="text-align:center">Embedded Systems (MSc)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Saarland University萨尔大学</td><td style="text-align:center">Mathematics and Computer Science (MSc)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Saarland University萨尔大学</td><td style="text-align:center">Computer Science (MSc)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">KIT</td><td style="text-align:center">EEM,FE,MPD,MSEM,POM,ISEM</td><td style="text-align:center">Karlsruhe</td><td style="text-align:center"></td><td style="text-align:center">托福90</td><td style="text-align:center">1/15</td><td style="text-align:center">30000欧</td></tr></tbody></table><h3 id="基本简介"><a href="#基本简介" class="headerlink" title="基本简介"></a>基本简介</h3><h4 id="学校概览"><a href="#学校概览" class="headerlink" title="学校概览"></a>学校概览</h4><!-- ![0](Master/德国学校.jpg) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/Master/%E5%BE%B7%E5%9B%BD%E5%AD%A6%E6%A0%A1.jpg?raw=true"></p><h4 id="11所精英大学"><a href="#11所精英大学" class="headerlink" title="11所精英大学"></a>11所精英大学</h4><blockquote><p>理工类3所（慕尼黑工业大学、德累斯顿工业大学、亚琛工业大学），文理类8所<br>（海德堡大学、 柏林自由大学、柏林洪堡大学、慕尼黑大学、图宾根大学、康斯坦茨大学、科隆大学、不莱梅大学）</p></blockquote><!-- ![1](Master/精英大学.png) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/Master/%E7%B2%BE%E8%8B%B1%E5%A4%A7%E5%AD%A6.png?raw=true"></p><blockquote><p>大学名称对应</p></blockquote><!-- ![2](Master/name.png) --><p><img src="https://github.com/Spycsh/blog/blob/master/images/Master/name.png?raw=true"></p><h4 id="TU9"><a href="#TU9" class="headerlink" title="TU9"></a>TU9</h4><blockquote><p>九所德国大学，包括亚琛工业大学RWTH Aachen, 柏林工业大学TU Berlin, 不伦瑞克工业大学TU Braunschweig, 达姆施达特工业大学TU Darmstadt,<br> 德累斯顿工业大学TU Dresden, 莱布尼茨-汉诺威大学Leibniz Universität Hannover,<br>  卡尔斯鲁厄理工学院Karlsruher Institut für Technologie, 慕尼黑工业大学TU München,<br>   斯图加特大学Universität Stuttgart。九所大学都是1900年之前成立的理工高校。<br>   TU9联盟主席Ernst Schmachtenberg博士教授指出，”TU9理工高校联盟就是科研实力的代名词。“</p></blockquote><h4 id="U15"><a href="#U15" class="headerlink" title="U15"></a>U15</h4><blockquote><p>U15大学联盟是德国的大型高校、研究型高校联盟，成立于2012年10月12日。联盟成立宗旨为改善德国科研和教育的架构。占德国高校总数13%的十五所高校，承担了37%的第三方资助、60%的医科资助、43%的博士授予，并获得了43%的莱布尼茨奖。目前联盟主席为海德堡大学校长爱特尔(Bernd Eitel)。<br>联盟成员,柏林自由大学,海德堡大学,柏林洪堡大学,波恩大学,法兰克福大学,弗莱堡大学,哥廷根大学,汉堡大学,科隆大学,莱比锡大学,美因茨大学,慕尼黑大学,明斯特大学,图宾根大学,维尔茨堡大学.</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.daad.de/deutschland/studienangebote/international-programmes/en/result/?crossFac=&amp;cert=&amp;admReq=&amp;scholarshipLC=&amp;scholarshipSC=&amp;degree%5B%5D=&amp;fos=&amp;langDeAvailable=&amp;langEnAvailable=&amp;lang%5B%5D=&amp;cit%5B%5D=&amp;tyi%5B%5D=&amp;ins%5B%5D=&amp;dur%5B%5D=&amp;sort=4&amp;subjects%5B%5D=&amp;q=&amp;limit=10&amp;offset=&amp;display=list" target="_blank" rel="noopener">DAAD查找路径</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>少年的诗</title>
      <link href="/blog/2018/12/13/%E5%B0%91%E5%B9%B4%E7%9A%84%E8%AF%97/"/>
      <url>/blog/2018/12/13/%E5%B0%91%E5%B9%B4%E7%9A%84%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><center>三峡江声流笔底, 六朝帆影落樽前<br><center>胸中机杼，笔底波澜<br><center>写一点诗，总是好的</center></center></center></blockquote><a id="more"></a><h1 id="《侠的诗》"><a href="#《侠的诗》" class="headerlink" title=" 《侠的诗》 "></a><center> 《侠的诗》 </center></h1><center>“傲指弹云分入酒，青冠流古照秋霜”<center>太平无侠士<center>那就写一点诗<center>放浪侠气</center><h2 id="「侠」"><a href="#「侠」" class="headerlink" title=" 「侠」"></a><center> 「侠」</center></h2><center>辞京飘迹楚山茫，</center><br><center>谑眼穿尘淡冕光。</center><br><center>傲指弹云分入酒，</center><br><center>青冠流古照秋霜。</center><h1 id="《少年游》"><a href="#《少年游》" class="headerlink" title=" 《少年游》 "></a><center> 《少年游》 </center></h1><center>“花有重开日，人无再少年”<center>最好的时光<center>总是少年时<center>那走遍的江河</center><h2 id="「入山」"><a href="#「入山」" class="headerlink" title=" 「入山」"></a><center> 「入山」</center></h2><center>山深纵马伫难前，</center><br><center>步下飞光百丈渊。</center><br><center>雾卷云廊封道尽，</center><br><center>雨开峰骨作桥源。</center><br><center>悠笛风远惊人迹，</center><br><center>长海际回忆陌年。</center><br><center>绝处寻松掬水月，</center><br><center>春秋一脉本多缘。</center><h2 id="「古原雨」"><a href="#「古原雨」" class="headerlink" title=" 「古原雨」"></a><center> 「古原雨」</center></h2><center>故迹青鸦驻，三江入古原。</center><br><center>立堤涛水逝，临野聚峰眠。</center><br><center>塔外清魂雨，烟间断梦田。</center><br><center>萧霜凋旧木，归马闭门前。</center><h2 id="「题赛里木湖」"><a href="#「题赛里木湖」" class="headerlink" title=" 「题赛里木湖」"></a><center> 「题赛里木湖」</center></h2><center>深云压海境，微雨落晶珠。</center><br><center>几骑寻闲客，风波自在途。</center><h1 id="《韵之心》"><a href="#《韵之心》" class="headerlink" title=" 《韵之心》 "></a><center> 《韵之心》 </center></h1><center>古有琴谱阳关三叠<br><center>“劝君更进一杯酒，西出阳关无故人”<br><center>古有诗歌驻马衔杯<br><center>“圣代即今多雨露，暂时分手莫踌躇”</center><h2 id="「缘深缘浅，留念诸君」"><a href="#「缘深缘浅，留念诸君」" class="headerlink" title=" 「缘深缘浅，留念诸君」"></a><center> 「缘深缘浅，留念诸君」</center></h2><center>何泣春江归晚照？松风水落对槐花。</center><br><center>遗朝柳折留寻念，此坊歌倾续梦茶。</center><br><center>解带吹心风作客，流光转忆泪分霞。</center><br><center>云终不见诸君影，碧海行帆懒问涯。</center><h2 id="「岳麓•祭•忆君之风忆水长」"><a href="#「岳麓•祭•忆君之风忆水长」" class="headerlink" title=" 「岳麓•祭•忆君之风忆水长」 "></a><center> 「岳麓•祭•忆君之风忆水长」 </center></h2><center>望尽湘江暮，亭间墨客愁。</center><br><center>满林兼叶落，独木与谁谋！</center><br><center>老雁飞斜镜，青衫立冷丘。</center><br><center>出钩疑钓叟，惟是月如舟。</center><h2 id="「早僧」"><a href="#「早僧」" class="headerlink" title=" 「早僧」 "></a><center> 「早僧」 </center></h2><center>拾枫一院露寒时，</center><br><center>早寺空门扫絮垂。</center><br><center>香火何堪折世浪，</center><br><center>且燃芯紫告人痴。</center><h1 id="《家国情》"><a href="#《家国情》" class="headerlink" title=" 《家国情》 "></a><center> 《家国情》 </center></h1><center>“王师北定中原日”<center>太平年间<center>曾经的荣辱仿佛被渐渐淡化了<center>而那血脉奔腾的黄河长江<center>却依然肃穆</center><h2 id="「记南京大屠杀」"><a href="#「记南京大屠杀」" class="headerlink" title=" 「记南京大屠杀」 "></a><center> 「记南京大屠杀」 </center></h2><center>寇兵侵戮昔悲史，</center><br><center>瑟瑟汗青警自鸣。</center><br><center>国父陵前国尽复，</center><br><center>雨花台上雨堪惊！</center><br><center>三江拾恨祭英骨，</center><br><center>亿气同途筑远程。</center><br><center>勿任危心流海去，</center><br><center>涯间舟载惜天明。</center></center></center></center></center></center></center></center></center></center></center></center></center></center>]]></content>
      
      
      
    </entry>
    
  
  
</search>
